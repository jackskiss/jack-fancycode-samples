{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"dev",
				"dev_id"
			],
			[
				"d",
				"d_type"
			],
			[
				"h",
				"hci_1"
			],
			[
				"hc",
				"hci_0"
			],
			[
				"num",
				"num_hci"
			],
			[
				"en",
				"entry"
			],
			[
				"de",
				"dev_id"
			],
			[
				"K",
				"KERNEL_PATH"
			],
			[
				"B",
				"BT_PATH"
			],
			[
				"INC",
				"INCPATH"
			],
			[
				"IN",
				"INCPATH"
			],
			[
				"L",
				"LIBS"
			],
			[
				"GS",
				"GSTREMER_LIB"
			],
			[
				"sys",
				"--sysroot"
			],
			[
				"includ",
				"include"
			],
			[
				"T",
				"TARGETELF"
			],
			[
				"TAR",
				"TARGET"
			]
		]
	},
	"buffers":
	[
		{
			"file": "/usr/include/bluetooth/hci_lib.h",
			"settings":
			{
				"buffer_size": 9916,
				"line_ending": "Unix"
			}
		},
		{
			"file": "Makefile",
			"settings":
			{
				"buffer_size": 1525,
				"line_ending": "Unix"
			}
		},
		{
			"file": "hcilocal.h",
			"settings":
			{
				"buffer_size": 525,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n* browser.c\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <dirent.h>\n#include <errno.h>\n#include <string.h>\n#include <bluetooth/bluetooth.h>\n#include <bluetooth/hci.h>\n#include <bluetooth/hci_lib.h>\n#include <sys/ioctl.h>\n#include <hcilocal.h>\n\n#define SYS_HCI_DIR \"/sys/class/bluetooth\"\n\nstatic int hci_count()\n{\n	int count = 0;\n	DIR * dirp;\n	struct dirent * entry;\n\n	dirp = opendir(SYS_HCI_DIR);\n\n	if(dirp == NULL) {\n		perror(\"Cannot open dir\");\n		return -1;\n	}\n\n	while((entry = readdir(dirp)) != NULL)\n	{\n		if (entry->d_type == DT_LNK) { /* directory type is not unknown */\n//		if (entry->d_type != DT_UNKNOWN) { /* directory type is not unknown */\n			printf(\"%s type is %d\\n\", entry->d_name, entry->d_type);\n			count++;\n		}\n	}\n\n	closedir(dirp);\n\n	return count;\n}\n\nstatic void hci_info(int devid)\n{\n	int ret;\n	struct hci_dev_info info;\n\n	//get_name()\n\n//	ret = hci_dev_info (devid, &info);\n\n/*	struct hci_dev_info {\n		uint16_t dev_id;\n		char     name[8];\n\n		bdaddr_t bdaddr;\n\n		uint32_t flags;\n		uint8_t  type;\n\n		uint8_t  features[8];\n\n		uint32_t pkt_type;\n		uint32_t link_policy;\n		uint32_t link_mode;\n\n		uint16_t acl_mtu;\n		uint16_t acl_pkts;\n		uint16_t sco_mtu;\n		uint16_t sco_pkts;\n\n		struct   hci_dev_stats stat;\n	};	\n*/\n}\n\n\n\nint main(int argc, char **argv)\n{\n	inquiry_info *ii = NULL;\n	int dev_id, sock;\n	int len, i;\n	int num_rsp, max_rsp, flags;\n	int num_hci;\n	int   devs[16];\n\n	char addr[19] = { 0 };\n	char name[248] = { 0 };\n	bdaddr_t leadd_0 = {{0x00, 0x19, 0x0e, 0x15, 0x57, 0x23}};\n	bdaddr_t leadd_1 = {{0xe0, 0x2a, 0x82, 0xc7, 0xa1, 0xd9}};\n\n	char * hci_0 = \"00:19:0e:15:57:23\";\n	char * hci_1 = \"e0:2a:82:c7:a1:d9\";\n\n	num_hci = hci_count();\n\n//	dev_id = hci_get_route(NULL);\n	dev_id = hci_get_route(&leadd_1);\n\n	printf(\"device id : %d\\n\", dev_id);\n\n	dev_id = hci_devid(hci_0);	\n\n	printf(\"device id : %d\\n\", dev_id);\n\n	dev_id = hci_devid(hci_1);	\n\n	printf(\"device id : %d\\n\", dev_id);\n\n	ba2str(&leadd_0, name);\n\n	printf(\"hci_0 address : %s\\n\", name);\n\n	printf(\"Adaptor number : %d\\n\", num_hci);\n\n	if (num_hci <= 0) {\n		perror(\"No hci device\");\n		exit(1);\n	}\n\n	for (dev_id = 0 ; dev_id < num_hci; dev_id++)\n	{\n		sock = hci_open_dev(dev_id);\n\n		cmd_scan(sock, dev_id, \"piscan\");\n\n	    len  = 8;\n	    max_rsp = 255;\n	    flags = IREQ_CACHE_FLUSH;\n	    ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info));\n	    \n	    num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, &ii, flags);\n	    if( num_rsp < 0 ) perror(\"hci_inquiry\");\n\n	    printf (\"num_rsp : %d\\n\", num_rsp);\n\n	    for (i = 0; i < num_rsp; i++) {\n	        ba2str(&(ii+i)->bdaddr, addr);\n	        memset(name, 0, sizeof(name));\n	        /* Display scanned device list */\n	        if (hci_read_remote_name(sock, &(ii+i)->bdaddr, sizeof(name), \n	            name, 0) < 0)\n	        strcpy(name, \"[unknown]\");\n	        printf(\"%s  %s\\n\", addr, name);\n	    }\n\n	    free( ii );\n	    close( sock );\n	    hci_close_dev(dev_id);\n	}\n\n	return 0;\n}\n",
			"file": "browser.c",
			"file_size": 3512,
			"file_write_time": 130819912077613146,
			"settings":
			{
				"buffer_size": 2967,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/x86_64-linux-gnu/bits/socket.h",
			"settings":
			{
				"buffer_size": 12741,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/bluetooth/bluetooth.h",
			"settings":
			{
				"buffer_size": 7588,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/bluetooth/hci.h",
			"settings":
			{
				"buffer_size": 61964,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "Searching 4624 files for \"HCIGETDEVINFO\"\n\n/usr/include/bluetooth/hci.h:\n   89  \n   90  #define HCIGETDEVLIST	_IOR('H', 210, int)\n   91: #define HCIGETDEVINFO	_IOR('H', 211, int)\n   92  #define HCIGETCONNLIST	_IOR('H', 212, int)\n   93  #define HCIGETCONNINFO	_IOR('H', 213, int)\n\n~/projects/opensource/bluez/lib/.hci.h.swp:\n    <binary>\n\n/home/jack/projects/opensource/bluez/lib/hci.c:\n  880  	struct hci_dev_info di = { .dev_id = dev_id };\n  881  \n  882: 	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))\n  883  		return 0;\n  884  \n  ...\n  893  	struct hci_dev_info di = { .dev_id = dev_id };\n  894  \n  895: 	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))\n  896  		return 0;\n  897  \n  ...\n  941  \n  942  	di->dev_id = dev_id;\n  943: 	ret = ioctl(dd, HCIGETDEVINFO, (void *) di);\n  944  \n  945  	err = errno;\n\n/home/jack/projects/opensource/bluez/lib/hci.h:\n   89  \n   90  #define HCIGETDEVLIST	_IOR('H', 210, int)\n   91: #define HCIGETDEVINFO	_IOR('H', 211, int)\n   92  #define HCIGETCONNLIST	_IOR('H', 212, int)\n   93  #define HCIGETCONNINFO	_IOR('H', 213, int)\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/hci.h:\n   89  \n   90  #define HCIGETDEVLIST	_IOR('H', 210, int)\n   91: #define HCIGETDEVINFO	_IOR('H', 211, int)\n   92  #define HCIGETCONNLIST	_IOR('H', 212, int)\n   93  #define HCIGETCONNINFO	_IOR('H', 213, int)\n\n/home/jack/projects/opensource/bluez/monitor/hcidump.c:\n  206  	di.dev_id = index;\n  207  \n  208: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0) {\n  209  		perror(\"Failed to get device information\");\n  210  		return;\n\n/home/jack/projects/opensource/bluez/tools/amptest.c:\n   57  	di.dev_id = dev_id;\n   58  \n   59: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0) {\n   60  		perror(\"Failed to get HCI device info\");\n   61  		close(fd);\n   ..\n  526  		di.dev_id = (dr + i)->dev_id;\n  527  \n  528: 		if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0)\n  529  			continue;\n  530  \n\n/home/jack/projects/opensource/bluez/tools/btinfo.c:\n   76  #define HCIDEVUP	_IOW('H', 201, int)\n   77  #define HCIDEVDOWN	_IOW('H', 202, int)\n   78: #define HCIGETDEVINFO	_IOR('H', 211, int)\n   79  \n   80  #define HCI_UP		(1 << 0)\n   ..\n  302  	hci_info.dev_id = index;\n  303  \n  304: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &hci_info) < 0) {\n  305  		perror(\"Failed to get HCI device information\");\n  306  		close(fd);\n\n/home/jack/projects/opensource/bluez/tools/cltest.c:\n  226  		di.dev_id = (dr + i)->dev_id;\n  227  \n  228: 		if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0)\n  229  			continue;\n  230  \n\n/home/jack/projects/opensource/bluez/tools/hciconfig.c:\n   75  	for (i = 0; i< dl->dev_num; i++) {\n   76  		di.dev_id = (dr+i)->dev_id;\n   77: 		if (ioctl(ctl, HCIGETDEVINFO, (void *) &di) < 0)\n   78  			continue;\n   79  		print_dev_info(ctl, &di);\n   ..\n 2010  	argc--; argv++;\n 2011  \n 2012: 	if (ioctl(ctl, HCIGETDEVINFO, (void *) &di)) {\n 2013  		perror(\"Can't get device info\");\n 2014  		exit(1);\n\n/home/jack/projects/opensource/bluez/tools/hcitool.c:\n   98  	char addr[18];\n   99  \n  100: 	if (ioctl(s, HCIGETDEVINFO, (void *) &di))\n  101  		return 0;\n  102  \n\n16 matches across 11 files\n\n\nSearching 4676 files for \"HCIDEVUP\"\n\n/usr/include/bluetooth/hci.h:\n   83  \n   84  /* HCI ioctl defines */\n   85: #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   87  #define HCIDEVRESET	_IOW('H', 203, int)\n\n/home/jack/projects/opensource/bluez/ChangeLog:\n  468  	Fix issue with stopping inquiry before adapter is initialized.\n  469  	Fix issue with creating device object when connection fails.\n  470: 	Fix issue with sending HCIDEVUP when adapter is already up.\n  471  	Fix issue with handling bonding IO channel closing.\n  472  	Fix agent cancellation in security mode 3 situations.\n\n~/projects/opensource/bluez/lib/.hci.h.swp:\n    <binary>\n\n/home/jack/projects/opensource/bluez/lib/hci.h:\n   83  \n   84  /* HCI ioctl defines */\n   85: #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   87  #define HCIDEVRESET	_IOW('H', 203, int)\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/hci.h:\n   83  \n   84  /* HCI ioctl defines */\n   85: #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   87  #define HCIDEVRESET	_IOW('H', 203, int)\n\n/home/jack/projects/opensource/bluez/tools/amptest.c:\n   64  \n   65  	if (!hci_test_bit(HCI_UP, &di.flags)) {\n   66: 		if (ioctl(fd, HCIDEVUP, dev_id) < 0) {\n   67  			if (errno != EALREADY) {\n   68  				perror(\"Failed to bring up HCI device\");\n\n/home/jack/projects/opensource/bluez/tools/bdaddr.c:\n  465  			//ioctl(dd, HCIDEVRESET, dev);\n  466  			//ioctl(dd, HCIDEVDOWN, dev);\n  467: 			//ioctl(dd, HCIDEVUP, dev);\n  468  \n  469  			hci_close_dev(dd);\n\n/home/jack/projects/opensource/bluez/tools/btinfo.c:\n   74  };\n   75  \n   76: #define HCIDEVUP	_IOW('H', 201, int)\n   77  #define HCIDEVDOWN	_IOW('H', 202, int)\n   78  #define HCIGETDEVINFO	_IOR('H', 211, int)\n   ..\n  311  		printf(\"Powering on controller\\n\");\n  312  \n  313: 		if (ioctl(fd, HCIDEVUP, hci_info.dev_id) < 0) {\n  314  			perror(\"Failed to power on controller\");\n  315  			close(fd);\n\n/home/jack/projects/opensource/bluez/tools/cltest.c:\n  157  		printf(\"Activating controller %s\\n\", addr);\n  158  \n  159: 		if (ioctl(fd, HCIDEVUP, di->dev_id) < 0) {\n  160  			if (errno != EALREADY) {\n  161  				perror(\"Failed to bring up HCI device\");\n\n/home/jack/projects/opensource/bluez/tools/hciattach_ath3k.c:\n  885  	}\n  886  \n  887: 	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {\n  888  		perror(\"hci down:Power management Disabled\");\n  889  		hci_close_dev(dd);\n\n/home/jack/projects/opensource/bluez/tools/hciattach_ti.c:\n  519  	}\n  520  \n  521: 	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {\n  522  		fprintf(stderr, \"Can't init device hci%d: %s (%d)\", dev_id,\n  523  							strerror(errno), errno);\n\n/home/jack/projects/opensource/bluez/tools/hciconfig.c:\n  473  {\n  474  	/* Start HCI device */\n  475: 	if (ioctl(ctl, HCIDEVUP, hdev) < 0) {\n  476  		if (errno == EALREADY)\n  477  			return;\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_sock.c:\n  584  		return hci_get_conn_list(argp);\n  585  \n  586: 	case HCIDEVUP:\n  587  		if (!capable(CAP_NET_ADMIN))\n  588  			return -EPERM;\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci.h:\n  141  \n  142  /* HCI ioctl defines */\n  143: #define HCIDEVUP	_IOW('H', 201, int)\n  144  #define HCIDEVDOWN	_IOW('H', 202, int)\n  145  #define HCIDEVRESET	_IOW('H', 203, int)\n\n15 matches across 14 files\n\n\nSearching 4676 files for \"ioctl\"\n\n~/projects/jack-fancycode-samples/bluez/le/browser/browser:\n    <binary>\n\n/home/jack/projects/jack-fancycode-samples/bluez/le/browser/browser.c:\n   13  #include <bluetooth/hci.h>\n   14  #include <bluetooth/hci_lib.h>\n   15: #include <sys/ioctl.h>\n   16  #include <hcilocal.h>\n   17  \n\n/home/jack/projects/jack-fancycode-samples/bluez/le/browser/hcilocal.c:\n   22  #endif\n   23  \n   24: 	if (ioctl(ctl, HCISETSCAN, (unsigned long) &dr) < 0) {\n   25  		fprintf(stderr, \"Can't set scan mode on hci%d: %s (%d)\\n\",\n   26  						hdev, strerror(errno), errno);\n\n/usr/include/ifaddrs.h:\n   32  \n   33    char *ifa_name;		/* Name of this network interface.  */\n   34:   unsigned int ifa_flags;	/* Flags as from SIOCGIFFLAGS ioctl.  */\n   35  \n   36    struct sockaddr *ifa_addr;	/* Network address of this interface.  */\n\n/usr/include/pty.h:\n   23  \n   24  #include <termios.h>\n   25: #include <sys/ioctl.h>\n   26  \n   27  \n\n/usr/include/sgtty.h:\n   21  #include <features.h>\n   22  \n   23: #include <sys/ioctl.h>\n   24  \n   25: /* On some systems this type is not defined by <bits/ioctl-types.h>;\n   26     in that case, the functions are just stubs that return ENOSYS.  */\n   27  struct sgttyb;\n\n/usr/include/stropts.h:\n   65     One argument may follow; its presence and type depend on REQUEST.\n   66     Return value depends on REQUEST.  Usually -1 indicates error.  */\n   67: extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;\n   68  \n   69  /* Send a message on a STREAM.\n\n/usr/include/termio.h:\n    1: /* Compatible <termio.h> for old `struct termio' ioctl interface.\n    2     This is obsolete; use the POSIX.1 `struct termios' interface\n    3     defined in <termios.h> instead.  */\n    4  \n    5  #include <termios.h>\n    6: #include <sys/ioctl.h>\n    7  \n\n/usr/include/xf86drm.h:\n   50  #if defined(__linux__)\n   51  \n   52: #define DRM_IOCTL_NR(n)		_IOC_NR(n)\n   53  #define DRM_IOC_VOID		_IOC_NONE\n   54  #define DRM_IOC_READ		_IOC_READ\n   ..\n   60  \n   61  #include <sys/ioccom.h>\n   62: #define DRM_IOCTL_NR(n)         ((n) & 0xff)\n   63  #define DRM_IOC_VOID            IOC_VOID\n   64  #define DRM_IOC_READ            IOC_OUT\n   ..\n  112  } drmHashEntry;\n  113  \n  114: extern int drmIoctl(int fd, unsigned long request, void *arg);\n  115  extern void *drmGetHashTable(void);\n  116  extern drmHashEntry *drmGetEntry(int fd);\n\n/usr/include/X11/Xtrans/Xtrans.c:\n  120  \n  121  #ifdef WIN32\n  122: #define ioctl ioctlsocket\n  123  #endif\n  124  \n  ...\n  696  	    int arg;\n  697  	    arg = 1;\n  698: 	    ret = ioctl (fd, FIOSNBIO, &arg);\n  699  	}\n  700  #else\n  ...\n  709  /* IBM TCP/IP understands this option too well: it causes TRANS(Read) to fail\n  710   * eventually with EWOULDBLOCK */\n  711: 	    ret = ioctl (fd, FIONBIO, &arg);\n  712  	}\n  713  #else\n\n/usr/include/X11/Xtrans/Xtranslcl.c:\n   74  #include <ctype.h>\n   75  #include <sys/signal.h>\n   76: #include <sys/ioctl.h>\n   77  #include <sys/stat.h>\n   78  #if defined(SVR4) || defined(__SVR4)\n   ..\n  790      }\n  791  \n  792:     if( ioctl(pipefd[0], I_PUSH, \"connld\") != 0) {\n  793: 	prmsg(1, \"NAMEDOpenPipe: ioctl(I_PUSH,\\\"connld\\\") failed, errno=%d\\n\",errno);\n  794  	close(pipefd[0]);\n  795  	close(pipefd[1]);\n  ...\n  891      prmsg(2,\"NAMEDAccept(%p->%d)\\n\", ciptr, ciptr->fd);\n  892  \n  893:     if( ioctl(ciptr->fd, I_RECVFD, &str ) < 0 ) {\n  894: 	prmsg(1, \"NAMEDAccept: ioctl(I_RECVFD) failed, errno=%d\\n\", errno);\n  895  	*status = TRANS_ACCEPT_MISC_ERROR;\n  896  	return(-1);\n  ...\n  956      sbuf.flags = 0;\n  957  \n  958:     if( ioctl(fd1, I_FDINSERT, &sbuf) < 0 )\n  959  	return(-1);\n  960  \n  ...\n 1182  \n 1183      if (connect_spipe(fds, fdr)) {\n 1184: 	prmsg(1,\"SCOOpenServer: ioctl(I_FDINSERT) failed on %s\\n\",\n 1185  	      serverS_path);\n 1186  	close (fdr);\n ....\n 1229  \n 1230      if (connect_spipe (ciptr->fd, fd) < 0) {\n 1231: 	prmsg(1,\"SCOAccept: ioctl(I_FDINSERT) failed\\n\");\n 1232  	close (fd);\n 1233  	*status = TRANS_ACCEPT_MISC_ERROR;\n ....\n 2240  \n 2241  #if defined(SCO325)\n 2242:     return ioctl(ciptr->fd, I_NREAD, (char *)pend);\n 2243  #else\n 2244:     return ioctl(ciptr->fd, FIONREAD, (char *)pend);\n 2245  #endif\n 2246  }\n\n/usr/include/X11/Xtrans/Xtranssock.c:\n  108  #endif /* !NO_TCP_H */\n  109  \n  110: #include <sys/ioctl.h>\n  111  #if defined(SVR4) || defined(__SVR4)\n  112  #include <sys/filio.h>\n  ...\n 2109  #ifdef WIN32\n 2110      {\n 2111: 	int ret = ioctlsocket ((SOCKET) ciptr->fd, FIONREAD, (u_long *) pend);\n 2112  	if (ret == SOCKET_ERROR) errno = WSAGetLastError();\n 2113  	return ret;\n ....\n 2115  #else\n 2116  #if defined(__i386__) && defined(SYSV) && !defined(SCO325)\n 2117:     return ioctl (ciptr->fd, I_NREAD, (char *) pend);\n 2118  #else\n 2119:     return ioctl (ciptr->fd, FIONREAD, (char *) pend);\n 2120  #endif /* __i386__ && SYSV || _SEQUENT_ && _SOCKET_VERSION == 1 */\n 2121  #endif /* WIN32 */\n\n/usr/include/alsa/hwdep.h:\n  103  int snd_hwdep_dsp_status(snd_hwdep_t *hwdep, snd_hwdep_dsp_status_t *status);\n  104  int snd_hwdep_dsp_load(snd_hwdep_t *hwdep, snd_hwdep_dsp_image_t *block);\n  105: int snd_hwdep_ioctl(snd_hwdep_t *hwdep, unsigned int request, void * arg);\n  106  ssize_t snd_hwdep_write(snd_hwdep_t *hwdep, const void *buffer, size_t size);\n  107  ssize_t snd_hwdep_read(snd_hwdep_t *hwdep, void *buffer, size_t size);\n\n/usr/include/alsa/pcm_plugin.h:\n   69  		    int card, int device, int subdevice,\n   70  		    snd_pcm_stream_t stream, int mode,\n   71: 		    int mmap_emulation, int sync_ptr_ioctl);\n   72  int _snd_pcm_hw_open(snd_pcm_t **pcmp, const char *name,\n   73  		     snd_config_t *root ATTRIBUTE_UNUSED, snd_config_t *conf,\n\n/usr/include/alsa/sound/asound_fm.h:\n   94  \n   95  /*\n   96:  *  FM mode ioctl settings\n   97   */\n   98  \n   99: #define SNDRV_DM_FM_IOCTL_INFO		_IOR('H', 0x20, struct snd_dm_fm_info)\n  100: #define SNDRV_DM_FM_IOCTL_RESET		_IO ('H', 0x21)\n  101: #define SNDRV_DM_FM_IOCTL_PLAY_NOTE	_IOW('H', 0x22, struct snd_dm_fm_note)\n  102: #define SNDRV_DM_FM_IOCTL_SET_VOICE	_IOW('H', 0x23, struct snd_dm_fm_voice)\n  103: #define SNDRV_DM_FM_IOCTL_SET_PARAMS	_IOW('H', 0x24, struct snd_dm_fm_params)\n  104: #define SNDRV_DM_FM_IOCTL_SET_MODE	_IOW('H', 0x25, int)\n  105  /* for OPL3 only */\n  106: #define SNDRV_DM_FM_IOCTL_SET_CONNECTION	_IOW('H', 0x26, int)\n  107  /* SBI patch management */\n  108: #define SNDRV_DM_FM_IOCTL_CLEAR_PATCHES	_IO ('H', 0x40)\n  109  \n  110: #define SNDRV_DM_FM_OSS_IOCTL_RESET		0x20\n  111: #define SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE		0x21\n  112: #define SNDRV_DM_FM_OSS_IOCTL_SET_VOICE		0x22\n  113: #define SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS	0x23\n  114: #define SNDRV_DM_FM_OSS_IOCTL_SET_MODE		0x24\n  115: #define SNDRV_DM_FM_OSS_IOCTL_SET_OPL		0x25\n  116  \n  117  /*\n\n/usr/include/alsa/sound/emu10k1.h:\n  332  } emu10k1_fx8010_pcm_t;\n  333  \n  334: #define SNDRV_EMU10K1_IOCTL_INFO	_IOR ('H', 0x10, emu10k1_fx8010_info_t)\n  335: #define SNDRV_EMU10K1_IOCTL_CODE_POKE	_IOW ('H', 0x11, emu10k1_fx8010_code_t)\n  336: #define SNDRV_EMU10K1_IOCTL_CODE_PEEK	_IOWR('H', 0x12, emu10k1_fx8010_code_t)\n  337: #define SNDRV_EMU10K1_IOCTL_TRAM_SETUP	_IOW ('H', 0x20, int)\n  338: #define SNDRV_EMU10K1_IOCTL_TRAM_POKE	_IOW ('H', 0x21, emu10k1_fx8010_tram_t)\n  339: #define SNDRV_EMU10K1_IOCTL_TRAM_PEEK	_IOWR('H', 0x22, emu10k1_fx8010_tram_t)\n  340: #define SNDRV_EMU10K1_IOCTL_PCM_POKE	_IOW ('H', 0x30, emu10k1_fx8010_pcm_t)\n  341: #define SNDRV_EMU10K1_IOCTL_PCM_PEEK	_IOWR('H', 0x31, emu10k1_fx8010_pcm_t)\n  342: #define SNDRV_EMU10K1_IOCTL_PVERSION	_IOR ('H', 0x40, int)\n  343: #define SNDRV_EMU10K1_IOCTL_STOP	_IO  ('H', 0x80)\n  344: #define SNDRV_EMU10K1_IOCTL_CONTINUE	_IO  ('H', 0x81)\n  345: #define SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER _IO ('H', 0x82)\n  346: #define SNDRV_EMU10K1_IOCTL_SINGLE_STEP	_IOW ('H', 0x83, int)\n  347: #define SNDRV_EMU10K1_IOCTL_DBG_READ	_IOR ('H', 0x84, int)\n  348  \n  349  #endif	/* __SOUND_EMU10K1_H */\n\n/usr/include/alsa/sound/hdsp.h:\n   45  };\n   46  \n   47: #define SNDRV_HDSP_IOCTL_GET_PEAK_RMS _IOR('H', 0x40, hdsp_peak_rms_t)\n   48  \n   49  typedef struct _snd_hdsp_config_info hdsp_config_info_t;\n   ..\n   75  };\n   76  \n   77: #define SNDRV_HDSP_IOCTL_GET_CONFIG_INFO _IOR('H', 0x41, hdsp_config_info_t)\n   78  \n   79  typedef struct _snd_hdsp_firmware hdsp_firmware_t;\n   ..\n   83  };\n   84  \n   85: #define SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE _IOW('H', 0x42, hdsp_firmware_t)\n   86  \n   87  typedef struct _snd_hdsp_version hdsp_version_t;\n   ..\n   92  };\n   93  \n   94: #define SNDRV_HDSP_IOCTL_GET_VERSION _IOR('H', 0x43, hdsp_version_t)\n   95  \n   96  typedef struct _snd_hdsp_mixer hdsp_mixer_t;\n   ..\n  100  };\n  101  \n  102: #define SNDRV_HDSP_IOCTL_GET_MIXER _IOR('H', 0x44, hdsp_mixer_t)\n  103  \n  104  typedef struct _snd_hdsp_9632_aeb hdsp_9632_aeb_t;\n  ...\n  109  };\n  110  \n  111: #define SNDRV_HDSP_IOCTL_GET_9632_AEB _IOR('H', 0x45, hdsp_9632_aeb_t)\n  112  \n  113  #endif /* __SOUND_HDSP_H */\n\n/usr/include/alsa/sound/hdspm.h:\n   38  };\n   39  \n   40: /* -------------------- IOCTL Peak/RMS Meters -------------------- */\n   41  \n   42  struct hdspm_peak_rms {\n   ..\n   53  };\n   54  \n   55: #define SNDRV_HDSPM_IOCTL_GET_PEAK_RMS \\\n   56  	_IOR('H', 0x42, struct hdspm_peak_rms)\n   57  \n   58: /* ------------ CONFIG block IOCTL ---------------------- */\n   59  \n   60  struct hdspm_config {\n   ..\n   72  };\n   73  \n   74: #define SNDRV_HDSPM_IOCTL_GET_CONFIG \\\n   75  	_IOR('H', 0x41, struct hdspm_config)\n   76  \n   ..\n   80   * The hdspm_ltc structure contains the current SMPTE\n   81   * timecode and some status information and can be\n   82:  * obtained via SNDRV_HDSPM_IOCTL_GET_LTC or in the\n   83   * hdspm_status struct.\n   84   **/\n   ..\n  112  };\n  113  \n  114: #define SNDRV_HDSPM_IOCTL_GET_LTC _IOR('H', 0x46, struct hdspm_mixer_ioctl)\n  115  \n  116  /**\n  ...\n  169  };\n  170  \n  171: #define SNDRV_HDSPM_IOCTL_GET_STATUS \\\n  172  	_IOR('H', 0x47, struct hdspm_status)\n  173  \n  ...\n  186  };\n  187  \n  188: #define SNDRV_HDSPM_IOCTL_GET_VERSION _IOR('H', 0x48, struct hdspm_version)\n  189  \n  190: /* ------------- get Matrix Mixer IOCTL --------------- */\n  191  \n  192  /* MADI mixer: 64inputs+64playback in 64outputs = 8192 => *4Byte =\n  ...\n  212  };\n  213  \n  214: struct hdspm_mixer_ioctl {\n  215  	struct hdspm_mixer *mixer;\n  216  };\n  217  \n  218: /* use indirect access due to the limit of ioctl bit size */\n  219: #define SNDRV_HDSPM_IOCTL_GET_MIXER _IOR('H', 0x44, struct hdspm_mixer_ioctl)\n  220  \n  221  /* typedefs for compatibility to user-space */\n\n/usr/include/alsa/sound/sb16_csp.h:\n   98  /* HWDEP controls */\n   99  /* get CSP information */\n  100: #define SNDRV_SB_CSP_IOCTL_INFO		_IOR('H', 0x10, snd_sb_csp_info_t)\n  101  /* load microcode to CSP */\n  102: #define SNDRV_SB_CSP_IOCTL_LOAD_CODE	_IOW('H', 0x11, snd_sb_csp_microcode_t)\n  103  /* unload microcode from CSP */\n  104: #define SNDRV_SB_CSP_IOCTL_UNLOAD_CODE	_IO('H', 0x12)\n  105  /* start CSP */\n  106: #define SNDRV_SB_CSP_IOCTL_START	_IOW('H', 0x13, snd_sb_csp_start_t)\n  107  /* stop CSP */\n  108: #define SNDRV_SB_CSP_IOCTL_STOP		_IO('H', 0x14)\n  109  /* pause CSP and DMA transfer */\n  110: #define SNDRV_SB_CSP_IOCTL_PAUSE	_IO('H', 0x15)\n  111  /* restart CSP and DMA transfer */\n  112: #define SNDRV_SB_CSP_IOCTL_RESTART	_IO('H', 0x16)\n  113  \n  114  \n\n/usr/include/alsa/sound/sscape_ioctl.h:\n    1: #ifndef SSCAPE_IOCTL_H\n    2: #define SSCAPE_IOCTL_H\n    3  \n    4  \n\n/usr/include/asm-generic/ioctl.h:\n    1: #ifndef _ASM_GENERIC_IOCTL_H\n    2: #define _ASM_GENERIC_IOCTL_H\n    3  \n    4: /* ioctl command encoding: 32 bits total, command in lower 16 bits,\n    5   * size of the parameter structure in the lower 14 bits of the\n    6   * upper 16 bits.\n    7:  * Encoding the size of the parameter structure in the ioctl request\n    8   * is useful for catching programs compiled with old versions\n    9   * and to avoid overwriting user space outside the user buffer area.\n   ..\n   14  /*\n   15   * The following is for compatibility across the various Linux\n   16:  * platforms.  The generic ioctl numbering scheme doesn't really enforce\n   17   * a type field.  De facto, however, the top 8 bits of the lower 16\n   18   * bits are indeed used as a type field, so we might just as well make\n   ..\n   80  #define _IOWR_BAD(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))\n   81  \n   82: /* used to decode ioctl numbers.. */\n   83  #define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)\n   84  #define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)\n   ..\n   94  #define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)\n   95  \n   96: #endif /* _ASM_GENERIC_IOCTL_H */\n   97  \n\n/usr/include/asm-generic/ioctls.h:\n    1: #ifndef __ASM_GENERIC_IOCTLS_H\n    2: #define __ASM_GENERIC_IOCTLS_H\n    3  \n    4: #include <linux/ioctl.h>\n    5  \n    6  /*\n    7:  * These are the most common definitions for tty ioctl numbers.\n    8   * Most of them do not use the recommended _IOC(), but there is\n    9   * probably some source code out there hardcoding the number,\n   ..\n   97  /*\n   98   * Some arches already define FIOQSIZE due to a historical\n   99:  * conflict with a Hayes modem-specific ioctl value.\n  100   */\n  101  #ifndef FIOQSIZE\n  ...\n  111  #define TIOCPKT_NOSTOP		16\n  112  #define TIOCPKT_DOSTOP		32\n  113: #define TIOCPKT_IOCTL		64\n  114  \n  115  #define TIOCSER_TEMT	0x01	/* Transmitter physically empty */\n  116  \n  117: #endif /* __ASM_GENERIC_IOCTLS_H */\n  118  \n\n/usr/include/asm-generic/termios.h:\n   10  \n   11  #include <asm/termbits.h>\n   12: #include <asm/ioctls.h>\n   13  \n   14  struct winsize {\n   ..\n   45  #define TIOCM_LOOP	0x8000\n   46  \n   47: /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */\n   48  \n   49  \n\n/usr/include/asm-generic/unistd.h:\n  103  __SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)\n  104  \n  105: /* fs/ioctl.c */\n  106: #define __NR_ioctl 29\n  107: __SC_COMP(__NR_ioctl, sys_ioctl, compat_sys_ioctl)\n  108  \n  109  /* fs/ioprio.c */\n\n/usr/include/bluetooth/bnep.h:\n  116  } __attribute__((packed));\n  117  \n  118: /* BNEP ioctl defines */\n  119  #define BNEPCONNADD	_IOW('B', 200, int)\n  120  #define BNEPCONNDEL	_IOW('B', 201, int)\n\n/usr/include/bluetooth/cmtp.h:\n   33  #define CMTP_DEFAULT_MTU 672\n   34  \n   35: /* CMTP ioctl defines */\n   36  #define CMTPCONNADD	_IOW('C', 200, int)\n   37  #define CMTPCONNDEL	_IOW('C', 201, int)\n\n/usr/include/bluetooth/hci.h:\n   82  };\n   83  \n   84: /* HCI ioctl defines */\n   85  #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   ..\n 2304  #define HCI_FLT_OCF_BITS	127\n 2305  \n 2306: /* Ioctl requests structures */\n 2307  struct hci_dev_stats {\n 2308  	uint32_t err_rx;\n\n/usr/include/bluetooth/hidp.h:\n   33  #define HIDP_DEFAULT_MTU 48\n   34  \n   35: /* HIDP ioctl defines */\n   36  #define HIDPCONNADD	_IOW('H', 200, int)\n   37  #define HIDPCONNDEL	_IOW('H', 201, int)\n\n/usr/include/drm/drm.h:\n   40  \n   41  #include <linux/types.h>\n   42: #include <asm/ioctl.h>\n   43  typedef unsigned int drm_handle_t;\n   44  \n   ..\n  122  \n  123  /**\n  124:  * DRM_IOCTL_VERSION ioctl argument type.\n  125   *\n  126   * \\sa drmGetVersion().\n  ...\n  139  \n  140  /**\n  141:  * DRM_IOCTL_GET_UNIQUE ioctl argument type.\n  142   *\n  143   * \\sa drmGetBusid() and drmSetBusId().\n  ...\n  158  \n  159  /**\n  160:  * DRM_IOCTL_CONTROL ioctl argument type.\n  161   *\n  162   * \\sa drmCtlInstHandler() and drmCtlUninstHandler().\n  ...\n  205  \n  206  /**\n  207:  * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls\n  208   * argument type.\n  209   *\n  ...\n  222  \n  223  /**\n  224:  * DRM_IOCTL_GET_CLIENT ioctl argument type.\n  225   */\n  226  struct drm_client {\n  ...\n  230  	unsigned long uid;	/**< User ID */\n  231  	unsigned long magic;	/**< Magic */\n  232: 	unsigned long iocs;	/**< Ioctl count */\n  233  };\n  234  \n  ...\n  237  	_DRM_STAT_OPENS,\n  238  	_DRM_STAT_CLOSES,\n  239: 	_DRM_STAT_IOCTLS,\n  240  	_DRM_STAT_LOCKS,\n  241  	_DRM_STAT_UNLOCKS,\n  ...\n  254  \n  255  /**\n  256:  * DRM_IOCTL_GET_STATS ioctl argument type.\n  257   */\n  258  struct drm_stats {\n  ...\n  280  \n  281  /**\n  282:  * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.\n  283   *\n  284   * \\sa drmGetLock() and drmUnlock().\n  ...\n  319  \n  320  /**\n  321:  * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.\n  322   *\n  323   * \\sa drmAddBufs().\n  ...\n  342  \n  343  /**\n  344:  * DRM_IOCTL_INFO_BUFS ioctl argument type.\n  345   */\n  346  struct drm_buf_info {\n  ...\n  350  \n  351  /**\n  352:  * DRM_IOCTL_FREE_BUFS ioctl argument type.\n  353   */\n  354  struct drm_buf_free {\n  ...\n  370  \n  371  /**\n  372:  * DRM_IOCTL_MAP_BUFS ioctl argument type.\n  373   */\n  374  struct drm_buf_map {\n  ...\n  379  \n  380  /**\n  381:  * DRM_IOCTL_DMA ioctl argument type.\n  382   *\n  383   * Indices here refer to the offset into the buffer list in drm_buf_get.\n  ...\n  404  \n  405  /**\n  406:  * DRM_IOCTL_ADD_CTX ioctl argument type.\n  407   *\n  408   * \\sa drmCreateContext() and drmDestroyContext().\n  ...\n  414  \n  415  /**\n  416:  * DRM_IOCTL_RES_CTX ioctl argument type.\n  417   */\n  418  struct drm_ctx_res {\n  ...\n  422  \n  423  /**\n  424:  * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.\n  425   */\n  426  struct drm_draw {\n  ...\n  429  \n  430  /**\n  431:  * DRM_IOCTL_UPDATE_DRAW ioctl argument type.\n  432   */\n  433  typedef enum {\n  ...\n  443  \n  444  /**\n  445:  * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.\n  446   */\n  447  struct drm_auth {\n  ...\n  450  \n  451  /**\n  452:  * DRM_IOCTL_IRQ_BUSID ioctl argument type.\n  453   *\n  454   * \\sa drmGetInterruptFromBusID().\n  ...\n  492  \n  493  /**\n  494:  * DRM_IOCTL_WAIT_VBLANK ioctl argument type.\n  495   *\n  496   * \\sa drmWaitVBlank().\n  ...\n  505  \n  506  /**\n  507:  * DRM_IOCTL_MODESET_CTL ioctl argument type\n  508   *\n  509   * \\sa drmModesetCtl().\n  ...\n  515  \n  516  /**\n  517:  * DRM_IOCTL_AGP_ENABLE ioctl argument type.\n  518   *\n  519   * \\sa drmAgpEnable().\n  ...\n  524  \n  525  /**\n  526:  * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.\n  527   *\n  528   * \\sa drmAgpAlloc() and drmAgpFree().\n  ...\n  536  \n  537  /**\n  538:  * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.\n  539   *\n  540   * \\sa drmAgpBind() and drmAgpUnbind().\n  ...\n  546  \n  547  /**\n  548:  * DRM_IOCTL_AGP_INFO ioctl argument type.\n  549   *\n  550   * \\sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),\n  ...\n  567  \n  568  /**\n  569:  * DRM_IOCTL_SG_ALLOC ioctl argument type.\n  570   */\n  571  struct drm_scatter_gather {\n  ...\n  575  \n  576  /**\n  577:  * DRM_IOCTL_SET_VERSION ioctl argument type.\n  578   */\n  579  struct drm_set_version {\n  ...\n  584  };\n  585  \n  586: /** DRM_IOCTL_GEM_CLOSE ioctl argument type */\n  587  struct drm_gem_close {\n  588  	/** Handle of the object to be closed. */\n  ...\n  591  };\n  592  \n  593: /** DRM_IOCTL_GEM_FLINK ioctl argument type */\n  594  struct drm_gem_flink {\n  595  	/** Handle for the object being named */\n  ...\n  600  };\n  601  \n  602: /** DRM_IOCTL_GEM_OPEN ioctl argument type */\n  603  struct drm_gem_open {\n  604  	/** Name of object being opened */\n  ...\n  624  #define DRM_CAP_CURSOR_HEIGHT		0x9\n  625  \n  626: /** DRM_IOCTL_GET_CAP ioctl argument type */\n  627  struct drm_get_cap {\n  628  	__u64 capability;\n  ...\n  639  #define DRM_CLIENT_CAP_STEREO_3D	1\n  640  \n  641: /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */\n  642  struct drm_set_client_cap {\n  643  	__u64 capability;\n  ...\n  658  #include <drm/drm_mode.h>\n  659  \n  660: #define DRM_IOCTL_BASE			'd'\n  661: #define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)\n  662: #define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)\n  663: #define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)\n  664: #define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)\n  665  \n  666: #define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)\n  667: #define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)\n  668: #define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)\n  669: #define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)\n  670: #define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)\n  671: #define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)\n  672: #define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)\n  673: #define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)\n  674: #define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)\n  675: #define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)\n  676: #define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)\n  677: #define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)\n  678: #define DRM_IOCTL_GET_CAP		DRM_IOWR(0x0c, struct drm_get_cap)\n  679: #define DRM_IOCTL_SET_CLIENT_CAP	DRM_IOW( 0x0d, struct drm_set_client_cap)\n  680  \n  681: #define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)\n  682: #define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)\n  683: #define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)\n  684: #define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)\n  685: #define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)\n  686: #define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)\n  687: #define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)\n  688: #define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)\n  689: #define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)\n  690: #define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)\n  691: #define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)\n  692  \n  693: #define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)\n  694  \n  695: #define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)\n  696: #define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, struct drm_ctx_priv_map)\n  697  \n  698: #define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)\n  699: #define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)\n  700  \n  701: #define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)\n  702: #define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)\n  703: #define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)\n  704: #define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)\n  705: #define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)\n  706: #define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)\n  707: #define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)\n  708: #define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)\n  709: #define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)\n  710: #define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)\n  711: #define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)\n  712: #define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)\n  713: #define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)\n  714  \n  715: #define DRM_IOCTL_PRIME_HANDLE_TO_FD    DRM_IOWR(0x2d, struct drm_prime_handle)\n  716: #define DRM_IOCTL_PRIME_FD_TO_HANDLE    DRM_IOWR(0x2e, struct drm_prime_handle)\n  717  \n  718: #define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)\n  719: #define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)\n  720: #define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)\n  721: #define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)\n  722: #define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)\n  723: #define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)\n  724: #define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)\n  725: #define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)\n  726  \n  727: #define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)\n  728: #define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)\n  729  \n  730: #define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)\n  731  \n  732: #define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)\n  733  \n  734: #define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)\n  735: #define DRM_IOCTL_MODE_GETCRTC		DRM_IOWR(0xA1, struct drm_mode_crtc)\n  736: #define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)\n  737: #define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)\n  738: #define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)\n  739: #define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)\n  740: #define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)\n  741: #define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)\n  742: #define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd) /* deprecated (never worked) */\n  743: #define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd) /* deprecated (never worked) */\n  744  \n  745: #define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)\n  746: #define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)\n  747: #define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)\n  748: #define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)\n  749: #define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)\n  750: #define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, unsigned int)\n  751: #define DRM_IOCTL_MODE_PAGE_FLIP	DRM_IOWR(0xB0, struct drm_mode_crtc_page_flip)\n  752: #define DRM_IOCTL_MODE_DIRTYFB		DRM_IOWR(0xB1, struct drm_mode_fb_dirty_cmd)\n  753  \n  754: #define DRM_IOCTL_MODE_CREATE_DUMB DRM_IOWR(0xB2, struct drm_mode_create_dumb)\n  755: #define DRM_IOCTL_MODE_MAP_DUMB    DRM_IOWR(0xB3, struct drm_mode_map_dumb)\n  756: #define DRM_IOCTL_MODE_DESTROY_DUMB    DRM_IOWR(0xB4, struct drm_mode_destroy_dumb)\n  757: #define DRM_IOCTL_MODE_GETPLANERESOURCES DRM_IOWR(0xB5, struct drm_mode_get_plane_res)\n  758: #define DRM_IOCTL_MODE_GETPLANE	DRM_IOWR(0xB6, struct drm_mode_get_plane)\n  759: #define DRM_IOCTL_MODE_SETPLANE	DRM_IOWR(0xB7, struct drm_mode_set_plane)\n  760: #define DRM_IOCTL_MODE_ADDFB2		DRM_IOWR(0xB8, struct drm_mode_fb_cmd2)\n  761: #define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)\n  762: #define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)\n  763: #define DRM_IOCTL_MODE_CURSOR2		DRM_IOWR(0xBB, struct drm_mode_cursor2)\n  764  \n  765  /**\n  766:  * Device specific ioctls should only be in their respective headers\n  767:  * The device specific ioctl range is from 0x40 to 0x99.\n  768:  * Generic IOCTLS restart at 0xA0.\n  769   *\n  770   * \\sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and\n  ...\n  778   * type defines the type of event, the length specifies the total\n  779   * length of the event (including the header), and user_data is\n  780:  * typically a 64 bit value passed with the ioctl that triggered the\n  781   * event.  A read on the drm fd will always only return complete\n  782   * events, that is, if for example the read buffer is 100 bytes, and\n\n/usr/include/drm/drm_mode.h:\n  315  \n  316  	/*\n  317: 	 * In case of planar formats, this ioctl allows up to 4\n  318  	 * buffer objects with offets and pitches per plane.\n  319  	 * The pitch and offset order is dictated by the fourcc,\n  ...\n  343   *\n  344   * Some hardware does not automatically update display contents\n  345:  * as a hardware or software draw to a framebuffer. This ioctl\n  346   * allows userspace to tell the kernel and the hardware what\n  347   * regions of the framebuffer have changed.\n  ...\n  438   * Request a page flip on the specified crtc.\n  439   *\n  440:  * This ioctl will ask KMS to schedule a page flip for the specified\n  441   * crtc.  Once any pending rendering targeting the specified fb (as of\n  442:  * ioctl time) has completed, the crtc will be reprogrammed to display\n  443:  * that fb after the next vertical refresh.  The ioctl returns\n  444   * immediately, but subsequent rendering to the current fb will block\n  445:  * in the execbuffer ioctl until the page flip happens.  If a page\n  446:  * flip is already pending as the ioctl is called, EBUSY will be\n  447   * returned.\n  448   *\n  449   * Flag DRM_MODE_PAGE_FLIP_EVENT requests that drm sends back a vblank\n  450   * event (see drm.h: struct drm_event_vblank) when the page flip is\n  451:  * done.  The user_data field passed in with this ioctl will be\n  452   * returned as the user_data field in the vblank event struct.\n  453   *\n\n/usr/include/drm/exynos_drm.h:\n  319  #define DRM_EXYNOS_GEM_MAP_OFFSET	0x01\n  320  #define DRM_EXYNOS_GEM_MMAP		0x02\n  321: /* Reserved 0x03 ~ 0x05 for exynos specific gem ioctl */\n  322  #define DRM_EXYNOS_GEM_GET		0x04\n  323  #define DRM_EXYNOS_VIDI_CONNECTION	0x07\n  ...\n  334  #define DRM_EXYNOS_IPP_CMD_CTRL	0x33\n  335  \n  336: #define DRM_IOCTL_EXYNOS_GEM_CREATE		DRM_IOWR(DRM_COMMAND_BASE + \\\n  337  		DRM_EXYNOS_GEM_CREATE, struct drm_exynos_gem_create)\n  338  \n  339: #define DRM_IOCTL_EXYNOS_GEM_MAP_OFFSET	DRM_IOWR(DRM_COMMAND_BASE + \\\n  340  		DRM_EXYNOS_GEM_MAP_OFFSET, struct drm_exynos_gem_map_off)\n  341  \n  342: #define DRM_IOCTL_EXYNOS_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + \\\n  343  		DRM_EXYNOS_GEM_MMAP, struct drm_exynos_gem_mmap)\n  344  \n  345: #define DRM_IOCTL_EXYNOS_GEM_GET	DRM_IOWR(DRM_COMMAND_BASE + \\\n  346  		DRM_EXYNOS_GEM_GET,	struct drm_exynos_gem_info)\n  347  \n  348: #define DRM_IOCTL_EXYNOS_VIDI_CONNECTION	DRM_IOWR(DRM_COMMAND_BASE + \\\n  349  		DRM_EXYNOS_VIDI_CONNECTION, struct drm_exynos_vidi_connection)\n  350  \n  351: #define DRM_IOCTL_EXYNOS_G2D_GET_VER		DRM_IOWR(DRM_COMMAND_BASE + \\\n  352  		DRM_EXYNOS_G2D_GET_VER, struct drm_exynos_g2d_get_ver)\n  353: #define DRM_IOCTL_EXYNOS_G2D_SET_CMDLIST	DRM_IOWR(DRM_COMMAND_BASE + \\\n  354  		DRM_EXYNOS_G2D_SET_CMDLIST, struct drm_exynos_g2d_set_cmdlist)\n  355: #define DRM_IOCTL_EXYNOS_G2D_EXEC		DRM_IOWR(DRM_COMMAND_BASE + \\\n  356  		DRM_EXYNOS_G2D_EXEC, struct drm_exynos_g2d_exec)\n  357  \n  358: #define DRM_IOCTL_EXYNOS_IPP_GET_PROPERTY	DRM_IOWR(DRM_COMMAND_BASE + \\\n  359  		DRM_EXYNOS_IPP_GET_PROPERTY, struct drm_exynos_ipp_prop_list)\n  360: #define DRM_IOCTL_EXYNOS_IPP_SET_PROPERTY	DRM_IOWR(DRM_COMMAND_BASE + \\\n  361  		DRM_EXYNOS_IPP_SET_PROPERTY, struct drm_exynos_ipp_property)\n  362: #define DRM_IOCTL_EXYNOS_IPP_QUEUE_BUF	DRM_IOWR(DRM_COMMAND_BASE + \\\n  363  		DRM_EXYNOS_IPP_QUEUE_BUF, struct drm_exynos_ipp_queue_buf)\n  364: #define DRM_IOCTL_EXYNOS_IPP_CMD_CTRL		DRM_IOWR(DRM_COMMAND_BASE + \\\n  365  		DRM_EXYNOS_IPP_CMD_CTRL, struct drm_exynos_ipp_cmd_ctrl)\n  366  \n\n/usr/include/drm/i810_drm.h:\n   88  #define I810_TEX_SETUP_SIZE 8\n   89  \n   90: /* Flags for clear ioctl\n   91   */\n   92  #define I810_FRONT   0x1\n   ..\n  191   */\n  192  \n  193: /* i810 specific ioctls\n  194:  * The device specific ioctl range is 0x40 to 0x79.\n  195   */\n  196  #define DRM_I810_INIT		0x00\n  ...\n  210  #define DRM_I810_FLIP		0x0e\n  211  \n  212: #define DRM_IOCTL_I810_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_INIT, drm_i810_init_t)\n  213: #define DRM_IOCTL_I810_VERTEX		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_VERTEX, drm_i810_vertex_t)\n  214: #define DRM_IOCTL_I810_CLEAR		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_CLEAR, drm_i810_clear_t)\n  215: #define DRM_IOCTL_I810_FLUSH		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_FLUSH)\n  216: #define DRM_IOCTL_I810_GETAGE		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_GETAGE)\n  217: #define DRM_IOCTL_I810_GETBUF		DRM_IOWR(DRM_COMMAND_BASE + DRM_I810_GETBUF, drm_i810_dma_t)\n  218: #define DRM_IOCTL_I810_SWAP		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_SWAP)\n  219: #define DRM_IOCTL_I810_COPY		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_COPY, drm_i810_copy_t)\n  220: #define DRM_IOCTL_I810_DOCOPY		DRM_IO(  DRM_COMMAND_BASE + DRM_I810_DOCOPY)\n  221: #define DRM_IOCTL_I810_OV0INFO		DRM_IOR( DRM_COMMAND_BASE + DRM_I810_OV0INFO, drm_i810_overlay_t)\n  222: #define DRM_IOCTL_I810_FSTATUS		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_FSTATUS)\n  223: #define DRM_IOCTL_I810_OV0FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_OV0FLIP)\n  224: #define DRM_IOCTL_I810_MC		DRM_IOW( DRM_COMMAND_BASE + DRM_I810_MC, drm_i810_mc_t)\n  225: #define DRM_IOCTL_I810_RSTATUS		DRM_IO ( DRM_COMMAND_BASE + DRM_I810_RSTATUS)\n  226: #define DRM_IOCTL_I810_FLIP             DRM_IO ( DRM_COMMAND_BASE + DRM_I810_FLIP)\n  227  \n  228  typedef struct _drm_i810_clear {\n\n/usr/include/drm/i915_drm.h:\n  172  #define I915_BOX_LOST_CONTEXT  0x10\n  173  \n  174: /* I915 specific ioctls\n  175:  * The device specific ioctl range is 0x40 to 0x79.\n  176   */\n  177  #define DRM_I915_INIT		0x00\n  ...\n  225  #define DRM_I915_GET_RESET_STATS	0x32\n  226  \n  227: #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)\n  228: #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)\n  229: #define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)\n  230: #define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)\n  231: #define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)\n  232: #define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)\n  233: #define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)\n  234: #define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)\n  235: #define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)\n  236: #define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)\n  237: #define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)\n  238: #define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)\n  239: #define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)\n  240: #define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)\n  241: #define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)\n  242: #define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)\n  243: #define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, struct drm_i915_gem_init)\n  244: #define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)\n  245: #define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)\n  246: #define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)\n  247: #define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)\n  248: #define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)\n  249: #define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)\n  250: #define DRM_IOCTL_I915_GEM_SET_CACHING		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_SET_CACHING, struct drm_i915_gem_caching)\n  251: #define DRM_IOCTL_I915_GEM_GET_CACHING		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_GET_CACHING, struct drm_i915_gem_caching)\n  252: #define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)\n  253: #define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)\n  254: #define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)\n  255: #define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)\n  256: #define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)\n  257: #define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)\n  258: #define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)\n  259: #define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)\n  260: #define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)\n  261: #define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)\n  262: #define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)\n  263: #define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)\n  264: #define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)\n  265: #define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_i915_get_pipe_from_crtc_id)\n  266: #define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)\n  267: #define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)\n  268: #define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)\n  269: #define DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)\n  270: #define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)\n  271: #define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)\n  272: #define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)\n  273: #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)\n  274: #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)\n  275: #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)\n  276  \n  277  /* Allow drivers to submit batchbuffers directly to hardware, relying\n  ...\n  309  } drm_i915_irq_wait_t;\n  310  \n  311: /* Ioctl to query kernel params:\n  312   */\n  313  #define I915_PARAM_IRQ_ACTIVE            1\n  ...\n  344  } drm_i915_getparam_t;\n  345  \n  346: /* Ioctl to set kernel params:\n  347   */\n  348  #define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1\n  ...\n  541  	 * If the buffer has the same offset as last time, we can skip syncing\n  542  	 * and writing the relocation.  This value is written back out by\n  543: 	 * the execbuffer ioctl when the relocation is written.\n  544  	 */\n  545  	__u64 presumed_offset;\n\n/usr/include/drm/mga_drm.h:\n  227  } drm_mga_sarea_t;\n  228  \n  229: /* MGA specific ioctls\n  230:  * The device specific ioctl range is 0x40 to 0x79.\n  231   */\n  232  #define DRM_MGA_INIT     0x00\n  ...\n  242  \n  243  /* 3.2:\n  244:  * ioctls for operating on fences.\n  245   */\n  246  #define DRM_MGA_SET_FENCE      0x0a\n  ...\n  248  #define DRM_MGA_DMA_BOOTSTRAP  0x0c\n  249  \n  250: #define DRM_IOCTL_MGA_INIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INIT, drm_mga_init_t)\n  251: #define DRM_IOCTL_MGA_FLUSH    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_FLUSH, struct drm_lock)\n  252: #define DRM_IOCTL_MGA_RESET    DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_RESET)\n  253: #define DRM_IOCTL_MGA_SWAP     DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_SWAP)\n  254: #define DRM_IOCTL_MGA_CLEAR    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_CLEAR, drm_mga_clear_t)\n  255: #define DRM_IOCTL_MGA_VERTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_VERTEX, drm_mga_vertex_t)\n  256: #define DRM_IOCTL_MGA_INDICES  DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INDICES, drm_mga_indices_t)\n  257: #define DRM_IOCTL_MGA_ILOAD    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_ILOAD, drm_mga_iload_t)\n  258: #define DRM_IOCTL_MGA_BLIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_BLIT, drm_mga_blit_t)\n  259: #define DRM_IOCTL_MGA_GETPARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_GETPARAM, drm_mga_getparam_t)\n  260: #define DRM_IOCTL_MGA_SET_FENCE     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_SET_FENCE, __u32)\n  261: #define DRM_IOCTL_MGA_WAIT_FENCE    DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_WAIT_FENCE, __u32)\n  262: #define DRM_IOCTL_MGA_DMA_BOOTSTRAP DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_DMA_BOOTSTRAP, drm_mga_dma_bootstrap_t)\n  263  \n  264  typedef struct _drm_mga_warp_index {\n  ...\n  303  	 * \\name AGP texture region\n  304  	 *\n  305: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will\n  306  	 * be filled in with the actual AGP texture settings.\n  307  	 *\n  ...\n  319  	 * Requested size of the primary DMA region.\n  320  	 *\n  321: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  322  	 * filled in with the actual AGP mode.  If AGP was not available\n  323  	 */\n  ...\n  327  	 * Requested number of secondary DMA buffers.\n  328  	 *\n  329: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  330  	 * filled in with the actual number of secondary DMA buffers\n  331  	 * allocated.  Particularly when PCI DMA is used, this may be\n  ...\n  349  	 * possible.\n  350  	 *\n  351: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  352  	 * filled in with the actual AGP mode.  If AGP was not available\n  353  	 * (i.e., PCI DMA was used), this value will be zero.\n  ...\n  399  } drm_mga_blit_t;\n  400  \n  401: /* 3.1: An ioctl to get parameters that aren't available to the 3d\n  402   * client any other way.\n  403   */\n\n/usr/include/drm/msm_drm.h:\n   27   *     user/kernel compatibility\n   28   *  2) Keep fields aligned to their size\n   29:  *  3) Because of how drm_ioctl() works, we can add new fields at\n   30:  *     the end of an ioctl if some care is taken: drm_ioctl() will\n   31:  *     zero out the new fields at the tail of the ioctl, so a zero\n   32   *     value should have a backwards compatible meaning.  And for\n   33   *     output params, userspace won't see the newly added output\n   ..\n   41  \n   42  /* timeouts are specified in clock-monotonic absolute times (to simplify\n   43:  * restarting interrupted ioctls).  The following struct is logically the\n   44   * same as 'struct timespec' but 32/64b ABI safe.\n   45   */\n   ..\n  125   *      this buffer in the first-level ringbuffer\n  126   *   CTX_RESTORE_BUF - only executed if there has been a GPU context\n  127:  *      switch since the last SUBMIT ioctl\n  128   */\n  129  #define MSM_SUBMIT_CMD_BUF             0x0001\n  ...\n  174  /* The normal way to synchronize with the GPU is just to CPU_PREP on\n  175   * a buffer if you need to access it from the CPU (other cmdstream\n  176:  * submission from same or other contexts, PAGE_FLIP ioctl, etc, all\n  177:  * handle the required synchronization under the hood).  This ioctl\n  178   * mainly just exists as a way to implement the gallium pipe_fence\n  179   * APIs without requiring a dummy bo to synchronize on.\n  ...\n  195  #define DRM_MSM_GEM_SUBMIT             0x06\n  196  #define DRM_MSM_WAIT_FENCE             0x07\n  197: #define DRM_MSM_NUM_IOCTLS             0x08\n  198  \n  199: #define DRM_IOCTL_MSM_GET_PARAM        DRM_IOWR(DRM_COMMAND_BASE + DRM_MSM_GET_PARAM, struct drm_msm_param)\n  200: #define DRM_IOCTL_MSM_GEM_NEW          DRM_IOWR(DRM_COMMAND_BASE + DRM_MSM_GEM_NEW, struct drm_msm_gem_new)\n  201: #define DRM_IOCTL_MSM_GEM_INFO         DRM_IOWR(DRM_COMMAND_BASE + DRM_MSM_GEM_INFO, struct drm_msm_gem_info)\n  202: #define DRM_IOCTL_MSM_GEM_CPU_PREP     DRM_IOW (DRM_COMMAND_BASE + DRM_MSM_GEM_CPU_PREP, struct drm_msm_gem_cpu_prep)\n  203: #define DRM_IOCTL_MSM_GEM_CPU_FINI     DRM_IOW (DRM_COMMAND_BASE + DRM_MSM_GEM_CPU_FINI, struct drm_msm_gem_cpu_fini)\n  204: #define DRM_IOCTL_MSM_GEM_SUBMIT       DRM_IOWR(DRM_COMMAND_BASE + DRM_MSM_GEM_SUBMIT, struct drm_msm_gem_submit)\n  205: #define DRM_IOCTL_MSM_WAIT_FENCE       DRM_IOW (DRM_COMMAND_BASE + DRM_MSM_WAIT_FENCE, struct drm_msm_wait_fence)\n  206  \n  207  #endif /* __MSM_DRM_H__ */\n\n/usr/include/drm/nouveau_drm.h:\n  130  #define DRM_NOUVEAU_GEM_INFO           0x44\n  131  \n  132: #define DRM_IOCTL_NOUVEAU_GEM_NEW            DRM_IOWR(DRM_COMMAND_BASE + DRM_NOUVEAU_GEM_NEW, struct drm_nouveau_gem_new)\n  133: #define DRM_IOCTL_NOUVEAU_GEM_PUSHBUF        DRM_IOWR(DRM_COMMAND_BASE + DRM_NOUVEAU_GEM_PUSHBUF, struct drm_nouveau_gem_pushbuf)\n  134: #define DRM_IOCTL_NOUVEAU_GEM_CPU_PREP       DRM_IOW (DRM_COMMAND_BASE + DRM_NOUVEAU_GEM_CPU_PREP, struct drm_nouveau_gem_cpu_prep)\n  135: #define DRM_IOCTL_NOUVEAU_GEM_CPU_FINI       DRM_IOW (DRM_COMMAND_BASE + DRM_NOUVEAU_GEM_CPU_FINI, struct drm_nouveau_gem_cpu_fini)\n  136: #define DRM_IOCTL_NOUVEAU_GEM_INFO           DRM_IOWR(DRM_COMMAND_BASE + DRM_NOUVEAU_GEM_INFO, struct drm_nouveau_gem_info)\n  137  \n  138  #endif /* __NOUVEAU_DRM_H__ */\n\n/usr/include/drm/qxl_drm.h:\n  124  };\n  125  \n  126: #define DRM_IOCTL_QXL_ALLOC \\\n  127  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_ALLOC, struct drm_qxl_alloc)\n  128  \n  129: #define DRM_IOCTL_QXL_MAP \\\n  130  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_MAP, struct drm_qxl_map)\n  131  \n  132: #define DRM_IOCTL_QXL_EXECBUFFER \\\n  133  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_EXECBUFFER,\\\n  134  		struct drm_qxl_execbuffer)\n  135  \n  136: #define DRM_IOCTL_QXL_UPDATE_AREA \\\n  137  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_UPDATE_AREA,\\\n  138  		struct drm_qxl_update_area)\n  139  \n  140: #define DRM_IOCTL_QXL_GETPARAM \\\n  141  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_GETPARAM,\\\n  142  		struct drm_qxl_getparam)\n  143  \n  144: #define DRM_IOCTL_QXL_CLIENTCAP \\\n  145  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_CLIENTCAP,\\\n  146  		struct drm_qxl_clientcap)\n  147  \n  148: #define DRM_IOCTL_QXL_ALLOC_SURF \\\n  149  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_ALLOC_SURF,\\\n  150  		struct drm_qxl_alloc_surf)\n\n/usr/include/drm/r128_drm.h:\n  173   */\n  174  \n  175: /* Rage 128 specific ioctls\n  176:  * The device specific ioctl range is 0x40 to 0x79.\n  177   */\n  178  #define DRM_R128_INIT       0x00\n  ...\n  197  #define DRM_R128_FLIP       0x13\n  198  \n  199: #define DRM_IOCTL_R128_INIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INIT, drm_r128_init_t)\n  200: #define DRM_IOCTL_R128_CCE_START  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_START)\n  201: #define DRM_IOCTL_R128_CCE_STOP   DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CCE_STOP, drm_r128_cce_stop_t)\n  202: #define DRM_IOCTL_R128_CCE_RESET  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_RESET)\n  203: #define DRM_IOCTL_R128_CCE_IDLE   DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_IDLE)\n  204  /* 0x05 not used */\n  205: #define DRM_IOCTL_R128_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_R128_RESET)\n  206: #define DRM_IOCTL_R128_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_SWAP)\n  207: #define DRM_IOCTL_R128_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR, drm_r128_clear_t)\n  208: #define DRM_IOCTL_R128_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_VERTEX, drm_r128_vertex_t)\n  209: #define DRM_IOCTL_R128_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INDICES, drm_r128_indices_t)\n  210: #define DRM_IOCTL_R128_BLIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_BLIT, drm_r128_blit_t)\n  211: #define DRM_IOCTL_R128_DEPTH      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_DEPTH, drm_r128_depth_t)\n  212: #define DRM_IOCTL_R128_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_STIPPLE, drm_r128_stipple_t)\n  213  /* 0x0e not used */\n  214: #define DRM_IOCTL_R128_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_R128_INDIRECT, drm_r128_indirect_t)\n  215: #define DRM_IOCTL_R128_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_R128_FULLSCREEN, drm_r128_fullscreen_t)\n  216: #define DRM_IOCTL_R128_CLEAR2     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR2, drm_r128_clear2_t)\n  217: #define DRM_IOCTL_R128_GETPARAM   DRM_IOWR( DRM_COMMAND_BASE + DRM_R128_GETPARAM, drm_r128_getparam_t)\n  218: #define DRM_IOCTL_R128_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_FLIP)\n  219  \n  220  typedef struct drm_r128_init {\n  ...\n  314  } drm_r128_fullscreen_t;\n  315  \n  316: /* 2.3: An ioctl to get parameters that aren't available to the 3d\n  317   * client any other way.\n  318   */\n\n/usr/include/drm/radeon_drm.h:\n   43  \n   44  /* Old style state flags, required for sarea interface (1.1 and 1.2\n   45:  * clears) and 1.2 drm_vertex2 ioctl.\n   46   */\n   47  #define RADEON_UPLOAD_CONTEXT		0x00000001\n   ..\n   66  #define RADEON_UPLOAD_CONTEXT_ALL       0x003e01ff\n   67  \n   68: /* New style per-packet identifiers for use in cmd_buffer ioctl with\n   69   * the RADEON_EMIT_PACKET command.  Comments relate new packets to old\n   70   * state bits and the packet size:\n   ..\n  167  #define RADEON_MAX_STATE_PACKETS                    95\n  168  \n  169: /* Commands understood by cmd_buffer ioctl.  More can be added but\n  170   * obviously these can't be removed or changed:\n  171   */\n  ...\n  215  #define R300_CMD_PACKET3_RAW		1\n  216  \n  217: /* Commands understood by cmd_buffer ioctl for R300.\n  218   * The interface has not been stabilized, so some of these may be removed\n  219   * and eventually reordered before stabilization.\n  ...\n  431  	/* The channel for communication of state information to the\n  432  	 * kernel on firing a vertex buffer with either of the\n  433: 	 * obsoleted vertex/index ioctls.\n  434  	 */\n  435  	drm_radeon_context_regs_t context_state;\n  ...\n  466   */\n  467  \n  468: /* Radeon specific ioctls\n  469:  * The device specific ioctl range is 0x40 to 0x79.\n  470   */\n  471  #define DRM_RADEON_CP_INIT    0x00\n  ...\n  497  #define DRM_RADEON_SURF_ALLOC 0x1a\n  498  #define DRM_RADEON_SURF_FREE  0x1b\n  499: /* KMS ioctl */\n  500  #define DRM_RADEON_GEM_INFO		0x1c\n  501  #define DRM_RADEON_GEM_CREATE		0x1d\n  ...\n  512  #define DRM_RADEON_GEM_VA		0x2b\n  513  \n  514: #define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)\n  515: #define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)\n  516: #define DRM_IOCTL_RADEON_CP_STOP    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_STOP, drm_radeon_cp_stop_t)\n  517: #define DRM_IOCTL_RADEON_CP_RESET   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESET)\n  518: #define DRM_IOCTL_RADEON_CP_IDLE    DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_IDLE)\n  519: #define DRM_IOCTL_RADEON_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_RESET)\n  520: #define DRM_IOCTL_RADEON_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FULLSCREEN, drm_radeon_fullscreen_t)\n  521: #define DRM_IOCTL_RADEON_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_SWAP)\n  522: #define DRM_IOCTL_RADEON_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CLEAR, drm_radeon_clear_t)\n  523: #define DRM_IOCTL_RADEON_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX, drm_radeon_vertex_t)\n  524: #define DRM_IOCTL_RADEON_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INDICES, drm_radeon_indices_t)\n  525: #define DRM_IOCTL_RADEON_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_STIPPLE, drm_radeon_stipple_t)\n  526: #define DRM_IOCTL_RADEON_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INDIRECT, drm_radeon_indirect_t)\n  527: #define DRM_IOCTL_RADEON_TEXTURE    DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_TEXTURE, drm_radeon_texture_t)\n  528: #define DRM_IOCTL_RADEON_VERTEX2    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX2, drm_radeon_vertex2_t)\n  529: #define DRM_IOCTL_RADEON_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CMDBUF, drm_radeon_cmd_buffer_t)\n  530: #define DRM_IOCTL_RADEON_GETPARAM   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GETPARAM, drm_radeon_getparam_t)\n  531: #define DRM_IOCTL_RADEON_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_FLIP)\n  532: #define DRM_IOCTL_RADEON_ALLOC      DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_ALLOC, drm_radeon_mem_alloc_t)\n  533: #define DRM_IOCTL_RADEON_FREE       DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FREE, drm_radeon_mem_free_t)\n  534: #define DRM_IOCTL_RADEON_INIT_HEAP  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INIT_HEAP, drm_radeon_mem_init_heap_t)\n  535: #define DRM_IOCTL_RADEON_IRQ_EMIT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_IRQ_EMIT, drm_radeon_irq_emit_t)\n  536: #define DRM_IOCTL_RADEON_IRQ_WAIT   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_IRQ_WAIT, drm_radeon_irq_wait_t)\n  537: #define DRM_IOCTL_RADEON_CP_RESUME  DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESUME)\n  538: #define DRM_IOCTL_RADEON_SETPARAM   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SETPARAM, drm_radeon_setparam_t)\n  539: #define DRM_IOCTL_RADEON_SURF_ALLOC DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_ALLOC, drm_radeon_surface_alloc_t)\n  540: #define DRM_IOCTL_RADEON_SURF_FREE  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_FREE, drm_radeon_surface_free_t)\n  541  /* KMS */\n  542: #define DRM_IOCTL_RADEON_GEM_INFO	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_INFO, struct drm_radeon_gem_info)\n  543: #define DRM_IOCTL_RADEON_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_CREATE, struct drm_radeon_gem_create)\n  544: #define DRM_IOCTL_RADEON_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_MMAP, struct drm_radeon_gem_mmap)\n  545: #define DRM_IOCTL_RADEON_GEM_PREAD	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PREAD, struct drm_radeon_gem_pread)\n  546: #define DRM_IOCTL_RADEON_GEM_PWRITE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PWRITE, struct drm_radeon_gem_pwrite)\n  547: #define DRM_IOCTL_RADEON_GEM_SET_DOMAIN	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_DOMAIN, struct drm_radeon_gem_set_domain)\n  548: #define DRM_IOCTL_RADEON_GEM_WAIT_IDLE	DRM_IOW(DRM_COMMAND_BASE + DRM_RADEON_GEM_WAIT_IDLE, struct drm_radeon_gem_wait_idle)\n  549: #define DRM_IOCTL_RADEON_CS		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_CS, struct drm_radeon_cs)\n  550: #define DRM_IOCTL_RADEON_INFO		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INFO, struct drm_radeon_info)\n  551: #define DRM_IOCTL_RADEON_GEM_SET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_TILING, struct drm_radeon_gem_set_tiling)\n  552: #define DRM_IOCTL_RADEON_GEM_GET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_GET_TILING, struct drm_radeon_gem_get_tiling)\n  553: #define DRM_IOCTL_RADEON_GEM_BUSY	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_BUSY, struct drm_radeon_gem_busy)\n  554: #define DRM_IOCTL_RADEON_GEM_VA		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_VA, struct drm_radeon_gem_va)\n  555  \n  556  typedef struct drm_radeon_init {\n  ...\n  631  \n  632  /* v1.2 - obsoletes drm_radeon_vertex and drm_radeon_indices\n  633:  *      - allows multiple primitives and state changes in a single ioctl\n  634   *      - supports driver change to emit native primitives\n  635   */\n  ...\n  649   *      - allows state to be emitted without a primitive\n  650   *           (for clears, ctx switches)\n  651:  *      - allows more than one dma buffer to be referenced per ioctl\n  652   *      - supports tcl driver\n  653   *      - may be extended in future versions with new cmd types, packets\n  ...\n  691  #define RADEON_CARD_PCIE 2\n  692  \n  693: /* 1.3: An ioctl to get parameters that aren't available to the 3d\n  694   * client any other way.\n  695   */\n  ...\n  753  \n  754  /* 1.10: Clients tell the DRM where they think the framebuffer is located in\n  755:  * the card's address space, via a new generic ioctl to set parameters\n  756   */\n  757  \n  ...\n  943  	/* this points to uint64_t * which point to cs chunks */\n  944  	uint64_t		chunks;\n  945: 	/* updates to the limits after this CS ioctl */\n  946  	uint64_t		gart_limit;\n  947  	uint64_t		vram_limit;\n\n/usr/include/drm/savage_drm.h:\n   57  } drm_savage_sarea_t, *drm_savage_sarea_ptr;\n   58  \n   59: /* Savage-specific ioctls\n   60   */\n   61  #define DRM_SAVAGE_BCI_INIT		0x00\n   ..\n   64  #define DRM_SAVAGE_BCI_EVENT_WAIT	0x03\n   65  \n   66: #define DRM_IOCTL_SAVAGE_BCI_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_INIT, drm_savage_init_t)\n   67: #define DRM_IOCTL_SAVAGE_BCI_CMDBUF		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_CMDBUF, drm_savage_cmdbuf_t)\n   68: #define DRM_IOCTL_SAVAGE_BCI_EVENT_EMIT	DRM_IOWR(DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_EMIT, drm_savage_event_emit_t)\n   69: #define DRM_IOCTL_SAVAGE_BCI_EVENT_WAIT	DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_WAIT, drm_savage_event_wait_t)\n   70  \n   71  #define SAVAGE_DMA_PCI	1\n   ..\n  126  } drm_savage_event_emit_t, drm_savage_event_wait_t;\n  127  \n  128: /* Commands for the cmdbuf ioctl\n  129   */\n  130  #define SAVAGE_CMD_STATE	0	/* a range of state registers */\n\n/usr/include/drm/sis_drm.h:\n   28  #define __SIS_DRM_H__\n   29  \n   30: /* SiS specific ioctls */\n   31  #define NOT_USED_0_3\n   32  #define DRM_SIS_FB_ALLOC	0x04\n   ..\n   38  #define DRM_SIS_FB_INIT	        0x16\n   39  \n   40: #define DRM_IOCTL_SIS_FB_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_FB_ALLOC, drm_sis_mem_t)\n   41: #define DRM_IOCTL_SIS_FB_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_FREE, drm_sis_mem_t)\n   42: #define DRM_IOCTL_SIS_AGP_INIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_INIT, drm_sis_agp_t)\n   43: #define DRM_IOCTL_SIS_AGP_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_ALLOC, drm_sis_mem_t)\n   44: #define DRM_IOCTL_SIS_AGP_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_AGP_FREE, drm_sis_mem_t)\n   45: #define DRM_IOCTL_SIS_FB_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_INIT, drm_sis_fb_t)\n   46  /*\n   47: #define DRM_IOCTL_SIS_FLIP		DRM_IOW( 0x48, drm_sis_flip_t)\n   48: #define DRM_IOCTL_SIS_FLIP_INIT		DRM_IO(  0x49)\n   49: #define DRM_IOCTL_SIS_FLIP_FINAL	DRM_IO(  0x50)\n   50  */\n   51  \n\n/usr/include/drm/tegra_drm.h:\n  136  #define DRM_TEGRA_GET_SYNCPT_BASE	0x09\n  137  \n  138: #define DRM_IOCTL_TEGRA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_CREATE, struct drm_tegra_gem_create)\n  139: #define DRM_IOCTL_TEGRA_GEM_MMAP DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_MMAP, struct drm_tegra_gem_mmap)\n  140: #define DRM_IOCTL_TEGRA_SYNCPT_READ DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_READ, struct drm_tegra_syncpt_read)\n  141: #define DRM_IOCTL_TEGRA_SYNCPT_INCR DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_INCR, struct drm_tegra_syncpt_incr)\n  142: #define DRM_IOCTL_TEGRA_SYNCPT_WAIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_WAIT, struct drm_tegra_syncpt_wait)\n  143: #define DRM_IOCTL_TEGRA_OPEN_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_OPEN_CHANNEL, struct drm_tegra_open_channel)\n  144: #define DRM_IOCTL_TEGRA_CLOSE_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_CLOSE_CHANNEL, struct drm_tegra_open_channel)\n  145: #define DRM_IOCTL_TEGRA_GET_SYNCPT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT, struct drm_tegra_get_syncpt)\n  146: #define DRM_IOCTL_TEGRA_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SUBMIT, struct drm_tegra_submit)\n  147: #define DRM_IOCTL_TEGRA_GET_SYNCPT_BASE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT_BASE, struct drm_tegra_get_syncpt_base)\n  148  \n  149  #endif\n\n/usr/include/drm/via_drm.h:\n   61  #define VIA_UPLOAD_ALL        0xff\n   62  \n   63: /* VIA specific ioctls */\n   64  #define DRM_VIA_ALLOCMEM	0x00\n   65  #define DRM_VIA_FREEMEM	        0x01\n   ..\n   79  #define DRM_VIA_BLIT_SYNC       0x0f\n   80  \n   81: #define DRM_IOCTL_VIA_ALLOCMEM	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_ALLOCMEM, drm_via_mem_t)\n   82: #define DRM_IOCTL_VIA_FREEMEM	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_FREEMEM, drm_via_mem_t)\n   83: #define DRM_IOCTL_VIA_AGP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_AGP_INIT, drm_via_agp_t)\n   84: #define DRM_IOCTL_VIA_FB_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_FB_INIT, drm_via_fb_t)\n   85: #define DRM_IOCTL_VIA_MAP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_MAP_INIT, drm_via_init_t)\n   86: #define DRM_IOCTL_VIA_DEC_FUTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_DEC_FUTEX, drm_via_futex_t)\n   87: #define DRM_IOCTL_VIA_DMA_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_DMA_INIT, drm_via_dma_init_t)\n   88: #define DRM_IOCTL_VIA_CMDBUFFER	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_CMDBUFFER, drm_via_cmdbuffer_t)\n   89: #define DRM_IOCTL_VIA_FLUSH	  DRM_IO(  DRM_COMMAND_BASE + DRM_VIA_FLUSH)\n   90: #define DRM_IOCTL_VIA_PCICMD	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_PCICMD, drm_via_cmdbuffer_t)\n   91: #define DRM_IOCTL_VIA_CMDBUF_SIZE DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_CMDBUF_SIZE, \\\n   92  					    drm_via_cmdbuf_size_t)\n   93: #define DRM_IOCTL_VIA_WAIT_IRQ    DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_WAIT_IRQ, drm_via_irqwait_t)\n   94: #define DRM_IOCTL_VIA_DMA_BLIT    DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_DMA_BLIT, drm_via_dmablit_t)\n   95: #define DRM_IOCTL_VIA_BLIT_SYNC   DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_BLIT_SYNC, drm_via_blitsync_t)\n   96  \n   97  /* Indices into buf.Setup where various bits of state are mirrored per\n   ..\n  102  #define VIA_TEX_SETUP_SIZE 8\n  103  \n  104: /* Flags for clear ioctl\n  105   */\n  106  #define VIA_FRONT   0x1\n\n/usr/include/drm/vmwgfx_drm.h:\n   72   * The fifo is mapped using the mmap() system call on the drm device.\n   73   *\n   74:  * DRM_VMW_PARAM_OVERLAY_IOCTL:\n   75:  * Does the driver support the overlay ioctl.\n   76   */\n   77  \n   ..\n   94   * @param: Parameter to query. //In.\n   95   *\n   96:  * Argument to the DRM_VMW_GET_PARAM Ioctl.\n   97   */\n   98  \n   ..\n  116   * @cid: Device unique context ID.\n  117   *\n  118:  * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.\n  119:  * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.\n  120   */\n  121  \n  ...\n  159   * scanout.\n  160   *\n  161:  * Input data to the DRM_VMW_CREATE_SURFACE Ioctl.\n  162:  * Output data from the DRM_VMW_REF_SURFACE Ioctl.\n  163   */\n  164  \n  ...\n  177   * @sid: Surface id of created surface or surface to destroy or reference.\n  178   *\n  179:  * Output data from the DRM_VMW_CREATE_SURFACE Ioctl.\n  180:  * Input argument to the DRM_VMW_UNREF_SURFACE Ioctl.\n  181:  * Input argument to the DRM_VMW_REF_SURFACE Ioctl.\n  182   */\n  183  \n  ...\n  188  \n  189  /**\n  190:  * struct drm_vmw_size ioctl.\n  191   *\n  192   * @width - mip level width\n  ...\n  195   *\n  196   * Description of a mip level.\n  197:  * Input data to the DRM_WMW_CREATE_SURFACE Ioctl.\n  198   */\n  199  \n  ...\n  211   * @req: Input data as described above.\n  212   *\n  213:  * Argument to the DRM_VMW_CREATE_SURFACE Ioctl.\n  214   */\n  215  \n  ...\n  224   *\n  225   * Puts a reference on a host surface with a give sid, as previously\n  226:  * returned by the DRM_VMW_CREATE_SURFACE ioctl.\n  227   * A reference will make sure the surface isn't destroyed while we hold\n  228   * it and will allow the calling client to use the surface ID in the command\n  229   * stream.\n  230   *\n  231:  * On successful return, the Ioctl returns the surface information given\n  232:  * in the DRM_VMW_CREATE_SURFACE ioctl.\n  233   */\n  234  \n  ...\n  239   * @req: Input data as described above.\n  240   *\n  241:  * Argument to the DRM_VMW_REF_SURFACE Ioctl.\n  242   */\n  243  \n  ...\n  277   * @fence_rep: User-space address of a struct drm_vmw_fence_rep cast to an\n  278   * uint64_t.\n  279:  * @version: Allows expanding the execbuf ioctl parameters without breaking\n  280   * backwards compatibility, since user-space will always tell the kernel\n  281   * which version it uses.\n  282   * @flags: Execbuf flags. None currently.\n  283   *\n  284:  * Argument to the DRM_VMW_EXECBUF Ioctl.\n  285   */\n  286  \n  ...\n  318   * Use the fence_seq member.\n  319   *\n  320:  * Input / Output data to the DRM_VMW_EXECBUF Ioctl.\n  321   */\n  322  \n  ...\n  353   * @size: Required minimum size of the buffer.\n  354   *\n  355:  * Input data to the DRM_VMW_ALLOC_DMABUF Ioctl.\n  356   */\n  357  \n  ...\n  371   * referenced. See note above.\n  372   *\n  373:  * Output data from the DRM_VMW_ALLOC_DMABUF Ioctl.\n  374   */\n  375  \n  ...\n  388   * @rep: Output data as described above.\n  389   *\n  390:  * Argument to the DRM_VMW_ALLOC_DMABUF Ioctl.\n  391   */\n  392  \n  ...\n  406   *\n  407   * @handle: Handle indicating what buffer to free. Obtained from the\n  408:  * DRM_VMW_ALLOC_DMABUF Ioctl.\n  409   *\n  410:  * Argument to the DRM_VMW_UNREF_DMABUF Ioctl.\n  411   */\n  412  \n  ...\n  420   * DRM_VMW_CONTROL_STREAM - Control overlays, aka streams.\n  421   *\n  422:  * This IOCTL controls the overlay units of the svga device.\n  423   * The SVGA overlay units does not work like regular hardware units in\n  424   * that they do not automaticaly read back the contents of the given dma\n  425:  * buffer. But instead only read back for each call to this ioctl, and\n  426   * at any point between this call being made and a following call that\n  427   * either changes the buffer or disables the stream.\n  ...\n  431   * struct drm_vmw_rect\n  432   *\n  433:  * Defines a rectangle. Used in the overlay ioctl to define\n  434   * source and destination rectangle.\n  435   */\n  ...\n  457   * @dst: Destination rect, x and y may be negative.\n  458   *\n  459:  * Argument to the DRM_VMW_CONTROL_STREAM Ioctl.\n  460   */\n  461  \n  ...\n  499   * @yhot: Y hotspot.\n  500   *\n  501:  * Argument to the DRM_VMW_CURSOR_BYPASS Ioctl.\n  502   */\n  503  \n  ...\n  521   * @stream_id: Device unique context ID.\n  522   *\n  523:  * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.\n  524:  * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.\n  525   */\n  526  \n  ...\n  552   * @size: Max size to copy\n  553   *\n  554:  * Input argument to the DRM_VMW_GET_3D_CAP_IOCTL\n  555:  * ioctls.\n  556   */\n  557  \n  ...\n  572   * the timeout is computed from the first call.\n  573   *\n  574:  * The flags argument to the DRM_VMW_FENCE_WAIT ioctl indicates what to wait\n  575   * on:\n  576   * DRM_VMW_FENCE_FLAG_EXEC: All commands ahead of the fence in the command\n  ...\n  579   * DRM_VMW_FENCE_FLAG_QUERY: All query results resulting from query finish\n  580   * commands\n  581:  * in the buffer given to the EXECBUF ioctl returning the fence object handle\n  582   * are available to user-space.\n  583   *\n  584   * DRM_VMW_WAIT_OPTION_UNREF: If this wait option is given, and the\n  585:  * fenc wait ioctl returns 0, the fence object has been unreferenced after\n  586   * the wait.\n  587   */\n  ...\n  595   * struct drm_vmw_fence_wait_arg\n  596   *\n  597:  * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.\n  598   * @cookie_valid: Must be reset to 0 on first call. Left alone on restart.\n  599   * @kernel_cookie: Set to 0 on first call. Left alone on restart.\n  ...\n  602   * before returning.\n  603   * @flags: Fence flags to wait on.\n  604:  * @wait_options: Options that control the behaviour of the wait ioctl.\n  605   *\n  606:  * Input argument to the DRM_VMW_FENCE_WAIT ioctl.\n  607   */\n  608  \n  ...\n  628   * struct drm_vmw_fence_signaled_arg\n  629   *\n  630:  * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.\n  631:  * @flags: Fence object flags input to DRM_VMW_FENCE_SIGNALED ioctl\n  632   * @signaled: Out: Flags signaled.\n  633   * @sequence: Out: Highest sequence passed so far. Can be used to signal the\n  ...\n  635   *\n  636   * Input/Output argument to the DRM_VMW_FENCE_SIGNALED and DRM_VMW_FENCE_UNREF\n  637:  * ioctls.\n  638   */\n  639  \n  ...\n  659   * struct drm_vmw_fence_arg\n  660   *\n  661:  * @handle: Fence object handle as returned by the DRM_VMW_EXECBUF ioctl.\n  662   *\n  663:  * Input/Output argument to the DRM_VMW_FENCE_UNREF ioctl..\n  664   */\n  665  \n  ...\n  736   * @pad64: Unused 64-bit padding.\n  737   *\n  738:  * Input argument to the DRM_VMW_PRESENT ioctl.\n  739   */\n  740  \n  ...\n  766   * @clips_ptr: Pointer to an array of clip rects cast to an uint64_t.\n  767   * @fence_rep: Pointer to a struct drm_vmw_fence_rep, cast to an uint64_t.\n  768:  * If this member is NULL, then the ioctl should not return a fence.\n  769   */\n  770  \n  ...\n  791   * @rects: pointer to array of drm_vmw_rect cast to an uint64_t\n  792   *\n  793:  * Input argument to the DRM_VMW_UPDATE_LAYOUT Ioctl.\n  794   */\n  795  struct drm_vmw_update_layout_arg {\n  ...\n  830   * @offset: Offset in bytes into the buffer given by @buffer_handle,\n  831   *\n  832:  * Input / Output argument to the DRM_VMW_CREATE_SHADER Ioctl.\n  833   */\n  834  struct drm_vmw_shader_create_arg {\n  ...\n  853   * @handle: Handle identifying the shader to destroy.\n  854   *\n  855:  * Input argument to the DRM_VMW_UNREF_SHADER ioctl.\n  856   */\n  857  struct drm_vmw_shader_arg {\n  ...\n  897   * @base_size         Size of the base mip level for all faces.\n  898   *\n  899:  * Input argument to the  DRM_VMW_GB_SURFACE_CREATE Ioctl.\n  900:  * Part of output argument for the DRM_VMW_GB_SURFACE_REF Ioctl.\n  901   */\n  902  struct drm_vmw_gb_surface_create_req {\n  ...\n  923   *                     identified by @buffer_handle.\n  924   *\n  925:  * Part of output argument for the DRM_VMW_GB_SURFACE_REF ioctl.\n  926:  * Output argument for the DRM_VMW_GB_SURFACE_CREATE ioctl.\n  927   */\n  928  struct drm_vmw_gb_surface_create_rep {\n  ...\n  940   * @rep: Output argument as described above.\n  941   *\n  942:  * Argument to the DRM_VMW_GB_SURFACE_CREATE ioctl.\n  943   */\n  944  union drm_vmw_gb_surface_create_arg {\n  ...\n  952   *\n  953   * Puts a reference on a host surface with a given handle, as previously\n  954:  * returned by the DRM_VMW_GB_SURFACE_CREATE ioctl.\n  955   * A reference will make sure the surface isn't destroyed while we hold\n  956   * it and will allow the calling client to use the surface handle in\n  957   * the command stream.\n  958   *\n  959:  * On successful return, the Ioctl returns the surface information given\n  960:  * to and returned from the DRM_VMW_GB_SURFACE_CREATE ioctl.\n  961   */\n  962  \n  ...\n  969   *        above at \"struct drm_vmw_gb_surface_create_rep\"\n  970   *\n  971:  * Output Argument to the DRM_VMW_GB_SURFACE_REF ioctl.\n  972   */\n  973  struct drm_vmw_gb_surface_ref_rep {\n  ...\n  982   * @rep: Output data as described above at \"struct drm_vmw_gb_surface_ref_rep\"\n  983   *\n  984:  * Argument to the DRM_VMW_GB_SURFACE_REF Ioctl.\n  985   */\n  986  union drm_vmw_gb_surface_reference_arg {\n\n/usr/include/libdrm/drm.h:\n   40  \n   41  #include <linux/types.h>\n   42: #include <asm/ioctl.h>\n   43  typedef unsigned int drm_handle_t;\n   44  \n   ..\n  122  \n  123  /**\n  124:  * DRM_IOCTL_VERSION ioctl argument type.\n  125   *\n  126   * \\sa drmGetVersion().\n  ...\n  139  \n  140  /**\n  141:  * DRM_IOCTL_GET_UNIQUE ioctl argument type.\n  142   *\n  143   * \\sa drmGetBusid() and drmSetBusId().\n  ...\n  158  \n  159  /**\n  160:  * DRM_IOCTL_CONTROL ioctl argument type.\n  161   *\n  162   * \\sa drmCtlInstHandler() and drmCtlUninstHandler().\n  ...\n  205  \n  206  /**\n  207:  * DRM_IOCTL_GET_MAP, DRM_IOCTL_ADD_MAP and DRM_IOCTL_RM_MAP ioctls\n  208   * argument type.\n  209   *\n  ...\n  222  \n  223  /**\n  224:  * DRM_IOCTL_GET_CLIENT ioctl argument type.\n  225   */\n  226  struct drm_client {\n  ...\n  230  	unsigned long uid;	/**< User ID */\n  231  	unsigned long magic;	/**< Magic */\n  232: 	unsigned long iocs;	/**< Ioctl count */\n  233  };\n  234  \n  ...\n  237  	_DRM_STAT_OPENS,\n  238  	_DRM_STAT_CLOSES,\n  239: 	_DRM_STAT_IOCTLS,\n  240  	_DRM_STAT_LOCKS,\n  241  	_DRM_STAT_UNLOCKS,\n  ...\n  254  \n  255  /**\n  256:  * DRM_IOCTL_GET_STATS ioctl argument type.\n  257   */\n  258  struct drm_stats {\n  ...\n  280  \n  281  /**\n  282:  * DRM_IOCTL_LOCK, DRM_IOCTL_UNLOCK and DRM_IOCTL_FINISH ioctl argument type.\n  283   *\n  284   * \\sa drmGetLock() and drmUnlock().\n  ...\n  319  \n  320  /**\n  321:  * DRM_IOCTL_ADD_BUFS and DRM_IOCTL_MARK_BUFS ioctl argument type.\n  322   *\n  323   * \\sa drmAddBufs().\n  ...\n  342  \n  343  /**\n  344:  * DRM_IOCTL_INFO_BUFS ioctl argument type.\n  345   */\n  346  struct drm_buf_info {\n  ...\n  350  \n  351  /**\n  352:  * DRM_IOCTL_FREE_BUFS ioctl argument type.\n  353   */\n  354  struct drm_buf_free {\n  ...\n  370  \n  371  /**\n  372:  * DRM_IOCTL_MAP_BUFS ioctl argument type.\n  373   */\n  374  struct drm_buf_map {\n  ...\n  383  \n  384  /**\n  385:  * DRM_IOCTL_DMA ioctl argument type.\n  386   *\n  387   * Indices here refer to the offset into the buffer list in drm_buf_get.\n  ...\n  408  \n  409  /**\n  410:  * DRM_IOCTL_ADD_CTX ioctl argument type.\n  411   *\n  412   * \\sa drmCreateContext() and drmDestroyContext().\n  ...\n  418  \n  419  /**\n  420:  * DRM_IOCTL_RES_CTX ioctl argument type.\n  421   */\n  422  struct drm_ctx_res {\n  ...\n  426  \n  427  /**\n  428:  * DRM_IOCTL_ADD_DRAW and DRM_IOCTL_RM_DRAW ioctl argument type.\n  429   */\n  430  struct drm_draw {\n  ...\n  433  \n  434  /**\n  435:  * DRM_IOCTL_UPDATE_DRAW ioctl argument type.\n  436   */\n  437  typedef enum {\n  ...\n  447  \n  448  /**\n  449:  * DRM_IOCTL_GET_MAGIC and DRM_IOCTL_AUTH_MAGIC ioctl argument type.\n  450   */\n  451  struct drm_auth {\n  ...\n  454  \n  455  /**\n  456:  * DRM_IOCTL_IRQ_BUSID ioctl argument type.\n  457   *\n  458   * \\sa drmGetInterruptFromBusID().\n  ...\n  493  \n  494  /**\n  495:  * DRM_IOCTL_WAIT_VBLANK ioctl argument type.\n  496   *\n  497   * \\sa drmWaitVBlank().\n  ...\n  506  \n  507  /**\n  508:  * DRM_IOCTL_MODESET_CTL ioctl argument type\n  509   *\n  510   * \\sa drmModesetCtl().\n  ...\n  516  \n  517  /**\n  518:  * DRM_IOCTL_AGP_ENABLE ioctl argument type.\n  519   *\n  520   * \\sa drmAgpEnable().\n  ...\n  525  \n  526  /**\n  527:  * DRM_IOCTL_AGP_ALLOC and DRM_IOCTL_AGP_FREE ioctls argument type.\n  528   *\n  529   * \\sa drmAgpAlloc() and drmAgpFree().\n  ...\n  537  \n  538  /**\n  539:  * DRM_IOCTL_AGP_BIND and DRM_IOCTL_AGP_UNBIND ioctls argument type.\n  540   *\n  541   * \\sa drmAgpBind() and drmAgpUnbind().\n  ...\n  547  \n  548  /**\n  549:  * DRM_IOCTL_AGP_INFO ioctl argument type.\n  550   *\n  551   * \\sa drmAgpVersionMajor(), drmAgpVersionMinor(), drmAgpGetMode(),\n  ...\n  568  \n  569  /**\n  570:  * DRM_IOCTL_SG_ALLOC ioctl argument type.\n  571   */\n  572  struct drm_scatter_gather {\n  ...\n  576  \n  577  /**\n  578:  * DRM_IOCTL_SET_VERSION ioctl argument type.\n  579   */\n  580  struct drm_set_version {\n  ...\n  585  };\n  586  \n  587: /** DRM_IOCTL_GEM_CLOSE ioctl argument type */\n  588  struct drm_gem_close {\n  589  	/** Handle of the object to be closed. */\n  ...\n  592  };\n  593  \n  594: /** DRM_IOCTL_GEM_FLINK ioctl argument type */\n  595  struct drm_gem_flink {\n  596  	/** Handle for the object being named */\n  ...\n  601  };\n  602  \n  603: /** DRM_IOCTL_GEM_OPEN ioctl argument type */\n  604  struct drm_gem_open {\n  605  	/** Name of object being opened */\n  ...\n  613  };\n  614  \n  615: /** DRM_IOCTL_GET_CAP ioctl argument type */\n  616  struct drm_get_cap {\n  617  	__u64 capability;\n  ...\n  636  #define DRM_CLIENT_CAP_UNIVERSAL_PLANES 2\n  637  \n  638: /** DRM_IOCTL_SET_CLIENT_CAP ioctl argument type */\n  639  struct drm_set_client_cap {\n  640  	__u64 capability;\n  ...\n  655  #include \"drm_mode.h\"\n  656  \n  657: #define DRM_IOCTL_BASE			'd'\n  658: #define DRM_IO(nr)			_IO(DRM_IOCTL_BASE,nr)\n  659: #define DRM_IOR(nr,type)		_IOR(DRM_IOCTL_BASE,nr,type)\n  660: #define DRM_IOW(nr,type)		_IOW(DRM_IOCTL_BASE,nr,type)\n  661: #define DRM_IOWR(nr,type)		_IOWR(DRM_IOCTL_BASE,nr,type)\n  662  \n  663: #define DRM_IOCTL_VERSION		DRM_IOWR(0x00, struct drm_version)\n  664: #define DRM_IOCTL_GET_UNIQUE		DRM_IOWR(0x01, struct drm_unique)\n  665: #define DRM_IOCTL_GET_MAGIC		DRM_IOR( 0x02, struct drm_auth)\n  666: #define DRM_IOCTL_IRQ_BUSID		DRM_IOWR(0x03, struct drm_irq_busid)\n  667: #define DRM_IOCTL_GET_MAP               DRM_IOWR(0x04, struct drm_map)\n  668: #define DRM_IOCTL_GET_CLIENT            DRM_IOWR(0x05, struct drm_client)\n  669: #define DRM_IOCTL_GET_STATS             DRM_IOR( 0x06, struct drm_stats)\n  670: #define DRM_IOCTL_SET_VERSION		DRM_IOWR(0x07, struct drm_set_version)\n  671: #define DRM_IOCTL_MODESET_CTL           DRM_IOW(0x08, struct drm_modeset_ctl)\n  672: #define DRM_IOCTL_GEM_CLOSE		DRM_IOW (0x09, struct drm_gem_close)\n  673: #define DRM_IOCTL_GEM_FLINK		DRM_IOWR(0x0a, struct drm_gem_flink)\n  674: #define DRM_IOCTL_GEM_OPEN		DRM_IOWR(0x0b, struct drm_gem_open)\n  675: #define DRM_IOCTL_GET_CAP		DRM_IOWR(0x0c, struct drm_get_cap)\n  676: #define DRM_IOCTL_SET_CLIENT_CAP	DRM_IOW( 0x0d, struct drm_set_client_cap)\n  677  \n  678: #define DRM_IOCTL_SET_UNIQUE		DRM_IOW( 0x10, struct drm_unique)\n  679: #define DRM_IOCTL_AUTH_MAGIC		DRM_IOW( 0x11, struct drm_auth)\n  680: #define DRM_IOCTL_BLOCK			DRM_IOWR(0x12, struct drm_block)\n  681: #define DRM_IOCTL_UNBLOCK		DRM_IOWR(0x13, struct drm_block)\n  682: #define DRM_IOCTL_CONTROL		DRM_IOW( 0x14, struct drm_control)\n  683: #define DRM_IOCTL_ADD_MAP		DRM_IOWR(0x15, struct drm_map)\n  684: #define DRM_IOCTL_ADD_BUFS		DRM_IOWR(0x16, struct drm_buf_desc)\n  685: #define DRM_IOCTL_MARK_BUFS		DRM_IOW( 0x17, struct drm_buf_desc)\n  686: #define DRM_IOCTL_INFO_BUFS		DRM_IOWR(0x18, struct drm_buf_info)\n  687: #define DRM_IOCTL_MAP_BUFS		DRM_IOWR(0x19, struct drm_buf_map)\n  688: #define DRM_IOCTL_FREE_BUFS		DRM_IOW( 0x1a, struct drm_buf_free)\n  689  \n  690: #define DRM_IOCTL_RM_MAP		DRM_IOW( 0x1b, struct drm_map)\n  691  \n  692: #define DRM_IOCTL_SET_SAREA_CTX		DRM_IOW( 0x1c, struct drm_ctx_priv_map)\n  693: #define DRM_IOCTL_GET_SAREA_CTX 	DRM_IOWR(0x1d, struct drm_ctx_priv_map)\n  694  \n  695: #define DRM_IOCTL_SET_MASTER            DRM_IO(0x1e)\n  696: #define DRM_IOCTL_DROP_MASTER           DRM_IO(0x1f)\n  697  \n  698: #define DRM_IOCTL_ADD_CTX		DRM_IOWR(0x20, struct drm_ctx)\n  699: #define DRM_IOCTL_RM_CTX		DRM_IOWR(0x21, struct drm_ctx)\n  700: #define DRM_IOCTL_MOD_CTX		DRM_IOW( 0x22, struct drm_ctx)\n  701: #define DRM_IOCTL_GET_CTX		DRM_IOWR(0x23, struct drm_ctx)\n  702: #define DRM_IOCTL_SWITCH_CTX		DRM_IOW( 0x24, struct drm_ctx)\n  703: #define DRM_IOCTL_NEW_CTX		DRM_IOW( 0x25, struct drm_ctx)\n  704: #define DRM_IOCTL_RES_CTX		DRM_IOWR(0x26, struct drm_ctx_res)\n  705: #define DRM_IOCTL_ADD_DRAW		DRM_IOWR(0x27, struct drm_draw)\n  706: #define DRM_IOCTL_RM_DRAW		DRM_IOWR(0x28, struct drm_draw)\n  707: #define DRM_IOCTL_DMA			DRM_IOWR(0x29, struct drm_dma)\n  708: #define DRM_IOCTL_LOCK			DRM_IOW( 0x2a, struct drm_lock)\n  709: #define DRM_IOCTL_UNLOCK		DRM_IOW( 0x2b, struct drm_lock)\n  710: #define DRM_IOCTL_FINISH		DRM_IOW( 0x2c, struct drm_lock)\n  711  \n  712: #define DRM_IOCTL_PRIME_HANDLE_TO_FD    DRM_IOWR(0x2d, struct drm_prime_handle)\n  713: #define DRM_IOCTL_PRIME_FD_TO_HANDLE    DRM_IOWR(0x2e, struct drm_prime_handle)\n  714  \n  715: #define DRM_IOCTL_AGP_ACQUIRE		DRM_IO(  0x30)\n  716: #define DRM_IOCTL_AGP_RELEASE		DRM_IO(  0x31)\n  717: #define DRM_IOCTL_AGP_ENABLE		DRM_IOW( 0x32, struct drm_agp_mode)\n  718: #define DRM_IOCTL_AGP_INFO		DRM_IOR( 0x33, struct drm_agp_info)\n  719: #define DRM_IOCTL_AGP_ALLOC		DRM_IOWR(0x34, struct drm_agp_buffer)\n  720: #define DRM_IOCTL_AGP_FREE		DRM_IOW( 0x35, struct drm_agp_buffer)\n  721: #define DRM_IOCTL_AGP_BIND		DRM_IOW( 0x36, struct drm_agp_binding)\n  722: #define DRM_IOCTL_AGP_UNBIND		DRM_IOW( 0x37, struct drm_agp_binding)\n  723  \n  724: #define DRM_IOCTL_SG_ALLOC		DRM_IOWR(0x38, struct drm_scatter_gather)\n  725: #define DRM_IOCTL_SG_FREE		DRM_IOW( 0x39, struct drm_scatter_gather)\n  726  \n  727: #define DRM_IOCTL_WAIT_VBLANK		DRM_IOWR(0x3a, union drm_wait_vblank)\n  728  \n  729: #define DRM_IOCTL_UPDATE_DRAW		DRM_IOW(0x3f, struct drm_update_draw)\n  730  \n  731: #define DRM_IOCTL_MODE_GETRESOURCES	DRM_IOWR(0xA0, struct drm_mode_card_res)\n  732: #define DRM_IOCTL_MODE_GETCRTC		DRM_IOWR(0xA1, struct drm_mode_crtc)\n  733: #define DRM_IOCTL_MODE_SETCRTC		DRM_IOWR(0xA2, struct drm_mode_crtc)\n  734: #define DRM_IOCTL_MODE_CURSOR		DRM_IOWR(0xA3, struct drm_mode_cursor)\n  735: #define DRM_IOCTL_MODE_GETGAMMA		DRM_IOWR(0xA4, struct drm_mode_crtc_lut)\n  736: #define DRM_IOCTL_MODE_SETGAMMA		DRM_IOWR(0xA5, struct drm_mode_crtc_lut)\n  737: #define DRM_IOCTL_MODE_GETENCODER	DRM_IOWR(0xA6, struct drm_mode_get_encoder)\n  738: #define DRM_IOCTL_MODE_GETCONNECTOR	DRM_IOWR(0xA7, struct drm_mode_get_connector)\n  739: #define DRM_IOCTL_MODE_ATTACHMODE	DRM_IOWR(0xA8, struct drm_mode_mode_cmd)\n  740: #define DRM_IOCTL_MODE_DETACHMODE	DRM_IOWR(0xA9, struct drm_mode_mode_cmd)\n  741  \n  742: #define DRM_IOCTL_MODE_GETPROPERTY	DRM_IOWR(0xAA, struct drm_mode_get_property)\n  743: #define DRM_IOCTL_MODE_SETPROPERTY	DRM_IOWR(0xAB, struct drm_mode_connector_set_property)\n  744: #define DRM_IOCTL_MODE_GETPROPBLOB	DRM_IOWR(0xAC, struct drm_mode_get_blob)\n  745: #define DRM_IOCTL_MODE_GETFB		DRM_IOWR(0xAD, struct drm_mode_fb_cmd)\n  746: #define DRM_IOCTL_MODE_ADDFB		DRM_IOWR(0xAE, struct drm_mode_fb_cmd)\n  747: #define DRM_IOCTL_MODE_RMFB		DRM_IOWR(0xAF, unsigned int)\n  748: #define DRM_IOCTL_MODE_PAGE_FLIP	DRM_IOWR(0xB0, struct drm_mode_crtc_page_flip)\n  749: #define DRM_IOCTL_MODE_DIRTYFB		DRM_IOWR(0xB1, struct drm_mode_fb_dirty_cmd)\n  750  \n  751: #define DRM_IOCTL_MODE_CREATE_DUMB DRM_IOWR(0xB2, struct drm_mode_create_dumb)\n  752: #define DRM_IOCTL_MODE_MAP_DUMB    DRM_IOWR(0xB3, struct drm_mode_map_dumb)\n  753: #define DRM_IOCTL_MODE_DESTROY_DUMB    DRM_IOWR(0xB4, struct drm_mode_destroy_dumb)\n  754: #define DRM_IOCTL_MODE_GETPLANERESOURCES DRM_IOWR(0xB5, struct drm_mode_get_plane_res)\n  755: #define DRM_IOCTL_MODE_GETPLANE	DRM_IOWR(0xB6, struct drm_mode_get_plane)\n  756: #define DRM_IOCTL_MODE_SETPLANE	DRM_IOWR(0xB7, struct drm_mode_set_plane)\n  757: #define DRM_IOCTL_MODE_ADDFB2		DRM_IOWR(0xB8, struct drm_mode_fb_cmd2)\n  758: #define DRM_IOCTL_MODE_OBJ_GETPROPERTIES	DRM_IOWR(0xB9, struct drm_mode_obj_get_properties)\n  759: #define DRM_IOCTL_MODE_OBJ_SETPROPERTY	DRM_IOWR(0xBA, struct drm_mode_obj_set_property)\n  760: #define DRM_IOCTL_MODE_CURSOR2		DRM_IOWR(0xBB, struct drm_mode_cursor2)\n  761  \n  762  /**\n  763:  * Device specific ioctls should only be in their respective headers\n  764:  * The device specific ioctl range is from 0x40 to 0x99.\n  765:  * Generic IOCTLS restart at 0xA0.\n  766   *\n  767   * \\sa drmCommandNone(), drmCommandRead(), drmCommandWrite(), and\n  ...\n  775   * type defines the type of event, the length specifies the total\n  776   * length of the event (including the header), and user_data is\n  777:  * typically a 64 bit value passed with the ioctl that triggered the\n  778   * event.  A read on the drm fd will always only return complete\n  779   * events, that is, if for example the read buffer is 100 bytes, and\n\n/usr/include/libdrm/drm_mode.h:\n  332  \n  333  	/*\n  334: 	 * In case of planar formats, this ioctl allows up to 4\n  335  	 * buffer objects with offsets and pitches per plane.\n  336  	 * The pitch and offset order is dictated by the fourcc,\n  ...\n  358   *\n  359   * Some hardware does not automatically update display contents\n  360:  * as a hardware or software draw to a framebuffer. This ioctl\n  361   * allows userspace to tell the kernel and the hardware what\n  362   * regions of the framebuffer have changed.\n  ...\n  452   * Request a page flip on the specified crtc.\n  453   *\n  454:  * This ioctl will ask KMS to schedule a page flip for the specified\n  455   * crtc.  Once any pending rendering targeting the specified fb (as of\n  456:  * ioctl time) has completed, the crtc will be reprogrammed to display\n  457:  * that fb after the next vertical refresh.  The ioctl returns\n  458   * immediately, but subsequent rendering to the current fb will block\n  459:  * in the execbuffer ioctl until the page flip happens.  If a page\n  460:  * flip is already pending as the ioctl is called, EBUSY will be\n  461   * returned.\n  462   *\n  463:  * The ioctl supports one flag, DRM_MODE_PAGE_FLIP_EVENT, which will\n  464   * request that drm sends back a vblank event (see drm.h: struct\n  465   * drm_event_vblank) when the page flip is done.  The user_data field\n  466:  * passed in with this ioctl will be returned as the user_data field\n  467   * in the vblank event struct.\n  468   *\n\n/usr/include/libdrm/i915_drm.h:\n  172  #define I915_BOX_LOST_CONTEXT  0x10\n  173  \n  174: /* I915 specific ioctls\n  175:  * The device specific ioctl range is 0x40 to 0x79.\n  176   */\n  177  #define DRM_I915_INIT		0x00\n  ...\n  226  #define DRM_I915_GEM_USERPTR		0x33\n  227  \n  228: #define DRM_IOCTL_I915_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT, drm_i915_init_t)\n  229: #define DRM_IOCTL_I915_FLUSH		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLUSH)\n  230: #define DRM_IOCTL_I915_FLIP		DRM_IO ( DRM_COMMAND_BASE + DRM_I915_FLIP)\n  231: #define DRM_IOCTL_I915_BATCHBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_BATCHBUFFER, drm_i915_batchbuffer_t)\n  232: #define DRM_IOCTL_I915_IRQ_EMIT         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_IRQ_EMIT, drm_i915_irq_emit_t)\n  233: #define DRM_IOCTL_I915_IRQ_WAIT         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_IRQ_WAIT, drm_i915_irq_wait_t)\n  234: #define DRM_IOCTL_I915_GETPARAM         DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GETPARAM, drm_i915_getparam_t)\n  235: #define DRM_IOCTL_I915_SETPARAM         DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SETPARAM, drm_i915_setparam_t)\n  236: #define DRM_IOCTL_I915_ALLOC            DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_ALLOC, drm_i915_mem_alloc_t)\n  237: #define DRM_IOCTL_I915_FREE             DRM_IOW( DRM_COMMAND_BASE + DRM_I915_FREE, drm_i915_mem_free_t)\n  238: #define DRM_IOCTL_I915_INIT_HEAP        DRM_IOW( DRM_COMMAND_BASE + DRM_I915_INIT_HEAP, drm_i915_mem_init_heap_t)\n  239: #define DRM_IOCTL_I915_CMDBUFFER	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_CMDBUFFER, drm_i915_cmdbuffer_t)\n  240: #define DRM_IOCTL_I915_DESTROY_HEAP	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_DESTROY_HEAP, drm_i915_mem_destroy_heap_t)\n  241: #define DRM_IOCTL_I915_SET_VBLANK_PIPE	DRM_IOW( DRM_COMMAND_BASE + DRM_I915_SET_VBLANK_PIPE, drm_i915_vblank_pipe_t)\n  242: #define DRM_IOCTL_I915_GET_VBLANK_PIPE	DRM_IOR( DRM_COMMAND_BASE + DRM_I915_GET_VBLANK_PIPE, drm_i915_vblank_pipe_t)\n  243: #define DRM_IOCTL_I915_VBLANK_SWAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_VBLANK_SWAP, drm_i915_vblank_swap_t)\n  244: #define DRM_IOCTL_I915_HWS_ADDR		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_HWS_ADDR, struct drm_i915_gem_init)\n  245: #define DRM_IOCTL_I915_GEM_INIT		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_INIT, struct drm_i915_gem_init)\n  246: #define DRM_IOCTL_I915_GEM_EXECBUFFER	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER, struct drm_i915_gem_execbuffer)\n  247: #define DRM_IOCTL_I915_GEM_EXECBUFFER2	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_EXECBUFFER2, struct drm_i915_gem_execbuffer2)\n  248: #define DRM_IOCTL_I915_GEM_PIN		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_PIN, struct drm_i915_gem_pin)\n  249: #define DRM_IOCTL_I915_GEM_UNPIN	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_UNPIN, struct drm_i915_gem_unpin)\n  250: #define DRM_IOCTL_I915_GEM_BUSY		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_BUSY, struct drm_i915_gem_busy)\n  251: #define DRM_IOCTL_I915_GEM_SET_CACHING		DRM_IOW(DRM_COMMAND_BASE + DRM_I915_GEM_SET_CACHING, struct drm_i915_gem_caching)\n  252: #define DRM_IOCTL_I915_GEM_GET_CACHING		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_GET_CACHING, struct drm_i915_gem_caching)\n  253: #define DRM_IOCTL_I915_GEM_THROTTLE	DRM_IO ( DRM_COMMAND_BASE + DRM_I915_GEM_THROTTLE)\n  254: #define DRM_IOCTL_I915_GEM_ENTERVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_ENTERVT)\n  255: #define DRM_IOCTL_I915_GEM_LEAVEVT	DRM_IO(DRM_COMMAND_BASE + DRM_I915_GEM_LEAVEVT)\n  256: #define DRM_IOCTL_I915_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_CREATE, struct drm_i915_gem_create)\n  257: #define DRM_IOCTL_I915_GEM_PREAD	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PREAD, struct drm_i915_gem_pread)\n  258: #define DRM_IOCTL_I915_GEM_PWRITE	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_PWRITE, struct drm_i915_gem_pwrite)\n  259: #define DRM_IOCTL_I915_GEM_MMAP		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP, struct drm_i915_gem_mmap)\n  260: #define DRM_IOCTL_I915_GEM_MMAP_GTT	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MMAP_GTT, struct drm_i915_gem_mmap_gtt)\n  261: #define DRM_IOCTL_I915_GEM_SET_DOMAIN	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SET_DOMAIN, struct drm_i915_gem_set_domain)\n  262: #define DRM_IOCTL_I915_GEM_SW_FINISH	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_SW_FINISH, struct drm_i915_gem_sw_finish)\n  263: #define DRM_IOCTL_I915_GEM_SET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_SET_TILING, struct drm_i915_gem_set_tiling)\n  264: #define DRM_IOCTL_I915_GEM_GET_TILING	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_GET_TILING, struct drm_i915_gem_get_tiling)\n  265: #define DRM_IOCTL_I915_GEM_GET_APERTURE	DRM_IOR  (DRM_COMMAND_BASE + DRM_I915_GEM_GET_APERTURE, struct drm_i915_gem_get_aperture)\n  266: #define DRM_IOCTL_I915_GET_PIPE_FROM_CRTC_ID DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GET_PIPE_FROM_CRTC_ID, struct drm_i915_get_pipe_from_crtc_id)\n  267: #define DRM_IOCTL_I915_GEM_MADVISE	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_MADVISE, struct drm_i915_gem_madvise)\n  268: #define DRM_IOCTL_I915_OVERLAY_PUT_IMAGE	DRM_IOW(DRM_COMMAND_BASE + DRM_I915_OVERLAY_PUT_IMAGE, struct drm_intel_overlay_put_image)\n  269: #define DRM_IOCTL_I915_OVERLAY_ATTRS	DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_OVERLAY_ATTRS, struct drm_intel_overlay_attrs)\n  270: #define DRM_IOCTL_I915_SET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)\n  271: #define DRM_IOCTL_I915_GET_SPRITE_COLORKEY DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_SET_SPRITE_COLORKEY, struct drm_intel_sprite_colorkey)\n  272: #define DRM_IOCTL_I915_GEM_WAIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_WAIT, struct drm_i915_gem_wait)\n  273: #define DRM_IOCTL_I915_GEM_CONTEXT_CREATE	DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_CREATE, struct drm_i915_gem_context_create)\n  274: #define DRM_IOCTL_I915_GEM_CONTEXT_DESTROY	DRM_IOW (DRM_COMMAND_BASE + DRM_I915_GEM_CONTEXT_DESTROY, struct drm_i915_gem_context_destroy)\n  275: #define DRM_IOCTL_I915_REG_READ			DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_REG_READ, struct drm_i915_reg_read)\n  276: #define DRM_IOCTL_I915_GET_RESET_STATS		DRM_IOWR (DRM_COMMAND_BASE + DRM_I915_GET_RESET_STATS, struct drm_i915_reset_stats)\n  277: #define DRM_IOCTL_I915_GEM_USERPTR		DRM_IOWR(DRM_COMMAND_BASE + DRM_I915_GEM_USERPTR,  struct drm_i915_gem_userptr)\n  278  \n  279  /* Allow drivers to submit batchbuffers directly to hardware, relying\n  ...\n  311  } drm_i915_irq_wait_t;\n  312  \n  313: /* Ioctl to query kernel params:\n  314   */\n  315  #define I915_PARAM_IRQ_ACTIVE            1\n  ...\n  349  } drm_i915_getparam_t;\n  350  \n  351: /* Ioctl to set kernel params:\n  352   */\n  353  #define I915_SETPARAM_USE_MI_BATCHBUFFER_START            1\n  ...\n  546  	 * If the buffer has the same offset as last time, we can skip syncing\n  547  	 * and writing the relocation.  This value is written back out by\n  548: 	 * the execbuffer ioctl when the relocation is written.\n  549  	 */\n  550  	__u64 presumed_offset;\n\n/usr/include/libdrm/mach64_drm.h:\n  150   */\n  151  \n  152: /* Mach64 specific ioctls\n  153:  * The device specific ioctl range is 0x40 to 0x79.\n  154   */\n  155  \n  ...\n  164  #define DRM_MACH64_GETPARAM       0x08\n  165  \n  166: #define DRM_IOCTL_MACH64_INIT           DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_INIT, drm_mach64_init_t)\n  167: #define DRM_IOCTL_MACH64_IDLE           DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_IDLE )\n  168: #define DRM_IOCTL_MACH64_RESET          DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_RESET )\n  169: #define DRM_IOCTL_MACH64_SWAP           DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_SWAP )\n  170: #define DRM_IOCTL_MACH64_CLEAR          DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_CLEAR, drm_mach64_clear_t)\n  171: #define DRM_IOCTL_MACH64_VERTEX         DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_VERTEX, drm_mach64_vertex_t)\n  172: #define DRM_IOCTL_MACH64_BLIT           DRM_IOW( DRM_COMMAND_BASE + DRM_MACH64_BLIT, drm_mach64_blit_t)\n  173: #define DRM_IOCTL_MACH64_FLUSH          DRM_IO(  DRM_COMMAND_BASE + DRM_MACH64_FLUSH )\n  174: #define DRM_IOCTL_MACH64_GETPARAM       DRM_IOWR( DRM_COMMAND_BASE + DRM_MACH64_GETPARAM, drm_mach64_getparam_t)\n  175  \n  176  /* Buffer flags for clears\n\n/usr/include/libdrm/mga_drm.h:\n  227  } drm_mga_sarea_t;\n  228  \n  229: /* MGA specific ioctls\n  230:  * The device specific ioctl range is 0x40 to 0x79.\n  231   */\n  232  #define DRM_MGA_INIT     0x00\n  ...\n  242  \n  243  /* 3.2:\n  244:  * ioctls for operating on fences.\n  245   */\n  246  #define DRM_MGA_SET_FENCE      0x0a\n  ...\n  248  #define DRM_MGA_DMA_BOOTSTRAP  0x0c\n  249  \n  250: #define DRM_IOCTL_MGA_INIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INIT, drm_mga_init_t)\n  251: #define DRM_IOCTL_MGA_FLUSH    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_FLUSH, drm_lock_t)\n  252: #define DRM_IOCTL_MGA_RESET    DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_RESET)\n  253: #define DRM_IOCTL_MGA_SWAP     DRM_IO(  DRM_COMMAND_BASE + DRM_MGA_SWAP)\n  254: #define DRM_IOCTL_MGA_CLEAR    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_CLEAR, drm_mga_clear_t)\n  255: #define DRM_IOCTL_MGA_VERTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_VERTEX, drm_mga_vertex_t)\n  256: #define DRM_IOCTL_MGA_INDICES  DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_INDICES, drm_mga_indices_t)\n  257: #define DRM_IOCTL_MGA_ILOAD    DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_ILOAD, drm_mga_iload_t)\n  258: #define DRM_IOCTL_MGA_BLIT     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_BLIT, drm_mga_blit_t)\n  259: #define DRM_IOCTL_MGA_GETPARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_GETPARAM, drm_mga_getparam_t)\n  260: #define DRM_IOCTL_MGA_SET_FENCE     DRM_IOW( DRM_COMMAND_BASE + DRM_MGA_SET_FENCE, __u32)\n  261: #define DRM_IOCTL_MGA_WAIT_FENCE    DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_WAIT_FENCE, __u32)\n  262: #define DRM_IOCTL_MGA_DMA_BOOTSTRAP DRM_IOWR(DRM_COMMAND_BASE + DRM_MGA_DMA_BOOTSTRAP, drm_mga_dma_bootstrap_t)\n  263  \n  264  typedef struct _drm_mga_warp_index {\n  ...\n  303  	 * \\name AGP texture region\n  304  	 *\n  305: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, these fields will\n  306  	 * be filled in with the actual AGP texture settings.\n  307  	 *\n  ...\n  319  	 * Requested size of the primary DMA region.\n  320  	 *\n  321: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  322  	 * filled in with the actual AGP mode.  If AGP was not available\n  323  	 */\n  ...\n  327  	 * Requested number of secondary DMA buffers.\n  328  	 *\n  329: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  330  	 * filled in with the actual number of secondary DMA buffers\n  331  	 * allocated.  Particularly when PCI DMA is used, this may be\n  ...\n  349  	 * possible.\n  350  	 *\n  351: 	 * On return from the DRM_MGA_DMA_BOOTSTRAP ioctl, this field will be\n  352  	 * filled in with the actual AGP mode.  If AGP was not available\n  353  	 * (i.e., PCI DMA was used), this value will be zero.\n  ...\n  399  } drm_mga_blit_t;\n  400  \n  401: /* 3.1: An ioctl to get parameters that aren't available to the 3d\n  402   * client any other way.\n  403   */\n\n/usr/include/libdrm/qxl_drm.h:\n  124  };\n  125  \n  126: #define DRM_IOCTL_QXL_ALLOC \\\n  127  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_ALLOC, struct drm_qxl_alloc)\n  128  \n  129: #define DRM_IOCTL_QXL_MAP \\\n  130  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_MAP, struct drm_qxl_map)\n  131  \n  132: #define DRM_IOCTL_QXL_EXECBUFFER \\\n  133  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_EXECBUFFER,\\\n  134  		struct drm_qxl_execbuffer)\n  135  \n  136: #define DRM_IOCTL_QXL_UPDATE_AREA \\\n  137  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_UPDATE_AREA,\\\n  138  		struct drm_qxl_update_area)\n  139  \n  140: #define DRM_IOCTL_QXL_GETPARAM \\\n  141  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_GETPARAM,\\\n  142  		struct drm_qxl_getparam)\n  143  \n  144: #define DRM_IOCTL_QXL_CLIENTCAP \\\n  145  	DRM_IOW(DRM_COMMAND_BASE + DRM_QXL_CLIENTCAP,\\\n  146  		struct drm_qxl_clientcap)\n  147  \n  148: #define DRM_IOCTL_QXL_ALLOC_SURF \\\n  149  	DRM_IOWR(DRM_COMMAND_BASE + DRM_QXL_ALLOC_SURF,\\\n  150  		struct drm_qxl_alloc_surf)\n\n/usr/include/libdrm/r128_drm.h:\n  173   */\n  174  \n  175: /* Rage 128 specific ioctls\n  176:  * The device specific ioctl range is 0x40 to 0x79.\n  177   */\n  178  #define DRM_R128_INIT       0x00\n  ...\n  197  #define DRM_R128_FLIP       0x13\n  198  \n  199: #define DRM_IOCTL_R128_INIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INIT, drm_r128_init_t)\n  200: #define DRM_IOCTL_R128_CCE_START  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_START)\n  201: #define DRM_IOCTL_R128_CCE_STOP   DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CCE_STOP, drm_r128_cce_stop_t)\n  202: #define DRM_IOCTL_R128_CCE_RESET  DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_RESET)\n  203: #define DRM_IOCTL_R128_CCE_IDLE   DRM_IO(  DRM_COMMAND_BASE + DRM_R128_CCE_IDLE)\n  204  /* 0x05 not used */\n  205: #define DRM_IOCTL_R128_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_R128_RESET)\n  206: #define DRM_IOCTL_R128_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_SWAP)\n  207: #define DRM_IOCTL_R128_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR, drm_r128_clear_t)\n  208: #define DRM_IOCTL_R128_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_VERTEX, drm_r128_vertex_t)\n  209: #define DRM_IOCTL_R128_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_INDICES, drm_r128_indices_t)\n  210: #define DRM_IOCTL_R128_BLIT       DRM_IOW( DRM_COMMAND_BASE + DRM_R128_BLIT, drm_r128_blit_t)\n  211: #define DRM_IOCTL_R128_DEPTH      DRM_IOW( DRM_COMMAND_BASE + DRM_R128_DEPTH, drm_r128_depth_t)\n  212: #define DRM_IOCTL_R128_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_R128_STIPPLE, drm_r128_stipple_t)\n  213  /* 0x0e not used */\n  214: #define DRM_IOCTL_R128_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_R128_INDIRECT, drm_r128_indirect_t)\n  215: #define DRM_IOCTL_R128_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_R128_FULLSCREEN, drm_r128_fullscreen_t)\n  216: #define DRM_IOCTL_R128_CLEAR2     DRM_IOW( DRM_COMMAND_BASE + DRM_R128_CLEAR2, drm_r128_clear2_t)\n  217: #define DRM_IOCTL_R128_GETPARAM   DRM_IOWR( DRM_COMMAND_BASE + DRM_R128_GETPARAM, drm_r128_getparam_t)\n  218: #define DRM_IOCTL_R128_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_R128_FLIP)\n  219  \n  220  typedef struct drm_r128_init {\n  ...\n  314  } drm_r128_fullscreen_t;\n  315  \n  316: /* 2.3: An ioctl to get parameters that aren't available to the 3d\n  317   * client any other way.\n  318   */\n\n/usr/include/libdrm/radeon_drm.h:\n   43  \n   44  /* Old style state flags, required for sarea interface (1.1 and 1.2\n   45:  * clears) and 1.2 drm_vertex2 ioctl.\n   46   */\n   47  #define RADEON_UPLOAD_CONTEXT		0x00000001\n   ..\n   66  #define RADEON_UPLOAD_CONTEXT_ALL       0x003e01ff\n   67  \n   68: /* New style per-packet identifiers for use in cmd_buffer ioctl with\n   69   * the RADEON_EMIT_PACKET command.  Comments relate new packets to old\n   70   * state bits and the packet size:\n   ..\n  167  #define RADEON_MAX_STATE_PACKETS                    95\n  168  \n  169: /* Commands understood by cmd_buffer ioctl.  More can be added but\n  170   * obviously these can't be removed or changed:\n  171   */\n  ...\n  215  #define R300_CMD_PACKET3_RAW		1\n  216  \n  217: /* Commands understood by cmd_buffer ioctl for R300.\n  218   * The interface has not been stabilized, so some of these may be removed\n  219   * and eventually reordered before stabilization.\n  ...\n  431  	/* The channel for communication of state information to the\n  432  	 * kernel on firing a vertex buffer with either of the\n  433: 	 * obsoleted vertex/index ioctls.\n  434  	 */\n  435  	drm_radeon_context_regs_t context_state;\n  ...\n  466   */\n  467  \n  468: /* Radeon specific ioctls\n  469:  * The device specific ioctl range is 0x40 to 0x79.\n  470   */\n  471  #define DRM_RADEON_CP_INIT    0x00\n  ...\n  497  #define DRM_RADEON_SURF_ALLOC 0x1a\n  498  #define DRM_RADEON_SURF_FREE  0x1b\n  499: /* KMS ioctl */\n  500  #define DRM_RADEON_GEM_INFO		0x1c\n  501  #define DRM_RADEON_GEM_CREATE		0x1d\n  ...\n  513  #define DRM_RADEON_GEM_OP		0x2c\n  514  \n  515: #define DRM_IOCTL_RADEON_CP_INIT    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_INIT, drm_radeon_init_t)\n  516: #define DRM_IOCTL_RADEON_CP_START   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_START)\n  517: #define DRM_IOCTL_RADEON_CP_STOP    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CP_STOP, drm_radeon_cp_stop_t)\n  518: #define DRM_IOCTL_RADEON_CP_RESET   DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESET)\n  519: #define DRM_IOCTL_RADEON_CP_IDLE    DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_IDLE)\n  520: #define DRM_IOCTL_RADEON_RESET      DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_RESET)\n  521: #define DRM_IOCTL_RADEON_FULLSCREEN DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FULLSCREEN, drm_radeon_fullscreen_t)\n  522: #define DRM_IOCTL_RADEON_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_SWAP)\n  523: #define DRM_IOCTL_RADEON_CLEAR      DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CLEAR, drm_radeon_clear_t)\n  524: #define DRM_IOCTL_RADEON_VERTEX     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX, drm_radeon_vertex_t)\n  525: #define DRM_IOCTL_RADEON_INDICES    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INDICES, drm_radeon_indices_t)\n  526: #define DRM_IOCTL_RADEON_STIPPLE    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_STIPPLE, drm_radeon_stipple_t)\n  527: #define DRM_IOCTL_RADEON_INDIRECT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INDIRECT, drm_radeon_indirect_t)\n  528: #define DRM_IOCTL_RADEON_TEXTURE    DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_TEXTURE, drm_radeon_texture_t)\n  529: #define DRM_IOCTL_RADEON_VERTEX2    DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_VERTEX2, drm_radeon_vertex2_t)\n  530: #define DRM_IOCTL_RADEON_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_CMDBUF, drm_radeon_cmd_buffer_t)\n  531: #define DRM_IOCTL_RADEON_GETPARAM   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GETPARAM, drm_radeon_getparam_t)\n  532: #define DRM_IOCTL_RADEON_FLIP       DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_FLIP)\n  533: #define DRM_IOCTL_RADEON_ALLOC      DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_ALLOC, drm_radeon_mem_alloc_t)\n  534: #define DRM_IOCTL_RADEON_FREE       DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_FREE, drm_radeon_mem_free_t)\n  535: #define DRM_IOCTL_RADEON_INIT_HEAP  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_INIT_HEAP, drm_radeon_mem_init_heap_t)\n  536: #define DRM_IOCTL_RADEON_IRQ_EMIT   DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_IRQ_EMIT, drm_radeon_irq_emit_t)\n  537: #define DRM_IOCTL_RADEON_IRQ_WAIT   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_IRQ_WAIT, drm_radeon_irq_wait_t)\n  538: #define DRM_IOCTL_RADEON_CP_RESUME  DRM_IO(  DRM_COMMAND_BASE + DRM_RADEON_CP_RESUME)\n  539: #define DRM_IOCTL_RADEON_SETPARAM   DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SETPARAM, drm_radeon_setparam_t)\n  540: #define DRM_IOCTL_RADEON_SURF_ALLOC DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_ALLOC, drm_radeon_surface_alloc_t)\n  541: #define DRM_IOCTL_RADEON_SURF_FREE  DRM_IOW( DRM_COMMAND_BASE + DRM_RADEON_SURF_FREE, drm_radeon_surface_free_t)\n  542  /* KMS */\n  543: #define DRM_IOCTL_RADEON_GEM_INFO	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_INFO, struct drm_radeon_gem_info)\n  544: #define DRM_IOCTL_RADEON_GEM_CREATE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_CREATE, struct drm_radeon_gem_create)\n  545: #define DRM_IOCTL_RADEON_GEM_MMAP	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_MMAP, struct drm_radeon_gem_mmap)\n  546: #define DRM_IOCTL_RADEON_GEM_PREAD	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PREAD, struct drm_radeon_gem_pread)\n  547: #define DRM_IOCTL_RADEON_GEM_PWRITE	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_PWRITE, struct drm_radeon_gem_pwrite)\n  548: #define DRM_IOCTL_RADEON_GEM_SET_DOMAIN	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_DOMAIN, struct drm_radeon_gem_set_domain)\n  549: #define DRM_IOCTL_RADEON_GEM_WAIT_IDLE	DRM_IOW(DRM_COMMAND_BASE + DRM_RADEON_GEM_WAIT_IDLE, struct drm_radeon_gem_wait_idle)\n  550: #define DRM_IOCTL_RADEON_CS		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_CS, struct drm_radeon_cs)\n  551: #define DRM_IOCTL_RADEON_INFO		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_INFO, struct drm_radeon_info)\n  552: #define DRM_IOCTL_RADEON_GEM_SET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_SET_TILING, struct drm_radeon_gem_set_tiling)\n  553: #define DRM_IOCTL_RADEON_GEM_GET_TILING	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_GET_TILING, struct drm_radeon_gem_get_tiling)\n  554: #define DRM_IOCTL_RADEON_GEM_BUSY	DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_BUSY, struct drm_radeon_gem_busy)\n  555: #define DRM_IOCTL_RADEON_GEM_VA		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_VA, struct drm_radeon_gem_va)\n  556: #define DRM_IOCTL_RADEON_GEM_OP		DRM_IOWR(DRM_COMMAND_BASE + DRM_RADEON_GEM_OP, struct drm_radeon_gem_op)\n  557  \n  558  typedef struct drm_radeon_init {\n  ...\n  633  \n  634  /* v1.2 - obsoletes drm_radeon_vertex and drm_radeon_indices\n  635:  *      - allows multiple primitives and state changes in a single ioctl\n  636   *      - supports driver change to emit native primitives\n  637   */\n  ...\n  651   *      - allows state to be emitted without a primitive\n  652   *           (for clears, ctx switches)\n  653:  *      - allows more than one dma buffer to be referenced per ioctl\n  654   *      - supports tcl driver\n  655   *      - may be extended in future versions with new cmd types, packets\n  ...\n  693  #define RADEON_CARD_PCIE 2\n  694  \n  695: /* 1.3: An ioctl to get parameters that aren't available to the 3d\n  696   * client any other way.\n  697   */\n  ...\n  755  \n  756  /* 1.10: Clients tell the DRM where they think the framebuffer is located in\n  757:  * the card's address space, via a new generic ioctl to set parameters\n  758   */\n  759  \n  ...\n  957  	/* this points to uint64_t * which point to cs chunks */\n  958  	uint64_t		chunks;\n  959: 	/* updates to the limits after this CS ioctl */\n  960  	uint64_t		gart_limit;\n  961  	uint64_t		vram_limit;\n\n/usr/include/libdrm/savage_drm.h:\n   57  } drm_savage_sarea_t, *drm_savage_sarea_ptr;\n   58  \n   59: /* Savage-specific ioctls\n   60   */\n   61  #define DRM_SAVAGE_BCI_INIT		0x00\n   ..\n   64  #define DRM_SAVAGE_BCI_EVENT_WAIT	0x03\n   65  \n   66: #define DRM_IOCTL_SAVAGE_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_INIT, drm_savage_init_t)\n   67: #define DRM_IOCTL_SAVAGE_CMDBUF		DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_CMDBUF, drm_savage_cmdbuf_t)\n   68: #define DRM_IOCTL_SAVAGE_EVENT_EMIT	DRM_IOWR(DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_EMIT, drm_savage_event_emit_t)\n   69: #define DRM_IOCTL_SAVAGE_EVENT_WAIT	DRM_IOW( DRM_COMMAND_BASE + DRM_SAVAGE_BCI_EVENT_WAIT, drm_savage_event_wait_t)\n   70  \n   71  #define SAVAGE_DMA_PCI	1\n   ..\n  126  } drm_savage_event_emit_t, drm_savage_event_wait_t;\n  127  \n  128: /* Commands for the cmdbuf ioctl\n  129   */\n  130  #define SAVAGE_CMD_STATE	0	/* a range of state registers */\n\n/usr/include/libdrm/sis_drm.h:\n   28  #define __SIS_DRM_H__\n   29  \n   30: /* SiS specific ioctls */\n   31  #define NOT_USED_0_3\n   32  #define DRM_SIS_FB_ALLOC	0x04\n   ..\n   38  #define DRM_SIS_FB_INIT	        0x16\n   39  \n   40: #define DRM_IOCTL_SIS_FB_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_FB_ALLOC, drm_sis_mem_t)\n   41: #define DRM_IOCTL_SIS_FB_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_FREE, drm_sis_mem_t)\n   42: #define DRM_IOCTL_SIS_AGP_INIT		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_INIT, drm_sis_agp_t)\n   43: #define DRM_IOCTL_SIS_AGP_ALLOC		DRM_IOWR(DRM_COMMAND_BASE + DRM_SIS_AGP_ALLOC, drm_sis_mem_t)\n   44: #define DRM_IOCTL_SIS_AGP_FREE		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_AGP_FREE, drm_sis_mem_t)\n   45: #define DRM_IOCTL_SIS_FB_INIT		DRM_IOW( DRM_COMMAND_BASE + DRM_SIS_FB_INIT, drm_sis_fb_t)\n   46  /*\n   47: #define DRM_IOCTL_SIS_FLIP		DRM_IOW( 0x48, drm_sis_flip_t)\n   48: #define DRM_IOCTL_SIS_FLIP_INIT		DRM_IO(  0x49)\n   49: #define DRM_IOCTL_SIS_FLIP_FINAL	DRM_IO(  0x50)\n   50  */\n   51  \n\n/usr/include/libdrm/tegra_drm.h:\n  183  #define DRM_TEGRA_GEM_GET_FLAGS		0x0d\n  184  \n  185: #define DRM_IOCTL_TEGRA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_CREATE, struct drm_tegra_gem_create)\n  186: #define DRM_IOCTL_TEGRA_GEM_MMAP DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_MMAP, struct drm_tegra_gem_mmap)\n  187: #define DRM_IOCTL_TEGRA_SYNCPT_READ DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_READ, struct drm_tegra_syncpt_read)\n  188: #define DRM_IOCTL_TEGRA_SYNCPT_INCR DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_INCR, struct drm_tegra_syncpt_incr)\n  189: #define DRM_IOCTL_TEGRA_SYNCPT_WAIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SYNCPT_WAIT, struct drm_tegra_syncpt_wait)\n  190: #define DRM_IOCTL_TEGRA_OPEN_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_OPEN_CHANNEL, struct drm_tegra_open_channel)\n  191: #define DRM_IOCTL_TEGRA_CLOSE_CHANNEL DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_CLOSE_CHANNEL, struct drm_tegra_open_channel)\n  192: #define DRM_IOCTL_TEGRA_GET_SYNCPT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT, struct drm_tegra_get_syncpt)\n  193: #define DRM_IOCTL_TEGRA_SUBMIT DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_SUBMIT, struct drm_tegra_submit)\n  194: #define DRM_IOCTL_TEGRA_GET_SYNCPT_BASE DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GET_SYNCPT_BASE, struct drm_tegra_get_syncpt_base)\n  195: #define DRM_IOCTL_TEGRA_GEM_SET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_TILING, struct drm_tegra_gem_set_tiling)\n  196: #define DRM_IOCTL_TEGRA_GEM_GET_TILING DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_TILING, struct drm_tegra_gem_get_tiling)\n  197: #define DRM_IOCTL_TEGRA_GEM_SET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_SET_FLAGS, struct drm_tegra_gem_set_flags)\n  198: #define DRM_IOCTL_TEGRA_GEM_GET_FLAGS DRM_IOWR(DRM_COMMAND_BASE + DRM_TEGRA_GEM_GET_FLAGS, struct drm_tegra_gem_get_flags)\n  199  \n  200  #endif\n\n/usr/include/libdrm/via_drm.h:\n   61  #define VIA_UPLOAD_ALL        0xff\n   62  \n   63: /* VIA specific ioctls */\n   64  #define DRM_VIA_ALLOCMEM	0x00\n   65  #define DRM_VIA_FREEMEM	        0x01\n   ..\n   79  #define DRM_VIA_BLIT_SYNC       0x0f\n   80  \n   81: #define DRM_IOCTL_VIA_ALLOCMEM	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_ALLOCMEM, drm_via_mem_t)\n   82: #define DRM_IOCTL_VIA_FREEMEM	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_FREEMEM, drm_via_mem_t)\n   83: #define DRM_IOCTL_VIA_AGP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_AGP_INIT, drm_via_agp_t)\n   84: #define DRM_IOCTL_VIA_FB_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_FB_INIT, drm_via_fb_t)\n   85: #define DRM_IOCTL_VIA_MAP_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_MAP_INIT, drm_via_init_t)\n   86: #define DRM_IOCTL_VIA_DEC_FUTEX   DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_DEC_FUTEX, drm_via_futex_t)\n   87: #define DRM_IOCTL_VIA_DMA_INIT	  DRM_IOWR(DRM_COMMAND_BASE + DRM_VIA_DMA_INIT, drm_via_dma_init_t)\n   88: #define DRM_IOCTL_VIA_CMDBUFFER	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_CMDBUFFER, drm_via_cmdbuffer_t)\n   89: #define DRM_IOCTL_VIA_FLUSH	  DRM_IO(  DRM_COMMAND_BASE + DRM_VIA_FLUSH)\n   90: #define DRM_IOCTL_VIA_PCICMD	  DRM_IOW( DRM_COMMAND_BASE + DRM_VIA_PCICMD, drm_via_cmdbuffer_t)\n   91: #define DRM_IOCTL_VIA_CMDBUF_SIZE DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_CMDBUF_SIZE, \\\n   92  					    drm_via_cmdbuf_size_t)\n   93: #define DRM_IOCTL_VIA_WAIT_IRQ    DRM_IOWR( DRM_COMMAND_BASE + DRM_VIA_WAIT_IRQ, drm_via_irqwait_t)\n   94: #define DRM_IOCTL_VIA_DMA_BLIT    DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_DMA_BLIT, drm_via_dmablit_t)\n   95: #define DRM_IOCTL_VIA_BLIT_SYNC   DRM_IOW(DRM_COMMAND_BASE + DRM_VIA_BLIT_SYNC, drm_via_blitsync_t)\n   96  \n   97  /* Indices into buf.Setup where various bits of state are mirrored per\n   ..\n  102  #define VIA_TEX_SETUP_SIZE 8\n  103  \n  104: /* Flags for clear ioctl\n  105   */\n  106  #define VIA_FRONT   0x1\n\n/usr/include/libdrm/vmwgfx_drm.h:\n   63   * The fifo is mapped using the mmap() system call on the drm device.\n   64   *\n   65:  * DRM_VMW_PARAM_OVERLAY_IOCTL:\n   66:  * Does the driver support the overlay ioctl.\n   67   */\n   68  \n   ..\n   80   * @param: Parameter to query. //In.\n   81   *\n   82:  * Argument to the DRM_VMW_GET_PARAM Ioctl.\n   83   */\n   84  \n   ..\n   98   *\n   99   * @exists: The queried extension exists.\n  100:  * @driver_ioctl_offset: Ioctl number of the first ioctl in the extension.\n  101   * @driver_sarea_offset: Offset to any space in the DRI SAREA\n  102   * used by the extension.\n  ...\n  105   * @pl: Patch level version number of the extension.\n  106   *\n  107:  * Output argument to the DRM_VMW_EXTENSION Ioctl.\n  108   */\n  109  \n  110  struct drm_vmw_extension_rep {\n  111  	int32_t exists;\n  112: 	uint32_t driver_ioctl_offset;\n  113  	uint32_t driver_sarea_offset;\n  114  	uint32_t major;\n  ...\n  124   * @rep - Reply as defined above. //Out\n  125   *\n  126:  * Argument to the DRM_VMW_EXTENSION Ioctl.\n  127   */\n  128  \n  ...\n  145   * @cid: Device unique context ID.\n  146   *\n  147:  * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.\n  148:  * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.\n  149   */\n  150  \n  ...\n  188   * scanout.\n  189   *\n  190:  * Input data to the DRM_VMW_CREATE_SURFACE Ioctl.\n  191:  * Output data from the DRM_VMW_REF_SURFACE Ioctl.\n  192   */\n  193  \n  ...\n  206   * @sid: Surface id of created surface or surface to destroy or reference.\n  207   *\n  208:  * Output data from the DRM_VMW_CREATE_SURFACE Ioctl.\n  209:  * Input argument to the DRM_VMW_UNREF_SURFACE Ioctl.\n  210:  * Input argument to the DRM_VMW_REF_SURFACE Ioctl.\n  211   */\n  212  \n  ...\n  217  \n  218  /**\n  219:  * struct drm_vmw_size ioctl.\n  220   *\n  221   * @width - mip level width\n  ...\n  224   *\n  225   * Description of a mip level.\n  226:  * Input data to the DRM_WMW_CREATE_SURFACE Ioctl.\n  227   */\n  228  \n  ...\n  240   * @req: Input data as described above.\n  241   *\n  242:  * Argument to the DRM_VMW_CREATE_SURFACE Ioctl.\n  243   */\n  244  \n  ...\n  253   *\n  254   * Puts a reference on a host surface with a give sid, as previously\n  255:  * returned by the DRM_VMW_CREATE_SURFACE ioctl.\n  256   * A reference will make sure the surface isn't destroyed while we hold\n  257   * it and will allow the calling client to use the surface ID in the command\n  258   * stream.\n  259   *\n  260:  * On successful return, the Ioctl returns the surface information given\n  261:  * in the DRM_VMW_CREATE_SURFACE ioctl.\n  262   */\n  263  \n  ...\n  268   * @req: Input data as described above.\n  269   *\n  270:  * Argument to the DRM_VMW_REF_SURFACE Ioctl.\n  271   */\n  272  \n  ...\n  306   * @fence_rep: User-space address of a struct drm_vmw_fence_rep cast to an\n  307   * uint64_t.\n  308:  * @version: Allows expanding the execbuf ioctl parameters without breaking\n  309   * backwards compatibility, since user-space will always tell the kernel\n  310   * which version it uses.\n  311   * @flags: Execbuf flags. None currently.\n  312   *\n  313:  * Argument to the DRM_VMW_EXECBUF Ioctl.\n  314   */\n  315  \n  ...\n  338   * Use the fence_seq member.\n  339   *\n  340:  * Input / Output data to the DRM_VMW_EXECBUF Ioctl.\n  341   */\n  342  \n  ...\n  370   * @size: Required minimum size of the buffer.\n  371   *\n  372:  * Input data to the DRM_VMW_ALLOC_DMABUF Ioctl.\n  373   */\n  374  \n  ...\n  388   * referenced. See note above.\n  389   *\n  390:  * Output data from the DRM_VMW_ALLOC_DMABUF Ioctl.\n  391   */\n  392  \n  ...\n  405   * @rep: Output data as described above.\n  406   *\n  407:  * Argument to the DRM_VMW_ALLOC_DMABUF Ioctl.\n  408   */\n  409  \n  ...\n  423   *\n  424   * @handle: Handle indicating what buffer to free. Obtained from the\n  425:  * DRM_VMW_ALLOC_DMABUF Ioctl.\n  426   *\n  427:  * Argument to the DRM_VMW_UNREF_DMABUF Ioctl.\n  428   */\n  429  \n  ...\n  437   * DRM_VMW_FIFO_DEBUG - Get last FIFO submission.\n  438   *\n  439:  * This IOCTL copies the last FIFO submission directly out of the FIFO buffer.\n  440   */\n  441  \n  ...\n  448   * @did_not_fit: Boolean indicating that the fifo contents did not fit. //Out\n  449   *\n  450:  * Argument to the DRM_VMW_FIFO_DEBUG Ioctl.\n  451   */\n  452  \n  ...\n  470   * DRM_VMW_CONTROL_STREAM - Control overlays, aka streams.\n  471   *\n  472:  * This IOCTL controls the overlay units of the svga device.\n  473   * The SVGA overlay units does not work like regular hardware units in\n  474   * that they do not automaticaly read back the contents of the given dma\n  475:  * buffer. But instead only read back for each call to this ioctl, and\n  476   * at any point between this call being made and a following call that\n  477   * either changes the buffer or disables the stream.\n  ...\n  481   * struct drm_vmw_rect\n  482   *\n  483:  * Defines a rectangle. Used in the overlay ioctl to define\n  484   * source and destination rectangle.\n  485   */\n  ...\n  507   * @dst: Destination rect, x and y may be negative.\n  508   *\n  509:  * Argument to the DRM_VMW_CONTROL_STREAM Ioctl.\n  510   */\n  511  \n  ...\n  549   * @yhot: Y hotspot.\n  550   *\n  551:  * Argument to the DRM_VMW_CURSOR_BYPASS Ioctl.\n  552   */\n  553  \n  ...\n  571   * @stream_id: Device unique context ID.\n  572   *\n  573:  * Output argument to the DRM_VMW_CREATE_CONTEXT Ioctl.\n  574:  * Input argument to the DRM_VMW_UNREF_CONTEXT Ioctl.\n  575   */\n  576  \n  ...\n  603   * @rects: pointer to array of drm_vmw_rect\n  604   *\n  605:  * Input argument to the DRM_VMW_UPDATE_LAYOUT Ioctl.\n  606   */\n  607  \n\n/usr/include/linux/apm_bios.h:\n  126  \n  127  /*\n  128:  * ioctl operations\n  129   */\n  130: #include <linux/ioctl.h>\n  131  \n  132  #define APM_IOC_STANDBY		_IO('A', 1)\n\n/usr/include/linux/atm_he.h:\n   13  #define HE_REGTYPE_MBOX	4\n   14  \n   15: struct he_ioctl_reg {\n   16  	unsigned addr, val;\n   17  	char type;\n\n/usr/include/linux/atm_idt77105.h:\n   13  \n   14  /*\n   15:  * Structure for IDT77105_GETSTAT and IDT77105_GETSTATZ ioctls.\n   16   * Pointed to by `arg' in atmif_sioc.\n   17   */\n\n/usr/include/linux/atmbr2684.h:\n   93  \n   94  /*\n   95:  * The BR2684_SETFILT ioctl is an experimental mechanism for folks\n   96   * terminating a large number of IP-only vcc's.  When netfilter allows\n   97   * efficient per-if in/out filters, this support will be removed\n\n/usr/include/linux/atmdev.h:\n  111   * These are backend handkers that can be set via the ATM_SETBACKEND call\n  112   * above.  In the future we may support dynamic loading of these - for now,\n  113:  * they're just being used to share the ATMIOC_BACKEND ioctls\n  114   */\n  115  #define ATM_BACKEND_RAW		0	\n\n/usr/include/linux/atmioc.h:\n    1: /* atmioc.h - ranges for ATM-related ioctl numbers */\n    2   \n    3  /* Written 1995-1999 by Werner Almesberger, EPFL LRC/ICA */\n    .\n    6  /*\n    7   * See http://icawww1.epfl.ch/linux-atm/magic.html for the complete list of\n    8:  * \"magic\" ioctl numbers.\n    9   */\n   10  \n   ..\n   13  #define _LINUX_ATMIOC_H\n   14  \n   15: #include <asm/ioctl.h>\n   16  		/* everybody including atmioc.h will also need _IO{,R,W,WR} */\n   17  \n   18: #define ATMIOC_PHYCOM	  0x00 /* PHY device common ioctls, globally unique */\n   19  #define ATMIOC_PHYCOM_END 0x0f\n   20: #define ATMIOC_PHYTYP	  0x10 /* PHY dev type ioctls, unique per PHY type */\n   21  #define ATMIOC_PHYTYP_END 0x2f\n   22: #define ATMIOC_PHYPRV	  0x30 /* PHY dev private ioctls, unique per driver */\n   23  #define ATMIOC_PHYPRV_END 0x4f\n   24: #define ATMIOC_SARCOM	  0x50 /* SAR device common ioctls, globally unique */\n   25  #define ATMIOC_SARCOM_END 0x50\n   26: #define ATMIOC_SARPRV	  0x60 /* SAR dev private ioctls, unique per driver */\n   27  #define ATMIOC_SARPRV_END 0x7f\n   28: #define ATMIOC_ITF	  0x80 /* Interface ioctls, globally unique */\n   29  #define ATMIOC_ITF_END	  0x8f\n   30: #define ATMIOC_BACKEND	  0x90 /* ATM generic backend ioctls, u. per backend */\n   31  #define ATMIOC_BACKEND_END 0xaf\n   32  /* 0xb0-0xbf: Reserved for future use */\n\n/usr/include/linux/aufs_type.h:\n  104  /* ---------------------------------------------------------------------- */\n  105  \n  106: /* ioctl */\n  107  enum {\n  108  	/* readdir in userspace */\n\n/usr/include/linux/auto_fs.h:\n   16  \n   17  #include <linux/types.h>\n   18: #include <sys/ioctl.h>\n   19  \n   20  \n   ..\n   28  /*\n   29   * The wait_queue_token (autofs_wqt_t) is part of a structure which is passed\n   30:  * back to the kernel via ioctl from userspace. On architectures where 32- and\n   31   * 64-bit userspace binaries can be executed it's important that the size of\n   32   * autofs_wqt_t stays constant between 32- and 64-bit Linux kernels so that we\n   ..\n   55  };	\n   56  \n   57: /* v3 expire (via ioctl) */\n   58  struct autofs_packet_expire {\n   59  	struct autofs_packet_hdr hdr;\n\n/usr/include/linux/auto_fs4.h:\n   77   * This isn't really a type as we use it to say \"no type set\" to\n   78   * indicate we want to search for \"any\" mount in the\n   79:  * autofs_dev_ioctl_ismountpoint() device ioctl function.\n   80   */\n   81  static __inline__ void set_autofs_type_any(unsigned int *type)\n\n/usr/include/linux/baycom.h:\n   10  /* -------------------------------------------------------------------- */\n   11  /*\n   12:  * structs for the IOCTL commands\n   13   */\n   14  \n   ..\n   19  };\n   20  \n   21: struct baycom_ioctl {\n   22  	int cmd;\n   23  	union {\n   ..\n   29  \n   30  /*\n   31:  * ioctl values change for baycom\n   32   */\n   33  #define BAYCOMCTL_GETDEBUG       0x92\n\n/usr/include/linux/blkpg.h:\n    5   * Partition table and disk geometry handling\n    6   *\n    7:  * A single ioctl with lots of subfunctions:\n    8   *\n    9   * Device number stuff:\n   ..\n   26   */\n   27  \n   28: #include <linux/ioctl.h>\n   29  \n   30  #define BLKPG      _IO(0x12,105)\n   31  \n   32  /* The argument structure */\n   33: struct blkpg_ioctl_arg {\n   34          int op;\n   35          int flags;\n\n/usr/include/linux/btrfs.h:\n   20  #define _LINUX_BTRFS_H\n   21  #include <linux/types.h>\n   22: #include <linux/ioctl.h>\n   23  \n   24: #define BTRFS_IOCTL_MAGIC 0x94\n   25  #define BTRFS_VOL_NAME_MAX 255\n   26  \n   27  /* this should be 4k */\n   28  #define BTRFS_PATH_NAME_MAX 4087\n   29: struct btrfs_ioctl_vol_args {\n   30  	__s64 fd;\n   31  	char name[BTRFS_PATH_NAME_MAX + 1];\n   ..\n   59  };\n   60  \n   61: struct btrfs_ioctl_qgroup_limit_args {\n   62  	__u64	qgroupid;\n   63  	struct btrfs_qgroup_limit lim;\n   ..\n   65  \n   66  #define BTRFS_SUBVOL_NAME_MAX 4039\n   67: struct btrfs_ioctl_vol_args_v2 {\n   68  	__s64 fd;\n   69  	__u64 transid;\n   ..\n  117  \n  118  #define BTRFS_SCRUB_READONLY	1\n  119: struct btrfs_ioctl_scrub_args {\n  120  	__u64 devid;				/* in */\n  121  	__u64 start;				/* in */\n  ...\n  127  };\n  128  \n  129: #define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_ALWAYS	0\n  130: #define BTRFS_IOCTL_DEV_REPLACE_CONT_READING_FROM_SRCDEV_MODE_AVOID	1\n  131: struct btrfs_ioctl_dev_replace_start_params {\n  132  	__u64 srcdevid;	/* in, if 0, use srcdev_name instead */\n  133  	__u64 cont_reading_from_srcdev_mode;	/* in, see #define\n  ...\n  137  };\n  138  \n  139: #define BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED	0\n  140: #define BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED		1\n  141: #define BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED		2\n  142: #define BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED		3\n  143: #define BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED		4\n  144: struct btrfs_ioctl_dev_replace_status_params {\n  145  	__u64 replace_state;	/* out, see #define above */\n  146  	__u64 progress_1000;	/* out, 0 <= x <= 1000 */\n  ...\n  151  };\n  152  \n  153: #define BTRFS_IOCTL_DEV_REPLACE_CMD_START			0\n  154: #define BTRFS_IOCTL_DEV_REPLACE_CMD_STATUS			1\n  155: #define BTRFS_IOCTL_DEV_REPLACE_CMD_CANCEL			2\n  156: #define BTRFS_IOCTL_DEV_REPLACE_RESULT_NO_ERROR			0\n  157: #define BTRFS_IOCTL_DEV_REPLACE_RESULT_NOT_STARTED		1\n  158: #define BTRFS_IOCTL_DEV_REPLACE_RESULT_ALREADY_STARTED		2\n  159: struct btrfs_ioctl_dev_replace_args {\n  160  	__u64 cmd;	/* in */\n  161  	__u64 result;	/* out */\n  162  \n  163  	union {\n  164: 		struct btrfs_ioctl_dev_replace_start_params start;\n  165: 		struct btrfs_ioctl_dev_replace_status_params status;\n  166  	};	/* in/out */\n  167  \n  ...\n  169  };\n  170  \n  171: struct btrfs_ioctl_dev_info_args {\n  172  	__u64 devid;				/* in/out */\n  173  	__u8 uuid[BTRFS_UUID_SIZE];		/* in/out */\n  ...\n  178  };\n  179  \n  180: struct btrfs_ioctl_fs_info_args {\n  181  	__u64 max_id;				/* out */\n  182  	__u64 num_devices;			/* out */\n  ...\n  185  };\n  186  \n  187: /* balance control ioctl modes */\n  188  #define BTRFS_BALANCE_CTL_PAUSE		1\n  189  #define BTRFS_BALANCE_CTL_CANCEL	2\n  ...\n  221  #define BTRFS_BALANCE_STATE_CANCEL_REQ	(1ULL << 2)\n  222  \n  223: struct btrfs_ioctl_balance_args {\n  224  	__u64 flags;				/* in/out */\n  225  	__u64 state;				/* out */\n  ...\n  235  \n  236  #define BTRFS_INO_LOOKUP_PATH_MAX 4080\n  237: struct btrfs_ioctl_ino_lookup_args {\n  238  	__u64 treeid;\n  239  	__u64 objectid;\n  ...\n  241  };\n  242  \n  243: struct btrfs_ioctl_search_key {\n  244  	/* which root are we searching.  0 is the tree of tree roots */\n  245  	__u64 tree_id;\n  ...\n  277  };\n  278  \n  279: struct btrfs_ioctl_search_header {\n  280  	__u64 transid;\n  281  	__u64 objectid;\n  ...\n  285  };\n  286  \n  287: #define BTRFS_SEARCH_ARGS_BUFSIZE (4096 - sizeof(struct btrfs_ioctl_search_key))\n  288  /*\n  289   * the buf is an array of search headers where\n  ...\n  291   * the type field is expanded to 32 bits for alignment\n  292   */\n  293: struct btrfs_ioctl_search_args {\n  294: 	struct btrfs_ioctl_search_key key;\n  295  	char buf[BTRFS_SEARCH_ARGS_BUFSIZE];\n  296  };\n  297  \n  298: struct btrfs_ioctl_clone_range_args {\n  299    __s64 src_fd;\n  300    __u64 src_offset, src_length;\n  ...\n  302  };\n  303  \n  304: /* flags for the defrag range ioctl */\n  305  #define BTRFS_DEFRAG_RANGE_COMPRESS 1\n  306  #define BTRFS_DEFRAG_RANGE_START_IO 2\n  307  \n  308  #define BTRFS_SAME_DATA_DIFFERS	1\n  309: /* For extent-same ioctl */\n  310: struct btrfs_ioctl_same_extent_info {\n  311  	__s64 fd;		/* in - destination file */\n  312  	__u64 logical_offset;	/* in - start of extent in destination */\n  ...\n  322  };\n  323  \n  324: struct btrfs_ioctl_same_args {\n  325  	__u64 logical_offset;	/* in - start of extent in source */\n  326  	__u64 length;		/* in - length of extent */\n  ...\n  328  	__u16 reserved1;\n  329  	__u32 reserved2;\n  330: 	struct btrfs_ioctl_same_extent_info info[0];\n  331  };\n  332  \n  333: struct btrfs_ioctl_space_info {\n  334  	__u64 flags;\n  335  	__u64 total_bytes;\n  ...\n  337  };\n  338  \n  339: struct btrfs_ioctl_space_args {\n  340  	__u64 space_slots;\n  341  	__u64 total_spaces;\n  342: 	struct btrfs_ioctl_space_info spaces[0];\n  343  };\n  344  \n  ...\n  351  };\n  352  \n  353: struct btrfs_ioctl_ino_path_args {\n  354  	__u64				inum;		/* in */\n  355  	__u64				size;		/* in */\n  ...\n  359  };\n  360  \n  361: struct btrfs_ioctl_logical_ino_args {\n  362  	__u64				logical;	/* in */\n  363  	__u64				size;		/* in */\n  ...\n  389  #define	BTRFS_DEV_STATS_RESET		(1ULL << 0)\n  390  \n  391: struct btrfs_ioctl_get_dev_stats {\n  392  	__u64 devid;				/* in */\n  393  	__u64 nr_items;				/* in/out */\n  ...\n  403  #define BTRFS_QUOTA_CTL_DISABLE	2\n  404  #define BTRFS_QUOTA_CTL_RESCAN__NOTUSED	3\n  405: struct btrfs_ioctl_quota_ctl_args {\n  406  	__u64 cmd;\n  407  	__u64 status;\n  408  };\n  409  \n  410: struct btrfs_ioctl_quota_rescan_args {\n  411  	__u64	flags;\n  412  	__u64   progress;\n  ...\n  414  };\n  415  \n  416: struct btrfs_ioctl_qgroup_assign_args {\n  417  	__u64 assign;\n  418  	__u64 src;\n  ...\n  420  };\n  421  \n  422: struct btrfs_ioctl_qgroup_create_args {\n  423  	__u64 create;\n  424  	__u64 qgroupid;\n  425  };\n  426: struct btrfs_ioctl_timespec {\n  427  	__u64 sec;\n  428  	__u32 nsec;\n  429  };\n  430  \n  431: struct btrfs_ioctl_received_subvol_args {\n  432  	char	uuid[BTRFS_UUID_SIZE];	/* in */\n  433  	__u64	stransid;		/* in */\n  434  	__u64	rtransid;		/* out */\n  435: 	struct btrfs_ioctl_timespec stime; /* in */\n  436: 	struct btrfs_ioctl_timespec rtime; /* out */\n  437  	__u64	flags;			/* in */\n  438  	__u64	reserved[16];		/* in */\n  ...\n  464  	 BTRFS_SEND_FLAG_OMIT_END_CMD)\n  465  \n  466: struct btrfs_ioctl_send_args {\n  467  	__s64 send_fd;			/* in */\n  468  	__u64 clone_sources_count;	/* in */\n  ...\n  513  }\n  514  \n  515: #define BTRFS_IOC_SNAP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 1, \\\n  516: 				   struct btrfs_ioctl_vol_args)\n  517: #define BTRFS_IOC_DEFRAG _IOW(BTRFS_IOCTL_MAGIC, 2, \\\n  518: 				   struct btrfs_ioctl_vol_args)\n  519: #define BTRFS_IOC_RESIZE _IOW(BTRFS_IOCTL_MAGIC, 3, \\\n  520: 				   struct btrfs_ioctl_vol_args)\n  521: #define BTRFS_IOC_SCAN_DEV _IOW(BTRFS_IOCTL_MAGIC, 4, \\\n  522: 				   struct btrfs_ioctl_vol_args)\n  523  /* trans start and trans end are dangerous, and only for\n  524   * use by applications that know how to avoid the\n  525   * resulting deadlocks\n  526   */\n  527: #define BTRFS_IOC_TRANS_START  _IO(BTRFS_IOCTL_MAGIC, 6)\n  528: #define BTRFS_IOC_TRANS_END    _IO(BTRFS_IOCTL_MAGIC, 7)\n  529: #define BTRFS_IOC_SYNC         _IO(BTRFS_IOCTL_MAGIC, 8)\n  530  \n  531: #define BTRFS_IOC_CLONE        _IOW(BTRFS_IOCTL_MAGIC, 9, int)\n  532: #define BTRFS_IOC_ADD_DEV _IOW(BTRFS_IOCTL_MAGIC, 10, \\\n  533: 				   struct btrfs_ioctl_vol_args)\n  534: #define BTRFS_IOC_RM_DEV _IOW(BTRFS_IOCTL_MAGIC, 11, \\\n  535: 				   struct btrfs_ioctl_vol_args)\n  536: #define BTRFS_IOC_BALANCE _IOW(BTRFS_IOCTL_MAGIC, 12, \\\n  537: 				   struct btrfs_ioctl_vol_args)\n  538  \n  539: #define BTRFS_IOC_CLONE_RANGE _IOW(BTRFS_IOCTL_MAGIC, 13, \\\n  540: 				  struct btrfs_ioctl_clone_range_args)\n  541  \n  542: #define BTRFS_IOC_SUBVOL_CREATE _IOW(BTRFS_IOCTL_MAGIC, 14, \\\n  543: 				   struct btrfs_ioctl_vol_args)\n  544: #define BTRFS_IOC_SNAP_DESTROY _IOW(BTRFS_IOCTL_MAGIC, 15, \\\n  545: 				struct btrfs_ioctl_vol_args)\n  546: #define BTRFS_IOC_DEFRAG_RANGE _IOW(BTRFS_IOCTL_MAGIC, 16, \\\n  547: 				struct btrfs_ioctl_defrag_range_args)\n  548: #define BTRFS_IOC_TREE_SEARCH _IOWR(BTRFS_IOCTL_MAGIC, 17, \\\n  549: 				   struct btrfs_ioctl_search_args)\n  550: #define BTRFS_IOC_INO_LOOKUP _IOWR(BTRFS_IOCTL_MAGIC, 18, \\\n  551: 				   struct btrfs_ioctl_ino_lookup_args)\n  552: #define BTRFS_IOC_DEFAULT_SUBVOL _IOW(BTRFS_IOCTL_MAGIC, 19, __u64)\n  553: #define BTRFS_IOC_SPACE_INFO _IOWR(BTRFS_IOCTL_MAGIC, 20, \\\n  554: 				    struct btrfs_ioctl_space_args)\n  555: #define BTRFS_IOC_START_SYNC _IOR(BTRFS_IOCTL_MAGIC, 24, __u64)\n  556: #define BTRFS_IOC_WAIT_SYNC  _IOW(BTRFS_IOCTL_MAGIC, 22, __u64)\n  557: #define BTRFS_IOC_SNAP_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 23, \\\n  558: 				   struct btrfs_ioctl_vol_args_v2)\n  559: #define BTRFS_IOC_SUBVOL_CREATE_V2 _IOW(BTRFS_IOCTL_MAGIC, 24, \\\n  560: 				   struct btrfs_ioctl_vol_args_v2)\n  561: #define BTRFS_IOC_SUBVOL_GETFLAGS _IOR(BTRFS_IOCTL_MAGIC, 25, __u64)\n  562: #define BTRFS_IOC_SUBVOL_SETFLAGS _IOW(BTRFS_IOCTL_MAGIC, 26, __u64)\n  563: #define BTRFS_IOC_SCRUB _IOWR(BTRFS_IOCTL_MAGIC, 27, \\\n  564: 			      struct btrfs_ioctl_scrub_args)\n  565: #define BTRFS_IOC_SCRUB_CANCEL _IO(BTRFS_IOCTL_MAGIC, 28)\n  566: #define BTRFS_IOC_SCRUB_PROGRESS _IOWR(BTRFS_IOCTL_MAGIC, 29, \\\n  567: 				       struct btrfs_ioctl_scrub_args)\n  568: #define BTRFS_IOC_DEV_INFO _IOWR(BTRFS_IOCTL_MAGIC, 30, \\\n  569: 				 struct btrfs_ioctl_dev_info_args)\n  570: #define BTRFS_IOC_FS_INFO _IOR(BTRFS_IOCTL_MAGIC, 31, \\\n  571: 			       struct btrfs_ioctl_fs_info_args)\n  572: #define BTRFS_IOC_BALANCE_V2 _IOWR(BTRFS_IOCTL_MAGIC, 32, \\\n  573: 				   struct btrfs_ioctl_balance_args)\n  574: #define BTRFS_IOC_BALANCE_CTL _IOW(BTRFS_IOCTL_MAGIC, 33, int)\n  575: #define BTRFS_IOC_BALANCE_PROGRESS _IOR(BTRFS_IOCTL_MAGIC, 34, \\\n  576: 					struct btrfs_ioctl_balance_args)\n  577: #define BTRFS_IOC_INO_PATHS _IOWR(BTRFS_IOCTL_MAGIC, 35, \\\n  578: 					struct btrfs_ioctl_ino_path_args)\n  579: #define BTRFS_IOC_LOGICAL_INO _IOWR(BTRFS_IOCTL_MAGIC, 36, \\\n  580: 					struct btrfs_ioctl_ino_path_args)\n  581: #define BTRFS_IOC_SET_RECEIVED_SUBVOL _IOWR(BTRFS_IOCTL_MAGIC, 37, \\\n  582: 				struct btrfs_ioctl_received_subvol_args)\n  583: #define BTRFS_IOC_SEND _IOW(BTRFS_IOCTL_MAGIC, 38, struct btrfs_ioctl_send_args)\n  584: #define BTRFS_IOC_DEVICES_READY _IOR(BTRFS_IOCTL_MAGIC, 39, \\\n  585: 				     struct btrfs_ioctl_vol_args)\n  586: #define BTRFS_IOC_QUOTA_CTL _IOWR(BTRFS_IOCTL_MAGIC, 40, \\\n  587: 			       struct btrfs_ioctl_quota_ctl_args)\n  588: #define BTRFS_IOC_QGROUP_ASSIGN _IOW(BTRFS_IOCTL_MAGIC, 41, \\\n  589: 			       struct btrfs_ioctl_qgroup_assign_args)\n  590: #define BTRFS_IOC_QGROUP_CREATE _IOW(BTRFS_IOCTL_MAGIC, 42, \\\n  591: 			       struct btrfs_ioctl_qgroup_create_args)\n  592: #define BTRFS_IOC_QGROUP_LIMIT _IOR(BTRFS_IOCTL_MAGIC, 43, \\\n  593: 			       struct btrfs_ioctl_qgroup_limit_args)\n  594: #define BTRFS_IOC_QUOTA_RESCAN _IOW(BTRFS_IOCTL_MAGIC, 44, \\\n  595: 			       struct btrfs_ioctl_quota_rescan_args)\n  596: #define BTRFS_IOC_QUOTA_RESCAN_STATUS _IOR(BTRFS_IOCTL_MAGIC, 45, \\\n  597: 			       struct btrfs_ioctl_quota_rescan_args)\n  598: #define BTRFS_IOC_QUOTA_RESCAN_WAIT _IO(BTRFS_IOCTL_MAGIC, 46)\n  599: #define BTRFS_IOC_GET_FSLABEL _IOR(BTRFS_IOCTL_MAGIC, 49, \\\n  600  				   char[BTRFS_LABEL_SIZE])\n  601: #define BTRFS_IOC_SET_FSLABEL _IOW(BTRFS_IOCTL_MAGIC, 50, \\\n  602  				   char[BTRFS_LABEL_SIZE])\n  603: #define BTRFS_IOC_GET_DEV_STATS _IOWR(BTRFS_IOCTL_MAGIC, 52, \\\n  604: 				      struct btrfs_ioctl_get_dev_stats)\n  605: #define BTRFS_IOC_DEV_REPLACE _IOWR(BTRFS_IOCTL_MAGIC, 53, \\\n  606: 				    struct btrfs_ioctl_dev_replace_args)\n  607: #define BTRFS_IOC_FILE_EXTENT_SAME _IOWR(BTRFS_IOCTL_MAGIC, 54, \\\n  608: 					 struct btrfs_ioctl_same_args)\n  609  \n  610  #endif /* _LINUX_BTRFS_H */\n\n/usr/include/linux/capability.h:\n  229  /* Allow calling bdflush() */\n  230  /* Allow mount() and umount(), setting up new smb connection */\n  231: /* Allow some autofs root ioctls */\n  232  /* Allow nfsservctl */\n  233  /* Allow VM86_REQUEST_IRQ */\n  ...\n  245  /* Allow turning DMA on/off in xd driver */\n  246  /* Allow administration of md devices (mostly the above, but some\n  247:    extra ioctls) */\n  248  /* Allow tuning the ide driver */\n  249  /* Allow access to the nvram device */\n  ...\n  251  /* Allow manufacturer commands in isdn CAPI support driver */\n  252  /* Allow reading non-standardized portions of pci configuration space */\n  253: /* Allow DDI debug ioctl on sbpcd driver */\n  254  /* Allow setting up serial ports */\n  255  /* Allow sending raw qic-117 commands */\n\n/usr/include/linux/capi.h:\n   14  \n   15  #include <linux/types.h>\n   16: #include <linux/ioctl.h>\n   17  #include <linux/kernelcapi.h>\n   18  \n   ..\n   87  /*\n   88   * CAPI_GET_ERRCODE\n   89:  * capi errcode is set, * if read, write, or ioctl returns EIO,\n   90:  * ioctl returns errcode directly, and in arg, if != 0\n   91   */\n   92  \n   ..\n  104   * and CAPI_GET_PROFILE\n  105   */\n  106: typedef union capi_ioctl_struct {\n  107  	__u32 contr;\n  108  	capi_register_params rparams;\n  ...\n  113  	capi_manufacturer_cmd cmd;\n  114  	__u16 errcode;\n  115: } capi_ioctl_struct;\n  116  \n  117  /*\n\n/usr/include/linux/cciss_ioctl.h:\n    1: #ifndef CCISS_IOCTLH\n    2: #define CCISS_IOCTLH\n    3  \n    4  #include <linux/types.h>\n    5: #include <linux/ioctl.h>\n    6  #include <linux/cciss_defs.h>\n    7  \n    .\n   38  #define MAX_KMALLOC_SIZE 128000\n   39  \n   40: typedef struct _IOCTL_Command_struct {\n   41    LUNAddr_struct	   LUN_info;\n   42    RequestBlock_struct      Request;\n   ..\n   44    WORD			   buf_size;  /* size in bytes of the buf */\n   45    BYTE			   *buf;\n   46: } IOCTL_Command_struct;\n   47  \n   48: typedef struct _BIG_IOCTL_Command_struct {\n   49    LUNAddr_struct	   LUN_info;\n   50    RequestBlock_struct      Request;\n   ..\n   54    				        /* < malloc_size * MAXSGENTRIES */\n   55    BYTE			   *buf;\n   56: } BIG_IOCTL_Command_struct;\n   57  \n   58  typedef struct _LogvolInfo_struct{\n   ..\n   75  #define CCISS_GETDRIVVER   _IOR(CCISS_IOC_MAGIC, 9, DriverVer_type)\n   76  #define CCISS_REVALIDVOLS  _IO(CCISS_IOC_MAGIC, 10)\n   77: #define CCISS_PASSTHRU	   _IOWR(CCISS_IOC_MAGIC, 11, IOCTL_Command_struct)\n   78  #define CCISS_DEREGDISK	   _IO(CCISS_IOC_MAGIC, 12)\n   79  \n   ..\n   84  #define CCISS_RESCANDISK   _IO(CCISS_IOC_MAGIC, 16)\n   85  #define CCISS_GETLUNINFO   _IOR(CCISS_IOC_MAGIC, 17, LogvolInfo_struct)\n   86: #define CCISS_BIG_PASSTHRU _IOWR(CCISS_IOC_MAGIC, 18, BIG_IOCTL_Command_struct)\n   87  \n   88: #endif /* CCISS_IOCTLH */\n   89  \n\n/usr/include/linux/cdrom.h:\n   25   * Additionally, as of Linux 2.1.x, all Linux application programs \n   26   * should use the O_NONBLOCK option when opening a CD-ROM device \n   27:  * for subsequent ioctl commands.  This allows for neat system errors \n   28   * like \"No medium found\" or \"Wrong medium type\" upon attempting to \n   29   * mount or play an empty slot, mount an audio disc, or play a data disc.\n   ..\n   47  \n   48  /*******************************************************\n   49:  * The CD-ROM IOCTL commands  -- these should be supported by \n   50:  * all the various cdrom drivers.  For the CD-ROM ioctls, we \n   51   * will commandeer byte 0x53, or 'S'.\n   52   *******************************************************/\n   ..\n   86                                             (struct cdrom_read) */\n   87  /* \n   88:  * These ioctls are used only used in aztcd.c and optcd.c\n   89   */\n   90  #define CDROMREADCOOKED		0x5315	/* read data in cooked mode */\n   ..\n   92    \n   93  /*\n   94:  * This ioctl is only used by the scsi-cd driver.  \n   95     It is for playing audio in logical block addressing mode.\n   96   */\n   ..\n   98  \n   99  /* \n  100:  * These ioctls are only used in optcd.c\n  101   */\n  102  #define CDROMREADALL		0x5318	/* read all 2646 bytes */\n  103  \n  104  /* \n  105:  * These ioctls are (now) only in ide-cd.c for controlling \n  106   * drive spindown time.  They should be implemented in the\n  107   * Uniform driver, via generic packet commands, GPCMD_MODE_SELECT_10,\n  ...\n  113  \n  114  /* \n  115:  * These ioctls are implemented through the uniform CD-ROM driver\n  116   * They _will_ be adopted by all CD-ROM drivers, when all the CD-ROM\n  117   * drivers are eventually ported to the uniform CD-ROM driver interface.\n  ...\n  130  #define CDROM_GET_CAPABILITY	0x5331	/* get capabilities */\n  131  \n  132: /* Note that scsi/scsi_ioctl.h also uses 0x5382 - 0x5386.\n  133:  * Future CDROM ioctls should be kept below 0x537F\n  134   */\n  135  \n  136: /* This ioctl is only used by sbpcd at the moment */\n  137  #define CDROMAUDIOBUFSIZ        0x5382	/* set the audio buffer size */\n  138: 					/* conflict with SCSI_IOCTL_GET_IDLUN */\n  139  \n  140: /* DVD-ROM Specific ioctls */\n  141  #define DVD_READ_STRUCT		0x5390  /* Read structure */\n  142  #define DVD_WRITE_STRUCT	0x5391  /* Write structure */\n  ...\n  148  \n  149  /*******************************************************\n  150:  * CDROM IOCTL structures\n  151   *******************************************************/\n  152  \n  ...\n  166  };\n  167  \n  168: /* This struct is used by the CDROMPLAYMSF ioctl */ \n  169  struct cdrom_msf \n  170  {\n  ...\n  177  };\n  178  \n  179: /* This struct is used by the CDROMPLAYTRKIND ioctl */\n  180  struct cdrom_ti \n  181  {\n  ...\n  186  };\n  187  \n  188: /* This struct is used by the CDROMREADTOCHDR ioctl */\n  189  struct cdrom_tochdr 	\n  190  {\n  ...\n  193  };\n  194  \n  195: /* This struct is used by the CDROMVOLCTRL and CDROMVOLREAD ioctls */\n  196  struct cdrom_volctrl\n  197  {\n  ...\n  202  };\n  203  \n  204: /* This struct is used by the CDROMSUBCHNL ioctl */\n  205  struct cdrom_subchnl \n  206  {\n  ...\n  216  \n  217  \n  218: /* This struct is used by the CDROMREADTOCENTRY ioctl */\n  219  struct cdrom_tocentry \n  220  {\n  ...\n  227  };\n  228  \n  229: /* This struct is used by the CDROMREADMODE1, and CDROMREADMODE2 ioctls */\n  230  struct cdrom_read      \n  231  {\n  ...\n  235  };\n  236  \n  237: /* This struct is used by the CDROMREADAUDIO ioctl */\n  238  struct cdrom_read_audio\n  239  {\n  ...\n  244  };\n  245  \n  246: /* This struct is used with the CDROMMULTISESSION ioctl */\n  247  struct cdrom_multisession\n  248  {\n  ...\n  254  };\n  255  \n  256: /* This struct is used with the CDROM_GET_MCN ioctl.  \n  257   * Very few audio discs actually have Universal Product Code information, \n  258   * which should just be the Medium Catalog Number on the box.  Also note \n  ...\n  264  };\n  265  \n  266: /* This is used by the CDROMPLAYBLK ioctl */\n  267  struct cdrom_blk \n  268  {\n  ...\n  278  #define CGC_DATA_NONE		3\n  279  \n  280: /* for CDROM_PACKET_COMMAND ioctl */\n  281  struct cdrom_generic_command\n  282  {\n  ...\n  392  #define CDC_RAM			0x200000 /* ok to open for WRITE */\n  393  \n  394: /* drive status possibilities returned by CDROM_DRIVE_STATUS ioctl */\n  395  #define CDS_NO_INFO		0	/* if not implemented */\n  396  #define CDS_NO_DISC		1\n  ...\n  399  #define CDS_DISC_OK		4\n  400  \n  401: /* return values for the CDROM_DISC_STATUS ioctl */\n  402  /* can also return CDS_NO_[INFO|DISC], from above */\n  403  #define CDS_AUDIO		100\n  ...\n  589  \n  590  /*\n  591:  * DVD authentication ioctl\n  592   */\n  593  \n\n/usr/include/linux/chio.h:\n    1  /*\n    2:  * ioctl interface for the scsi media changer driver\n    3   */\n    4  \n    .\n  147  #define CSV_CLEARTAG  0x04       /* clear volume tag */\n  148  \n  149: /* ioctls */\n  150  #define CHIOMOVE       _IOW('c', 1,struct changer_move)\n  151  #define CHIOEXCHANGE   _IOW('c', 2,struct changer_exchange)\n\n/usr/include/linux/cm4000_cs.h:\n    3  \n    4  #include <linux/types.h>\n    5: #include <linux/ioctl.h>\n    6  \n    7  #define	MAX_ATR			33\n    .\n    9  #define	CM4000_MAX_DEV		4\n   10  \n   11: /* those two structures are passed via ioctl() from/to userspace.  They are\n   12   * used by existing userspace programs, so I kepth the awkward \"bIFSD\" naming\n   13   * not to break compilation of userspace apps. -HW */\n\n/usr/include/linux/coda.h:\n  248  #define CODA_OPEN	4\n  249  #define CODA_CLOSE	5\n  250: #define CODA_IOCTL	6\n  251  #define CODA_GETATTR	7\n  252  #define CODA_SETATTR	8\n  ...\n  363  };\n  364  \n  365: /* coda_ioctl: */\n  366: struct coda_ioctl_in {\n  367      struct coda_in_hdr ih;\n  368      struct CodaFid VFid;\n  ...\n  373  };\n  374  \n  375: struct coda_ioctl_out {\n  376      struct coda_out_hdr oh;\n  377      int	len;\n  ...\n  651      struct coda_release_in coda_release;\n  652      struct coda_close_in coda_close;\n  653:     struct coda_ioctl_in coda_ioctl;\n  654      struct coda_getattr_in coda_getattr;\n  655      struct coda_setattr_in coda_setattr;\n  ...\n  675      struct coda_root_out coda_root;\n  676      struct coda_open_out coda_open;\n  677:     struct coda_ioctl_out coda_ioctl;\n  678      struct coda_getattr_out coda_getattr;\n  679      struct coda_lookup_out coda_lookup;\n  ...\n  704  \n  705  /*\n  706:  * Used for identifying usage of \"Control\" and pioctls\n  707   */\n  708  \n  709  #define PIOCPARM_MASK 0x0000ffff\n  710: struct ViceIoctl {\n  711          void *in;        /* Data to be transferred in */\n  712          void *out;       /* Data to be transferred out */\n  ...\n  715  };\n  716  \n  717: struct PioctlData {\n  718          const char *path;\n  719          int follow;\n  720:         struct ViceIoctl vi;\n  721  };\n  722  \n\n/usr/include/linux/cyclades.h:\n   28   *changes in the cyclades_port structure to get it closer to the \n   29   *standard serial port structure;\n   30:  *added constants for new ioctls;\n   31   *\n   32   *Revision 2.2  1998/02/17 16:50:00  ivan\n   33   *changes in the cyclades_port structure (addition of shutdown_wait and \n   34   *chip_rev variables);\n   35:  *added constants for new ioctls and for CD1400 rev. numbers.\n   36   *\n   37   *Revision 2.1	1997/10/24 16:03:00  ivan\n   ..\n   42   *\n   43   *Revision 2.0  1997/06/30 10:30:00  ivan\n   44:  *added some new doorbell command constants related to IOCTLW and\n   45   *UART error signaling\n   46   *\n   ..\n  311  #define C_IN_OVR_ERROR  0x00008000      /* overrun error */\n  312  #define C_IN_RXOFL	0x00010000      /* RX buffer overflow */\n  313: #define C_IN_IOCTLW	0x00020000      /* I/O control w/ wait */\n  314  #define C_IN_MRTS	0x00040000	/* modem RTS drop */\n  315  #define C_IN_ICHAR	0x00080000\n  ...\n  331  \n  332  #define C_RS_PARAM	0x80000000	/* Indicates presence of parameter in \n  333: 					   IOCTLM command */\n  334  #define	C_RS_RTS	0x00000001	/* RTS */\n  335  #define	C_RS_DTR	0x00000004	/* DTR */\n  ...\n  342  \n  343  #define	C_CM_RESET	0x01		/* reset/flush buffers */\n  344: #define	C_CM_IOCTL	0x02		/* re-read CH_CTRL */\n  345: #define	C_CM_IOCTLW	0x03		/* re-read CH_CTRL, intr when done */\n  346: #define	C_CM_IOCTLM	0x04		/* RS-232 outputs change */\n  347  #define	C_CM_SENDXOFF	0x10		/* send Xoff */\n  348  #define	C_CM_SENDXON	0x11		/* send Xon */\n\n/usr/include/linux/dm-ioctl.h:\n    6   */\n    7  \n    8: #ifndef _LINUX_DM_IOCTL_V4_H\n    9: #define _LINUX_DM_IOCTL_V4_H\n   10  \n   11  #include <linux/types.h>\n   ..\n   18  \n   19  /*\n   20:  * A traditional ioctl interface for the device mapper.\n   21   *\n   22   * Each device can have two tables associated with it, an\n   ..\n   26   *\n   27   * DM_VERSION:\n   28:  * Just get the version information for the ioctl interface.\n   29   *\n   30   * DM_REMOVE_ALL:\n   ..\n   95  \n   96  /*\n   97:  * All ioctl arguments consist of a single chunk of memory, with\n   98   * this structure at the start.  If a uuid is specified any\n   99   * lookup (eg. for a DM_INFO) will be done on that, *not* the\n  100   * name.\n  101   */\n  102: struct dm_ioctl {\n  103  	/*\n  104  	 * The version number is made up of three parts:\n  ...\n  107  	 * patch - both backwards and forwards compatible.\n  108  	 *\n  109: 	 * All clients of the ioctl interface should fill in the\n  110  	 * version number of the interface that they were\n  111  	 * compiled with.\n  112  	 *\n  113: 	 * All recognised ioctl commands (ie. those that don't\n  114  	 * return -ENOTTY) fill out this field, even if the\n  115  	 * command failed.\n  ...\n  129  	 * event_nr holds either the event number (input and output) or the\n  130  	 * udev cookie value (input only).\n  131: 	 * The DM_DEV_WAIT ioctl takes an event number as input.\n  132: 	 * The DM_SUSPEND, DM_DEV_REMOVE and DM_DEV_RENAME ioctls\n  133  	 * use the field as a cookie to return in the DM_COOKIE\n  134  	 * variable with the uevents they issue.\n  135: 	 * For output, the ioctls return the event number, not the cookie.\n  136  	 */\n  137  	__u32 event_nr;      	/* in/out */\n  ...\n  148  /*\n  149   * Used to specify tables.  These structures appear after the\n  150:  * dm_ioctl.\n  151   */\n  152  struct dm_target_spec {\n  ...\n  162  	 * - When retrieving targets on a DM_TABLE_STATUS command, this value\n  163  	 *   is the number of bytes from the start of the first dm_target_spec\n  164: 	 *   (that follows the dm_ioctl struct) to the start of the \"next\"\n  165  	 *   dm_target_spec.\n  166  	 */\n  ...\n  216  /*\n  217   * If you change this make sure you make the corresponding change\n  218:  * to dm-ioctl.c:lookup_ioctl()\n  219   */\n  220  enum {\n  ...\n  244  };\n  245  \n  246: #define DM_IOCTL 0xfd\n  247  \n  248: #define DM_VERSION       _IOWR(DM_IOCTL, DM_VERSION_CMD, struct dm_ioctl)\n  249: #define DM_REMOVE_ALL    _IOWR(DM_IOCTL, DM_REMOVE_ALL_CMD, struct dm_ioctl)\n  250: #define DM_LIST_DEVICES  _IOWR(DM_IOCTL, DM_LIST_DEVICES_CMD, struct dm_ioctl)\n  251  \n  252: #define DM_DEV_CREATE    _IOWR(DM_IOCTL, DM_DEV_CREATE_CMD, struct dm_ioctl)\n  253: #define DM_DEV_REMOVE    _IOWR(DM_IOCTL, DM_DEV_REMOVE_CMD, struct dm_ioctl)\n  254: #define DM_DEV_RENAME    _IOWR(DM_IOCTL, DM_DEV_RENAME_CMD, struct dm_ioctl)\n  255: #define DM_DEV_SUSPEND   _IOWR(DM_IOCTL, DM_DEV_SUSPEND_CMD, struct dm_ioctl)\n  256: #define DM_DEV_STATUS    _IOWR(DM_IOCTL, DM_DEV_STATUS_CMD, struct dm_ioctl)\n  257: #define DM_DEV_WAIT      _IOWR(DM_IOCTL, DM_DEV_WAIT_CMD, struct dm_ioctl)\n  258  \n  259: #define DM_TABLE_LOAD    _IOWR(DM_IOCTL, DM_TABLE_LOAD_CMD, struct dm_ioctl)\n  260: #define DM_TABLE_CLEAR   _IOWR(DM_IOCTL, DM_TABLE_CLEAR_CMD, struct dm_ioctl)\n  261: #define DM_TABLE_DEPS    _IOWR(DM_IOCTL, DM_TABLE_DEPS_CMD, struct dm_ioctl)\n  262: #define DM_TABLE_STATUS  _IOWR(DM_IOCTL, DM_TABLE_STATUS_CMD, struct dm_ioctl)\n  263  \n  264: #define DM_LIST_VERSIONS _IOWR(DM_IOCTL, DM_LIST_VERSIONS_CMD, struct dm_ioctl)\n  265  \n  266: #define DM_TARGET_MSG	 _IOWR(DM_IOCTL, DM_TARGET_MSG_CMD, struct dm_ioctl)\n  267: #define DM_DEV_SET_GEOMETRY	_IOWR(DM_IOCTL, DM_DEV_SET_GEOMETRY_CMD, struct dm_ioctl)\n  268  \n  269  #define DM_VERSION_MAJOR	4\n  270  #define DM_VERSION_MINOR	27\n  271  #define DM_VERSION_PATCHLEVEL	0\n  272: #define DM_VERSION_EXTRA	\"-ioctl (2013-10-30)\"\n  273  \n  274  /* Status bits */\n  ...\n  278  \n  279  /*\n  280:  * Flag passed into ioctl STATUS command to get table information\n  281   * rather than current status.\n  282   */\n  ...\n  347   * it should instead be scheduled for removal when it gets closed.\n  348   *\n  349:  * On return from DM_DEV_REMOVE, DM_DEV_STATUS or other ioctls, this\n  350   * flag indicates that the device is scheduled to be removed when it\n  351   * gets closed.\n  ...\n  353  #define DM_DEFERRED_REMOVE		(1 << 17) /* In/Out */\n  354  \n  355: #endif				/* _LINUX_DM_IOCTL_H */\n  356  \n\n/usr/include/linux/dm-log-userspace.h:\n    8  #define __DM_LOG_USERSPACE_H__\n    9  \n   10: #include <linux/dm-ioctl.h> /* For DM_UUID_LEN */\n   11  \n   12  /*\n\n/usr/include/linux/dn.h:\n  138  };\n  139  \n  140: #define DECNET_IOCTL_BASE 0x89 /* PROTOPRIVATE range */\n  141  \n  142: #define SIOCSNETADDR  _IOW(DECNET_IOCTL_BASE, 0xe0, struct dn_naddr)\n  143: #define SIOCGNETADDR  _IOR(DECNET_IOCTL_BASE, 0xe1, struct dn_naddr)\n  144: #define OSIOCSNETADDR _IOW(DECNET_IOCTL_BASE, 0xe0, int)\n  145: #define OSIOCGNETADDR _IOR(DECNET_IOCTL_BASE, 0xe1, int)\n  146  \n  147  #endif /* _LINUX_DN_H */\n\n/usr/include/linux/fb.h:\n    9  #define FB_MAX			32	/* sufficient for now */\n   10  \n   11: /* ioctls\n   12     0x46 is 'F'								*/\n   13  #define FBIOGET_VSCREENINFO	0x4600\n\n/usr/include/linux/fd.h:\n    2  #define _LINUX_FD_H\n    3  \n    4: #include <linux/ioctl.h>\n    5  \n    6  \n    7: /* New file layout: Now the ioctl definitions immediately follow the\n    8   * definitions of the structures that they use */\n    9  \n   ..\n  292  	/* Write error logging.\n  293  	 *\n  294: 	 * These fields can be cleared with the FDWERRORCLR ioctl.\n  295  	 * Only writes that were attempted but failed due to a physical media\n  296  	 * error are logged.  write(2) calls that fail and return an error code\n\n/usr/include/linux/fiemap.h:\n    1  /*\n    2:  * FS_IOC_FIEMAP ioctl infrastructure.\n    3   *\n    4   * Some portions copyright (C) 2007 Cluster File Systems, Inc\n\n/usr/include/linux/firewire-cdev.h:\n   27  #define _LINUX_FIREWIRE_CDEV_H\n   28  \n   29: #include <linux/ioctl.h>\n   30  #include <linux/types.h>\n   31  #include <linux/firewire-constants.h>\n   ..\n   57   * Data passed in the @closure field for a request will be returned in the\n   58   * corresponding event.  It is big enough to hold a pointer on all platforms.\n   59:  * The ioctl used to set @closure depends on the @type of event.\n   60   */\n   61  struct fw_cdev_event_common {\n   ..\n   66  /**\n   67   * struct fw_cdev_event_bus_reset - Sent when a bus reset occurred\n   68:  * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_GET_INFO ioctl\n   69   * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_BUS_RESET\n   70   * @node_id:       New node ID of this node\n   ..\n   80   *\n   81   * If @bm_node_id is 0xffff right after bus reset it can be reread by an\n   82:  * %FW_CDEV_IOC_GET_INFO ioctl after bus manager selection was finished.\n   83   * Kernels with ABI version < 4 do not set @bm_node_id.\n   84   */\n   ..\n   98   * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_REQUEST\n   99   *		or %FW_CDEV_IOC_SEND_BROADCAST_REQUEST\n  100:  *		or %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl\n  101   * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_RESPONSE\n  102   * @rcode:	Response code returned by the remote node\n  ...\n  105   *\n  106   * This event is sent when the stack receives a response to an outgoing request\n  107:  * sent by %FW_CDEV_IOC_SEND_REQUEST ioctl.  The payload data for responses\n  108   * carrying data (read and lock responses) follows immediately and can be\n  109   * accessed through the @data field.\n  ...\n  142  /**\n  143   * struct fw_cdev_event_request2 - Sent on incoming request to an address region\n  144:  * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_ALLOCATE ioctl\n  145   * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_REQUEST2\n  146   * @tcode:	Transaction code of the incoming request\n  ...\n  155   *\n  156   * This event is sent when the stack receives an incoming request to an address\n  157:  * region registered using the %FW_CDEV_IOC_ALLOCATE ioctl.  The request is\n  158   * guaranteed to be completely contained in the specified region.  Userspace is\n  159:  * responsible for sending the response by %FW_CDEV_IOC_SEND_RESPONSE ioctl,\n  160   * using the same @handle.\n  161   *\n  ...\n  175   * @destination_node_id may also differ from the current node ID because of a\n  176   * non-local bus ID part or in case of a broadcast write request.  Note, a\n  177:  * client must call an %FW_CDEV_IOC_SEND_RESPONSE ioctl even in case of a\n  178   * broadcast write request; the kernel will then release the kernel-side pending\n  179   * request but will not actually send a response packet.\n  ...\n  181   * In case of a write request to FCP_REQUEST or FCP_RESPONSE, the kernel already\n  182   * sent a write response immediately after the request was received; in this\n  183:  * case the client must still call an %FW_CDEV_IOC_SEND_RESPONSE ioctl to\n  184   * release the kernel-side pending request, though another response won't be\n  185   * sent.\n  ...\n  206   * struct fw_cdev_event_iso_interrupt - Sent when an iso packet was completed\n  207   * @closure:	See &fw_cdev_event_common;\n  208:  *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl\n  209   * @type:	See &fw_cdev_event_common; always %FW_CDEV_EVENT_ISO_INTERRUPT\n  210   * @cycle:	Cycle counter of the last completed packet\n  ...\n  266   * struct fw_cdev_event_iso_interrupt_mc - An iso buffer chunk was completed\n  267   * @closure:	See &fw_cdev_event_common;\n  268:  *		set by %FW_CDEV_CREATE_ISO_CONTEXT ioctl\n  269   * @type:	%FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL\n  270   * @completed:	Offset into the receive buffer; data before this offset is valid\n  ...\n  303   * struct fw_cdev_event_iso_resource - Iso resources were allocated or freed\n  304   * @closure:	See &fw_cdev_event_common;\n  305:  *		set by %FW_CDEV_IOC_(DE)ALLOCATE_ISO_RESOURCE(_ONCE) ioctl\n  306   * @type:	%FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED or\n  307   *		%FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED\n  ...\n  332   * struct fw_cdev_event_phy_packet - A PHY packet was transmitted or received\n  333   * @closure:	See &fw_cdev_event_common; set by %FW_CDEV_IOC_SEND_PHY_PACKET\n  334:  *		or %FW_CDEV_IOC_RECEIVE_PHY_PACKETS ioctl\n  335   * @type:	%FW_CDEV_EVENT_PHY_PACKET_SENT or %..._RECEIVED\n  336   * @rcode:	%RCODE_..., indicates success or failure of transmission\n  ...\n  455  \n  456  /**\n  457:  * struct fw_cdev_get_info - General purpose information ioctl\n  458   * @version:	The version field is just a running serial number.  Both an\n  459   *		input parameter (ABI version implemented by the client) and\n  ...\n  473   * @card:	The index of the card this device belongs to\n  474   *\n  475:  * The %FW_CDEV_IOC_GET_INFO ioctl is usually the very first one which a client\n  476   * performs right after it opened a /dev/fw* file.\n  477   *\n  478   * As a side effect, reception of %FW_CDEV_EVENT_BUS_RESET events to be read(2)\n  479:  * is started by this ioctl.\n  480   */\n  481  struct fw_cdev_get_info {\n  ...\n  497   * @generation:	The bus generation where packet is valid\n  498   *\n  499:  * Send a request to the device.  This ioctl implements all outgoing requests.\n  500   * Both quadlet and block request specify the payload as a pointer to the data\n  501   * in the @data field.  Once the transaction completes, the kernel writes an\n  ...\n  520   *\n  521   * Send a response to an incoming request.  By setting up an address range using\n  522:  * the %FW_CDEV_IOC_ALLOCATE ioctl, userspace can listen for incoming requests.  An\n  523   * incoming request will generate an %FW_CDEV_EVENT_REQUEST, and userspace must\n  524:  * send a reply using this ioctl.  The event has a handle to the kernel-side\n  525:  * pending transaction, which should be used with this ioctl.\n  526   */\n  527  struct fw_cdev_send_response {\n  ...\n  553   * The address range is allocated on all local nodes.  The address allocation\n  554   * is exclusive except for the FCP command and response registers.  If an\n  555:  * exclusive address region is already in use, the ioctl fails with errno set\n  556   * to %EBUSY.\n  557   *\n  ...\n  597   * introduced in 1394a-2000.\n  598   *\n  599:  * The ioctl returns immediately.  A subsequent &fw_cdev_event_bus_reset\n  600   * indicates when the reset actually happened.  Since ABI v4, this may be\n  601:  * considerably later than the ioctl because the kernel ensures a grace period\n  602   * between subsequent bus resets as per IEEE 1394 bus management specification.\n  603   */\n  ...\n  632   * change of the Configuration ROM to other nodes.\n  633   *\n  634:  * This ioctl affects the Configuration ROMs of all local nodes.\n  635:  * The ioctl only succeeds on device files which represent a local node.\n  636   */\n  637  struct fw_cdev_add_descriptor {\n  ...\n  710   * @channels is the bitwise or of 1ULL << n for each channel n to listen to.\n  711   *\n  712:  * The ioctl fails with errno %EBUSY if there is already another receive context\n  713   * on a channel in @channels.  In that case, the bitmask of all unoccupied\n  714   * channels is returned in @channels.\n  ...\n  743   * @control.HEADER_LENGTH must be a multiple of 4.  It specifies the numbers of\n  744   * bytes in @header that will be prepended to the packet's payload.  These bytes\n  745:  * are copied into the kernel and will not be accessed after the ioctl has\n  746   * returned.\n  747   *\n  ...\n  809   *\n  810   * Queue a number of isochronous packets for reception or transmission.\n  811:  * This ioctl takes a pointer to an array of &fw_cdev_iso_packet structs,\n  812   * which describe how to transmit from or receive into a contiguous region\n  813   * of a mmap()'ed payload buffer.  As part of transmit packet descriptors,\n  ...\n  816   *\n  817   * The kernel may or may not queue all packets, but will write back updated\n  818:  * values of the @packets, @data and @size fields, so the ioctl can be\n  819   * resubmitted easily.\n  820   *\n  ...\n  873   *\n  874   * Any %FW_CDEV_EVENT_ISO_INTERRUPT or %FW_CDEV_EVENT_ISO_INTERRUPT_MULTICHANNEL\n  875:  * events generated by this ioctl are sent synchronously, i.e., are available\n  876:  * for reading from the file descriptor when this ioctl returns.\n  877   */\n  878  struct fw_cdev_flush_iso {\n  ...\n  888   * and only with microseconds resolution.\n  889   *\n  890:  * In version 1 and 2 of the ABI, this ioctl returned unreliable (non-\n  891   * monotonic) @cycle_timer values on certain controllers.\n  892   */\n  ...\n  903   * @cycle_timer:  Cycle Time register contents\n  904   *\n  905:  * The %FW_CDEV_IOC_GET_CYCLE_TIMER2 ioctl reads the isochronous cycle timer\n  906   * and also the system clock.  This allows to correlate reception time of\n  907   * isochronous packets with system time.\n  ...\n  928   * @bandwidth:	Isochronous bandwidth units to be (de)allocated\n  929   * @handle:	Handle to the allocation, written by the kernel (only valid in\n  930:  *		case of %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctls)\n  931   *\n  932:  * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE ioctl initiates allocation of an\n  933   * isochronous channel and/or of isochronous bandwidth at the isochronous\n  934   * resource manager (IRM).  Only one of the channels specified in @channels is\n  ...\n  940   * when the file descriptor is closed.\n  941   *\n  942:  * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE ioctl can be used to initiate\n  943   * deallocation of resources which were allocated as described above.\n  944   * An %FW_CDEV_EVENT_ISO_RESOURCE_DEALLOCATED event concludes this operation.\n  945   *\n  946:  * The %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE ioctl is a variant of allocation\n  947   * without automatic re- or deallocation.\n  948   * An %FW_CDEV_EVENT_ISO_RESOURCE_ALLOCATED event concludes this operation,\n  949   * indicating success or failure in its data.\n  950   *\n  951:  * The %FW_CDEV_IOC_DEALLOCATE_ISO_RESOURCE_ONCE ioctl works like\n  952   * %FW_CDEV_IOC_ALLOCATE_ISO_RESOURCE_ONCE except that resources are freed\n  953   * instead of allocated.\n  ...\n  984   * @speed:	Speed to transmit at\n  985   *\n  986:  * The %FW_CDEV_IOC_SEND_STREAM_PACKET ioctl sends an asynchronous stream packet\n  987   * to every device which is listening to the specified channel.  The kernel\n  988   * writes an &fw_cdev_event_response event which indicates success or failure of\n  ...\n 1006   * @generation:	The bus generation where packet is valid\n 1007   *\n 1008:  * The %FW_CDEV_IOC_SEND_PHY_PACKET ioctl sends a PHY packet to all nodes\n 1009   * on the same card as this device.  After transmission, an\n 1010   * %FW_CDEV_EVENT_PHY_PACKET_SENT event is generated.\n ....\n 1014   * are an exception to this rule.\n 1015   *\n 1016:  * The ioctl is only permitted on device files which represent a local node.\n 1017   */\n 1018  struct fw_cdev_send_phy_packet {\n ....\n 1026   * @closure: Passed back to userspace in phy packet events\n 1027   *\n 1028:  * This ioctl activates issuing of %FW_CDEV_EVENT_PHY_PACKET_RECEIVED due to\n 1029   * incoming PHY packets from any node on the same bus as the device.\n 1030   *\n 1031:  * The ioctl is only permitted on device files which represent a local node.\n 1032   */\n 1033  struct fw_cdev_receive_phy_packets {\n\n/usr/include/linux/fs.h:\n    8  \n    9  #include <linux/limits.h>\n   10: #include <linux/ioctl.h>\n   11  #include <linux/types.h>\n   12  \n   ..\n  128  #define BLKELVSET  _IOW(0x12,107,size_t)/* elevator set */\n  129  /* This was here just to show that the number is taken -\n  130:    probably all these _IO(0x12,*) ioctls should be moved to blkpg.h. */\n  131  #endif\n  132  /* A jump here: 108-111 have been used for various private purposes. */\n  ...\n  148  #define BLKZEROOUT _IO(0x12,127)\n  149  \n  150: #define BMAP_IOCTL 1		/* obsolete - kept for compatibility */\n  151  #define FIBMAP	   _IO(0x00,1)	/* bmap access */\n  152  #define FIGETBSZ   _IO(0x00,2)	/* get the block size used for bmap */\n\n/usr/include/linux/fsl_hypervisor.h:\n    1  /*\n    2:  * Freescale hypervisor ioctl and kernel interface\n    3   *\n    4   * Copyright (C) 2008-2011 Freescale Semiconductor, Inc.\n    .\n   35   * This file is used by the Freescale hypervisor management driver.  It can\n   36   * also be included by applications that need to communicate with the driver\n   37:  * via the ioctl interface.\n   38   */\n   39  \n   ..\n   44  \n   45  /**\n   46:  * struct fsl_hv_ioctl_restart - restart a partition\n   47   * @ret: return error code from the hypervisor\n   48   * @partition: the ID of the partition to restart, or -1 for the\n   49   *             calling partition\n   50   *\n   51:  * Used by FSL_HV_IOCTL_PARTITION_RESTART\n   52   */\n   53: struct fsl_hv_ioctl_restart {\n   54  	__u32 ret;\n   55  	__u32 partition;\n   ..\n   57  \n   58  /**\n   59:  * struct fsl_hv_ioctl_status - get a partition's status\n   60   * @ret: return error code from the hypervisor\n   61   * @partition: the ID of the partition to query, or -1 for the\n   ..\n   63   * @status: The returned status of the partition\n   64   *\n   65:  * Used by FSL_HV_IOCTL_PARTITION_GET_STATUS\n   66   *\n   67   * Values of 'status':\n   ..\n   71   *    3 = Stopping\n   72   */\n   73: struct fsl_hv_ioctl_status {\n   74  	__u32 ret;\n   75  	__u32 partition;\n   ..\n   78  \n   79  /**\n   80:  * struct fsl_hv_ioctl_start - start a partition\n   81   * @ret: return error code from the hypervisor\n   82   * @partition: the ID of the partition to control\n   ..\n   84   * @load: If non-zero, reload the partition's images before starting\n   85   *\n   86:  * Used by FSL_HV_IOCTL_PARTITION_START\n   87   */\n   88: struct fsl_hv_ioctl_start {\n   89  	__u32 ret;\n   90  	__u32 partition;\n   ..\n   94  \n   95  /**\n   96:  * struct fsl_hv_ioctl_stop - stop a partition\n   97   * @ret: return error code from the hypervisor\n   98   * @partition: the ID of the partition to stop, or -1 for the calling\n   99   *             partition\n  100   *\n  101:  * Used by FSL_HV_IOCTL_PARTITION_STOP\n  102   */\n  103: struct fsl_hv_ioctl_stop {\n  104  	__u32 ret;\n  105  	__u32 partition;\n  ...\n  107  \n  108  /**\n  109:  * struct fsl_hv_ioctl_memcpy - copy memory between partitions\n  110   * @ret: return error code from the hypervisor\n  111   * @source: the partition ID of the source partition, or -1 for this\n  ...\n  121   *         buffers must be at least 'count' bytes long\n  122   *\n  123:  * Used by FSL_HV_IOCTL_MEMCPY\n  124   *\n  125:  * The 'local' partition is the partition that calls this ioctl.  The\n  126   * 'remote' partition is a different partition.  The data is copied from\n  127   * the 'source' paritition' to the 'target' partition.\n  ...\n  130   * contiguous.\n  131   *\n  132:  * This ioctl does not support copying memory between two remote\n  133   * partitions or within the same partition, so either 'source' or\n  134   * 'target' (but not both) must be -1.  In other words, either\n  ...\n  138   *      source == remote and target == local\n  139   */\n  140: struct fsl_hv_ioctl_memcpy {\n  141  	__u32 ret;\n  142  	__u32 source;\n  ...\n  149  \n  150  /**\n  151:  * struct fsl_hv_ioctl_doorbell - ring a doorbell\n  152   * @ret: return error code from the hypervisor\n  153   * @doorbell: the handle of the doorbell to ring doorbell\n  154   *\n  155:  * Used by FSL_HV_IOCTL_DOORBELL\n  156   */\n  157: struct fsl_hv_ioctl_doorbell {\n  158  	__u32 ret;\n  159  	__u32 doorbell;\n  ...\n  161  \n  162  /**\n  163:  * struct fsl_hv_ioctl_prop - get/set a device tree property\n  164   * @ret: return error code from the hypervisor\n  165   * @handle: handle of partition whose tree to access\n  ...\n  170   * @reserved: reserved, must be set to 0\n  171   *\n  172:  * Used by FSL_HV_IOCTL_DOORBELL\n  173   */\n  174: struct fsl_hv_ioctl_prop {\n  175  	__u32 ret;\n  176  	__u32 handle;\n  ...\n  182  };\n  183  \n  184: /* The ioctl type, documented in ioctl-number.txt */\n  185: #define FSL_HV_IOCTL_TYPE	0xAF\n  186  \n  187  /* Restart another partition */\n  188: #define FSL_HV_IOCTL_PARTITION_RESTART \\\n  189: 	_IOWR(FSL_HV_IOCTL_TYPE, 1, struct fsl_hv_ioctl_restart)\n  190  \n  191  /* Get a partition's status */\n  192: #define FSL_HV_IOCTL_PARTITION_GET_STATUS \\\n  193: 	_IOWR(FSL_HV_IOCTL_TYPE, 2, struct fsl_hv_ioctl_status)\n  194  \n  195  /* Boot another partition */\n  196: #define FSL_HV_IOCTL_PARTITION_START \\\n  197: 	_IOWR(FSL_HV_IOCTL_TYPE, 3, struct fsl_hv_ioctl_start)\n  198  \n  199  /* Stop this or another partition */\n  200: #define FSL_HV_IOCTL_PARTITION_STOP \\\n  201: 	_IOWR(FSL_HV_IOCTL_TYPE, 4, struct fsl_hv_ioctl_stop)\n  202  \n  203  /* Copy data from one partition to another */\n  204: #define FSL_HV_IOCTL_MEMCPY \\\n  205: 	_IOWR(FSL_HV_IOCTL_TYPE, 5, struct fsl_hv_ioctl_memcpy)\n  206  \n  207  /* Ring a doorbell */\n  208: #define FSL_HV_IOCTL_DOORBELL \\\n  209: 	_IOWR(FSL_HV_IOCTL_TYPE, 6, struct fsl_hv_ioctl_doorbell)\n  210  \n  211  /* Get a property from another guest's device tree */\n  212: #define FSL_HV_IOCTL_GETPROP \\\n  213: 	_IOWR(FSL_HV_IOCTL_TYPE, 7, struct fsl_hv_ioctl_prop)\n  214  \n  215  /* Set a property in another guest's device tree */\n  216: #define FSL_HV_IOCTL_SETPROP \\\n  217: 	_IOWR(FSL_HV_IOCTL_TYPE, 8, struct fsl_hv_ioctl_prop)\n  218  \n  219  \n\n/usr/include/linux/fuse.h:\n   49   *\n   50   * 7.11\n   51:  *  - add IOCTL message\n   52   *  - add unsolicited notification support\n   53   *  - add POLL message and NOTIFY_POLL notification\n   ..\n   71   * 7.16\n   72   *  - add BATCH_FORGET request\n   73:  *  - FUSE_IOCTL_UNRESTRICTED shall now return with array of 'struct\n   74:  *    fuse_ioctl_iovec' instead of ambiguous 'struct iovec'\n   75:  *  - add FUSE_IOCTL_32BIT flag\n   76   *\n   77   * 7.17\n   ..\n   79   *\n   80   * 7.18\n   81:  *  - add FUSE_IOCTL_DIR flag\n   82   *  - add FUSE_NOTIFY_DELETE\n   83   *\n   ..\n  211   * FUSE_SPLICE_READ: kernel supports splice read on the device\n  212   * FUSE_FLOCK_LOCKS: remote locking for BSD style file locks\n  213:  * FUSE_HAS_IOCTL_DIR: kernel supports ioctl on directories\n  214   * FUSE_AUTO_INVAL_DATA: automatically invalidate cached pages\n  215   * FUSE_DO_READDIRPLUS: do READDIRPLUS (READDIR+LOOKUP in one)\n  ...\n  228  #define FUSE_SPLICE_READ	(1 << 9)\n  229  #define FUSE_FLOCK_LOCKS	(1 << 10)\n  230: #define FUSE_HAS_IOCTL_DIR	(1 << 11)\n  231  #define FUSE_AUTO_INVAL_DATA	(1 << 12)\n  232  #define FUSE_DO_READDIRPLUS	(1 << 13)\n  ...\n  237   * CUSE INIT request/reply flags\n  238   *\n  239:  * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl\n  240   */\n  241: #define CUSE_UNRESTRICTED_IOCTL	(1 << 0)\n  242  \n  243  /**\n  ...\n  272  \n  273  /**\n  274:  * Ioctl flags\n  275   *\n  276:  * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine\n  277:  * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed\n  278:  * FUSE_IOCTL_RETRY: retry with new iovecs\n  279:  * FUSE_IOCTL_32BIT: 32bit ioctl\n  280:  * FUSE_IOCTL_DIR: is a directory\n  281   *\n  282:  * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs\n  283   */\n  284: #define FUSE_IOCTL_COMPAT	(1 << 0)\n  285: #define FUSE_IOCTL_UNRESTRICTED	(1 << 1)\n  286: #define FUSE_IOCTL_RETRY	(1 << 2)\n  287: #define FUSE_IOCTL_32BIT	(1 << 3)\n  288: #define FUSE_IOCTL_DIR		(1 << 4)\n  289  \n  290: #define FUSE_IOCTL_MAX_IOV	256\n  291  \n  292  /**\n  ...\n  334  	FUSE_BMAP          = 37,\n  335  	FUSE_DESTROY       = 38,\n  336: 	FUSE_IOCTL         = 39,\n  337  	FUSE_POLL          = 40,\n  338  	FUSE_NOTIFY_REPLY  = 41,\n  ...\n  596  };\n  597  \n  598: struct fuse_ioctl_in {\n  599  	uint64_t	fh;\n  600  	uint32_t	flags;\n  ...\n  605  };\n  606  \n  607: struct fuse_ioctl_iovec {\n  608  	uint64_t	base;\n  609  	uint64_t	len;\n  610  };\n  611  \n  612: struct fuse_ioctl_out {\n  613  	int32_t		result;\n  614  	uint32_t	flags;\n\n/usr/include/linux/gigaset_dev.h:\n   15  #define GIGASET_INTERFACE_H\n   16  \n   17: #include <linux/ioctl.h>\n   18  \n   19: /* The magic IOCTL value for this interface. */\n   20: #define GIGASET_IOCTL 0x47\n   21  \n   22  /* enable/disable device control via character device (lock out ISDN subsys) */\n   23: #define GIGASET_REDIR    _IOWR(GIGASET_IOCTL, 0, int)\n   24  \n   25  /* enable adapter configuration mode (M10x only) */\n   26: #define GIGASET_CONFIG   _IOWR(GIGASET_IOCTL, 1, int)\n   27  \n   28  /* set break characters (M105 only) */\n   29: #define GIGASET_BRKCHARS _IOW(GIGASET_IOCTL, 2, unsigned char[6])\n   30  \n   31  /* get version information selected by arg[0] */\n   32: #define GIGASET_VERSION  _IOWR(GIGASET_IOCTL, 3, unsigned[4])\n   33  /* values for GIGASET_VERSION arg[0] */\n   34  #define GIGVER_DRIVER 0		/* get driver version */\n\n/usr/include/linux/hdlcdrv.h:\n   10  /* -------------------------------------------------------------------- */\n   11  /*\n   12:  * structs for the IOCTL commands\n   13   */\n   14  \n   ..\n   48  };\n   49  \n   50: struct hdlcdrv_ioctl {\n   51  	int cmd;\n   52  	union {\n   ..\n   65  \n   66  /*\n   67:  * ioctl values\n   68   */\n   69  #define HDLCDRVCTL_GETMODEMPAR       0\n\n/usr/include/linux/hdreg.h:\n    5  \n    6  /*\n    7:  * Command Header sizes for IOCTL commands\n    8   */\n    9  \n   ..\n   64  } ide_task_request_t;\n   65  \n   66: typedef struct ide_ioctl_request_s {\n   67  	ide_task_request_t	*task_request;\n   68  	unsigned char		*out_buffer;\n   69  	unsigned char		*in_buffer;\n   70: } ide_ioctl_request_t;\n   71  \n   72  struct hd_drive_cmd_hdr {\n   ..\n  348  #define HDIO_SET_MULTCOUNT	0x0321	/* change IDE blockmode */\n  349  #define HDIO_SET_UNMASKINTR	0x0322	/* permit other irqs during I/O */\n  350: #define HDIO_SET_KEEPSETTINGS	0x0323	/* keep ioctl settings on reset */\n  351  #define HDIO_SET_32BIT		0x0324	/* change io_32bit flags */\n  352  #define HDIO_SET_NOWERR		0x0325	/* change ignore-write-error flag */\n\n/usr/include/linux/hiddev.h:\n  149  \n  150  /*\n  151:  * IOCTLs (0x00 - 0x7f)\n  152   */\n  153  \n  ...\n  187   * rinfo.report_type = HID_REPORT_TYPE_INPUT;\n  188   * rinfo.report_id = HID_REPORT_ID_FIRST;\n  189:  * ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);\n  190   *\n  191   * while (ret >= 0) {\n  ...\n  194   * 		finfo.report_id = rinfo.report_id;\n  195   * 		finfo.field_index = i;\n  196:  * 		ioctl(fd, HIDIOCGFIELDINFO, &finfo);\n  197   * 		for (j = 0; j < finfo.maxusage; j++) {\n  198   * 			uref.report_type = rinfo.report_type;\n  ...\n  200   * 			uref.field_index = i;\n  201   * 			uref.usage_index = j;\n  202:  * 			ioctl(fd, HIDIOCGUCODE, &uref);\n  203:  * 			ioctl(fd, HIDIOCGUSAGE, &uref);\n  204   * 		}\n  205   * 	}\n  206   * 	rinfo.report_id |= HID_REPORT_ID_NEXT;\n  207:  * 	ret = ioctl(fd, HIDIOCGREPORTINFO, &rinfo);\n  208   * }\n  209   */\n\n/usr/include/linux/hidraw.h:\n   30  };\n   31  \n   32: /* ioctl interface */\n   33  #define HIDIOCGRDESCSIZE	_IOR('H', 0x01, int)\n   34  #define HIDIOCGRDESC		_IOR('H', 0x02, struct hidraw_report_descriptor)\n\n/usr/include/linux/hysdn_if.h:\n    2   *\n    3   * Linux driver for HYSDN cards\n    4:  * ioctl definitions shared by hynetmgr and driver.\n    5   *\n    6   * Author    Werner Cornelius (werner@titro.de) for Hypercope GmbH\n\n/usr/include/linux/i2c-dev.h:\n   27  \n   28  \n   29: /* /dev/i2c-X ioctl commands.  The ioctl's parameter is always an\n   30   * unsigned long, except for:\n   31   *	- I2C_FUNCS, takes pointer to an unsigned long\n   32:  *	- I2C_RDWR, takes pointer to struct i2c_rdwr_ioctl_data\n   33:  *	- I2C_SMBUS, takes pointer to struct i2c_smbus_ioctl_data\n   34   */\n   35  #define I2C_RETRIES	0x0701	/* number of times a device address should\n   ..\n   53  \n   54  \n   55: /* This is the structure as used in the I2C_SMBUS ioctl call */\n   56: struct i2c_smbus_ioctl_data {\n   57  	__u8 read_write;\n   58  	__u8 command;\n   ..\n   61  };\n   62  \n   63: /* This is the structure as used in the I2C_RDWR ioctl call */\n   64: struct i2c_rdwr_ioctl_data {\n   65  	struct i2c_msg *msgs;	/* pointers to i2c_msgs */\n   66  	__u32 nmsgs;			/* number of i2c_msgs */\n   67  };\n   68  \n   69: #define  I2C_RDRW_IOCTL_MAX_MSGS	42\n   70  \n   71  \n\n/usr/include/linux/i2o-dev.h:\n   24  #define MAX_I2O_CONTROLLERS	32\n   25  \n   26: #include <linux/ioctl.h>\n   27  #include <linux/types.h>\n   28  \n   29  /*\n   30:  * I2O Control IOCTLs and structures\n   31   */\n   32  #define I2O_MAGIC_NUMBER	'i'\n\n/usr/include/linux/if.h:\n   26  #define	IFNAMSIZ	16\n   27  #define	IFALIASZ	256\n   28: #include <linux/hdlc/ioctl.h>\n   29  \n   30  /* Standard interface flags (netdevice->flags). */\n   ..\n  170  /*\n  171   * Interface request structure used for socket\n  172:  * ioctl's.  All interface ioctl's must have parameter\n  173   * definitions which begin with ifr_name.  The\n  174   * remainder may be interface specific.\n\n/usr/include/linux/if_arp.h:\n  109  \n  110  \n  111: /* ARP ioctl request. */\n  112  struct arpreq {\n  113    struct sockaddr	arp_pa;		/* protocol address		*/\n\n/usr/include/linux/if_bonding.h:\n   52  \n   53  /*\n   54:  * We can remove these ioctl definitions in 2.5.  People should use the\n   55   * SIOC*** versions of them instead\n   56   */\n   ..\n  102  \n  103  typedef struct ifslave {\n  104: 	__s32 slave_id; /* Used as an IN param to the BOND_SLAVE_INFO_QUERY ioctl */\n  105  	char slave_name[IFNAMSIZ];\n  106  	__s8 link;\n\n/usr/include/linux/if_frad.h:\n   74  #define FRAD_SET_CONF	(SIOCDEVPRIVATE + 1)\n   75  \n   76: #define FRAD_LAST_IOCTL	FRAD_SET_CONF\n   77  \n   78  /*\n\n/usr/include/linux/if_ppp.h:\n    1: #include <linux/ppp-ioctl.h>\n    2  \n\n/usr/include/linux/if_pppox.h:\n  102  /*********************************************************************\n  103   *\n  104:  * ioctl interface for defining forwarding of connections\n  105   *\n  106   ********************************************************************/\n\n/usr/include/linux/if_slip.h:\n   17  \n   18  /*\n   19:  *	VSV = ioctl for keepalive & outfill in SLIP driver \n   20   */\n   21   \n\n/usr/include/linux/if_tun.h:\n   38  #define TUN_TAP_MQ      0x0400\n   39  \n   40: /* Ioctl defines */\n   41  #define TUNSETNOCSUM  _IOW('T', 200, int) \n   42  #define TUNSETDEBUG   _IOW('T', 201, int) \n   ..\n   93  \n   94  /*\n   95:  * Filter spec (used for SETXXFILTER ioctls)\n   96   * This stuff is applicable only to the TAP (Ethernet) devices.\n   97   * If the count is zero the filter is disabled and the driver accepts\n\n/usr/include/linux/if_vlan.h:\n   15  \n   16  \n   17: /* VLAN IOCTLs are found in sockios.h */\n   18  \n   19: /* Passed in vlan_ioctl_args structure to determine behaviour. */\n   20: enum vlan_ioctl_cmds {\n   21  	ADD_VLAN_CMD,\n   22  	DEL_VLAN_CMD,\n   ..\n   46  };\n   47  \n   48: struct vlan_ioctl_args {\n   49: 	int cmd; /* Should be one of the vlan_ioctl_cmds enum above. */\n   50  	char device1[24];\n   51  \n\n/usr/include/linux/input.h:\n   11  \n   12  #include <sys/time.h>\n   13: #include <sys/ioctl.h>\n   14  #include <sys/types.h>\n   15  #include <linux/types.h>\n   ..\n   34  \n   35  /*\n   36:  * IOCTLs (0x00 - 0x7f)\n   37   */\n   38  \n   ..\n   45  \n   46  /**\n   47:  * struct input_absinfo - used by EVIOCGABS/EVIOCSABS ioctls\n   48   * @value: latest reported value for the axis.\n   49   * @minimum: specifies minimum value for the axis.\n   ..\n   73  \n   74  /**\n   75:  * struct input_keymap_entry - used by EVIOCGKEYCODE/EVIOCSKEYCODE ioctls\n   76   * @scancode: scancode represented in machine-endian form.\n   77   * @len: length of the scancode that resides in @scancode buffer.\n   ..\n  115   * @len: size of the data buffer in bytes\n  116   *\n  117:  * The ioctl buffer argument should be binary equivalent to\n  118   *\n  119   * struct input_mt_request_layout {\n  ...\n  124   * where num_slots is the (arbitrary) number of MT slots to extract.\n  125   *\n  126:  * The ioctl size argument (len) is the size of the buffer, which\n  127   * should satisfy len = (num_slots + 1) * sizeof(__s32).  If len is\n  128   * too small to fit all available slots, the first num_slots are\n  ...\n  958  \n  959  /*\n  960:  * Structures used in ioctls to upload effects to a device\n  961   * They are pieces of a bigger structure (called ff_effect)\n  962   */\n  ...\n 1105   *	defining effect parameters\n 1106   *\n 1107:  * This structure is sent through ioctl from the application to the driver.\n 1108   * To create a new effect application should set its @id to -1; the kernel\n 1109   * will return assigned @id which can later be used to update or delete\n\n/usr/include/linux/ioctl.h:\n    1: #ifndef _LINUX_IOCTL_H\n    2: #define _LINUX_IOCTL_H\n    3  \n    4: #include <asm/ioctl.h>\n    5  \n    6: #endif /* _LINUX_IOCTL_H */\n    7  \n    8  \n\n/usr/include/linux/ipmi.h:\n  176   * Receive types for messages coming from the receive interface.  This\n  177   * is used for the receive in-kernel interface and in the receive\n  178:  * IOCTL.\n  179   *\n  180   * The \"IPMI_RESPONSE_RESPNOSE_TYPE\" is a little strange sounding, but\n  ...\n  198  \n  199  /*\n  200:  * Modes for ipmi_set_maint_mode() and the userland IOCTL.  The AUTO\n  201   * setting is the default and means it will be set on certain\n  202   * commands.  Hard setting it on and off will override automatic\n  ...\n  219   *\n  220   * The read and write calls do not work, to get messages in and out\n  221:  * requires ioctl calls because of the complexity of the data.  select\n  222   * and poll do work, so you can wait for input using the file\n  223   * descriptor, you just can use read to get it.\n  ...\n  245  \n  246  \n  247: /* The magic IOCTL value for this interface. */\n  248  #define IPMI_IOC_MAGIC 'i'\n  249  \n\n/usr/include/linux/irda.h:\n  161  };\n  162  \n  163: /* Some private IOCTL's (max 16) */\n  164  #define SIOCSDONGLE    (SIOCDEVPRIVATE + 0)\n  165  #define SIOCGDONGLE    (SIOCDEVPRIVATE + 1)\n\n/usr/include/linux/isdn.h:\n   15  #define __ISDN_H__\n   16  \n   17: #include <linux/ioctl.h>\n   18  #include <linux/tty.h>\n   19  \n   ..\n   21  #define ISDN_MAX_CHANNELS   64\n   22  \n   23: /* New ioctl-codes */\n   24  #define IIOCNETAIF  _IO('I',1)\n   25  #define IIOCNETDIF  _IO('I',2)\n   ..\n   44  #define IIOCGETCPS  _IO('I',21)\n   45  #define IIOCGETDVR  _IO('I',22)\n   46: #define IIOCNETLCR  _IO('I',23) /* dwabc ioctl for LCR from isdnlog */\n   47: #define IIOCNETDWRSET  _IO('I',24) /* dwabc ioctl to reset abc-values to default on a net-interface */\n   48  \n   49  #define IIOCNETALN  _IO('I',32)\n   ..\n   56  #define IIOCDRVCTL  _IO('I',128)\n   57  \n   58: /* cisco hdlck device private ioctls */\n   59  #define SIOCGKEEPPERIOD	(SIOCDEVPRIVATE + 0)\n   60  #define SIOCSKEEPPERIOD	(SIOCDEVPRIVATE + 1)\n   ..\n   90  \n   91  #define ISDN_MSNLEN          32\n   92: #define NET_DV 0x06  /* Data version for isdn_net_ioctl_cfg   */\n   93  #define TTY_DV 0x06  /* Data version for iprofd etc.          */\n   94  \n   ..\n   98    char drvid[25];\n   99    unsigned long arg;\n  100: } isdn_ioctl_struct;\n  101  \n  102  typedef struct {\n  ...\n  104    char phone[ISDN_MSNLEN];\n  105    int  outgoing;\n  106: } isdn_net_ioctl_phone;\n  107  \n  108  typedef struct {\n  ...\n  132    int  dialwait;     /* Time to wait after failed dial        */\n  133    int  dialmode;     /* Flag: off / on / auto                 */\n  134: } isdn_net_ioctl_cfg;\n  135  \n  136  #define ISDN_NET_DIALMODE_MASK  0xC0    /* bits for status                */\n\n/usr/include/linux/ixjuser.h:\n   48  /******************************************************************************\n   49  *\n   50: * IOCTL's used for the Quicknet Telephony Cards\n   51  *\n   52  * If you use the IXJCTL_TESTRAM command, the card must be power cycled to\n   ..\n   74  /******************************************************************************\n   75  *\n   76: * This group of IOCTLs deal with the record settings of the DSP\n   77  *\n   78  * The IXJCTL_REC_DEPTH command sets the internal buffer depth of the DSP.\n   ..\n  145  /******************************************************************************\n  146  *\n  147: * This IOCTL allows you to reassign values in the tone index table.  The\n  148  * tone table has 32 entries (0 - 31), but the driver only allows entries\n  149  * 13 - 27 to be modified, entry 0 is reserved for silence and 1 - 12 are\n  ...\n  302  /******************************************************************************\n  303  *\n  304: * The IXJCTL_TONE_CADENCE ioctl defines tone sequences used for various\n  305  * Call Progress Tones (CPT).  This is accomplished by setting up an array of\n  306  * IXJ_CADENCE_ELEMENT structures that sequentially define the states of\n  ...\n  355  /******************************************************************************\n  356  *\n  357: * This group of IOCTLs deal with the playback settings of the DSP\n  358  *\n  359  ******************************************************************************/\n  ...\n  368  /******************************************************************************\n  369  *\n  370: * This group of IOCTLs deal with the Acoustic Echo Cancellation settings\n  371  * of the DSP\n  372  *\n  ...\n  391  * only.  If you pass a 1, DTMF is suppressed from the audio stream.\n  392  * Tone on and off times are in 250 microsecond intervals so\n  393: * ioctl(ixj1, IXJCTL_SET_TONE_ON_TIME, 360);\n  394  * will set the tone on time of board ixj1 to 360 * 250us = 90ms\n  395  * the default values of tone on and off times is 840 or 210ms\n  ...\n  413  \n  414  /******************************************************************************\n  415: * LineJACK specific IOCTLs\n  416  *\n  417  * The lsb 4 bits of the LED argument represent the state of each of the 4\n  ...\n  551  * \n  552  * Use IXJCTL_PORT to set or query the port the card is set to.  If the\n  553: * argument is set to PORT_QUERY, the return value of the ioctl will\n  554  * indicate which port is currently in use, otherwise it will change the\n  555  * port.\n  ...\n  597  /******************************************************************************\n  598  * \n  599: * The wink duration is tunable with this ioctl.  The default wink duration  \n  600: * is 320ms.  You do not need to use this ioctl if you do not require a\n  601  * different wink duration.\n  602  * \n  ...\n  606  /******************************************************************************\n  607  * \n  608: * This ioctl will connect the POTS port to the PSTN port on the LineJACK\n  609  * In order for this to work properly the port selection should be set to\n  610: * the PSTN port with IXJCTL_PORT prior to calling this ioctl.  This will\n  611  * enable conference calls between PSTN callers and network callers.\n  612: * Passing a 1 to this ioctl enables the POTS<->PSTN connection while\n  613  * passing a 0 turns it back off.\n  614  * \n  ...\n  618  /******************************************************************************\n  619  *\n  620: * IOCTLs added by request.\n  621  *\n  622  * IXJCTL_HZ sets the value your Linux kernel uses for HZ as defined in\n  ...\n  625  *           must be rebuilt if you change this value, also all modules you\n  626  *           use (except this one) must be recompiled.  The default value\n  627: *           is 100, and you only need to use this IOCTL if you use some\n  628  *           other value.\n  629  *\n  ...\n  649  /******************************************************************************\n  650  *\n  651: * This ioctl allows the user application to control what events the driver\n  652  * will send signals for, and what signals it will send for which event.\n  653  * By default, if signaling is enabled, all events will send SIGIO when\n  ...\n  677  /******************************************************************************\n  678  *\n  679: * These ioctls allow the user application to change the gain in the \n  680  * Smart Cable of the Internet Phone Card.  Sending -1 as a value will cause\n  681  * return value to be the current setting.  Valid values to set are 0x00 - 0x1F\n  ...\n  694  /******************************************************************************\n  695  *\n  696: * The intercom IOCTL's short the output from one card to the input of the\n  697  * other and vice versa (actually done in the DSP read function).  It is only\n  698: * necessary to execute the IOCTL on one card, but it is necessary to have\n  699  * both devices open to be able to detect hook switch changes.  The record\n  700  * codec and rate of each card must match the playback codec and rate of\n\n/usr/include/linux/joystick.h:\n   53  \n   54  /*\n   55:  * IOCTL commands for joystick driver\n   56   */\n   57  \n\n/usr/include/linux/kernelcapi.h:\n   29  } kcapi_carddef;\n   30  \n   31: /* new ioctls >= 10 */\n   32  #define KCAPI_CMD_TRACE		10\n   33  #define KCAPI_CMD_ADDCARD	11	/* OBSOLETE */\n\n/usr/include/linux/kvm.h:\n   10  #include <linux/types.h>\n   11  \n   12: #include <linux/ioctl.h>\n   13  #include <asm/kvm.h>\n   14  \n   ..\n  534  \n  535  /*\n  536:  * ioctls for /dev/kvm fds:\n  537   */\n  538  #define KVM_GET_API_VERSION       _IO(KVMIO,   0x00)\n  ...\n  866  \n  867  /*\n  868:  * ioctls for VM fds\n  869   */\n  870  #define KVM_SET_MEMORY_REGION     _IOW(KVMIO,  0x40, struct kvm_memory_region)\n  ...\n  955  #define KVM_PPC_RTAS_DEFINE_TOKEN _IOW(KVMIO,  0xac, struct kvm_rtas_token_args)\n  956  \n  957: /* ioctl for vm fd */\n  958  #define KVM_CREATE_DEVICE	  _IOWR(KVMIO,  0xe0, struct kvm_create_device)\n  959  \n  960: /* ioctls for fds returned by KVM_CREATE_DEVICE */\n  961  #define KVM_SET_DEVICE_ATTR	  _IOW(KVMIO,  0xe1, struct kvm_device_attr)\n  962  #define KVM_GET_DEVICE_ATTR	  _IOW(KVMIO,  0xe2, struct kvm_device_attr)\n  ...\n  964  \n  965  /*\n  966:  * ioctls for vcpu fds\n  967   */\n  968  #define KVM_RUN                   _IO(KVMIO,   0x80)\n\n/usr/include/linux/loop.h:\n   29  /* Backwards compatibility version */\n   30  struct loop_info {\n   31: 	int		   lo_number;		/* ioctl r/o */\n   32: 	__kernel_old_dev_t lo_device; 		/* ioctl r/o */\n   33: 	unsigned long	   lo_inode; 		/* ioctl r/o */\n   34: 	__kernel_old_dev_t lo_rdevice; 		/* ioctl r/o */\n   35  	int		   lo_offset;\n   36  	int		   lo_encrypt_type;\n   37: 	int		   lo_encrypt_key_size; 	/* ioctl w/o */\n   38: 	int		   lo_flags;			/* ioctl r/o */\n   39  	char		   lo_name[LO_NAME_SIZE];\n   40: 	unsigned char	   lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */\n   41  	unsigned long	   lo_init[2];\n   42  	char		   reserved[4];\n   ..\n   44  \n   45  struct loop_info64 {\n   46: 	__u64		   lo_device;			/* ioctl r/o */\n   47: 	__u64		   lo_inode;			/* ioctl r/o */\n   48: 	__u64		   lo_rdevice;			/* ioctl r/o */\n   49  	__u64		   lo_offset;\n   50  	__u64		   lo_sizelimit;/* bytes, 0 == max available */\n   51: 	__u32		   lo_number;			/* ioctl r/o */\n   52  	__u32		   lo_encrypt_type;\n   53: 	__u32		   lo_encrypt_key_size;		/* ioctl w/o */\n   54: 	__u32		   lo_flags;			/* ioctl r/o */\n   55  	__u8		   lo_file_name[LO_NAME_SIZE];\n   56  	__u8		   lo_crypt_name[LO_NAME_SIZE];\n   57: 	__u8		   lo_encrypt_key[LO_KEY_SIZE]; /* ioctl w/o */\n   58  	__u64		   lo_init[2];\n   59  };\n   ..\n   76  \n   77  /*\n   78:  * IOCTL commands --- we will commandeer 0x4C ('L')\n   79   */\n   80  \n\n/usr/include/linux/lp.h:\n   67  #define LP_INIT_TIME 2\n   68  \n   69: /* IOCTL numbers */\n   70  #define LPCHAR   0x0601  /* corresponds to LP_INIT_CHAR */\n   71  #define LPTIME   0x0602  /* corresponds to LP_INIT_TIME */\n\n/usr/include/linux/matroxfb.h:\n    2  #define __LINUX_MATROXFB_H__\n    3  \n    4: #include <asm/ioctl.h>\n    5  #include <linux/types.h>\n    6  #include <linux/videodev2.h>\n\n/usr/include/linux/mdio.h:\n  282  #define MDIO_PMA_LASI_RXALARM		0x0004	/* RX_ALARM enable/status */\n  283  \n  284: /* Mapping between MDIO PRTAD/DEVAD and mii_ioctl_data::phy_id */\n  285  \n  286  #define MDIO_PHY_ID_C45			0x8000\n\n/usr/include/linux/media.h:\n   24  #define __LINUX_MEDIA_H\n   25  \n   26: #include <linux/ioctl.h>\n   27  #include <linux/types.h>\n   28  #include <linux/version.h>\n\n/usr/include/linux/mei.h:\n   71  \n   72  /*\n   73:  * This IOCTL is used to associate the current file descriptor with a\n   74   * FW Client (given by UUID). This opens a communication channel\n   75   * between a host client and a FW client. From this point every read and write\n   ..\n   78   * the clients is disconnected\n   79   *\n   80:  * The IOCTL argument is a struct with a union that contains\n   81:  * the input parameter and the output parameter for this IOCTL.\n   82   *\n   83   * The input parameter is UUID of the FW Client.\n   ..\n   86   *\n   87   */\n   88: #define IOCTL_MEI_CONNECT_CLIENT \\\n   89  	_IOWR('H' , 0x01, struct mei_connect_client_data)\n   90  \n   ..\n   99  \n  100  /*\n  101:  * IOCTL Connect Client Data structure\n  102   */\n  103  struct mei_connect_client_data {\n\n/usr/include/linux/mic_ioctl.h:\n   19   *\n   20   */\n   21: #ifndef _MIC_IOCTL_H_\n   22: #define _MIC_IOCTL_H_\n   23  \n   24  #include <linux/types.h>\n\n/usr/include/linux/mii.h:\n  151  #define MII_MMD_CTRL_INCR_ON_WT	0xC000	/* post increment on writes only */\n  152  \n  153: /* This structure is used in all SIOCxMIIxxx ioctl calls */\n  154: struct mii_ioctl_data {\n  155  	__u16		phy_id;\n  156  	__u16		reg_num;\n\n/usr/include/linux/mmtimer.h:\n   11   * Timers Draft Specification (rev. 0.97) from Intel.  Note that some\n   12   * hardware may not be able to safely export its registers to userspace,\n   13:  * so the ioctl interface should support all necessary functionality.\n   14   *\n   15   * 11/01/01 - jbarnes - initial revision\n   ..\n   22  \n   23  /*\n   24:  * Breakdown of the ioctl's available.  An 'optional' next to the command\n   25   * indicates that supporting this command is optional, while 'required'\n   26   * commands must be implemented if conformance is desired.\n   ..\n   45   *   Gets the current value in the counter\n   46   */\n   47: #define MMTIMER_IOCTL_BASE 'm'\n   48  \n   49: #define MMTIMER_GETOFFSET _IO(MMTIMER_IOCTL_BASE, 0)\n   50: #define MMTIMER_GETRES _IOR(MMTIMER_IOCTL_BASE, 1, unsigned long)\n   51: #define MMTIMER_GETFREQ _IOR(MMTIMER_IOCTL_BASE, 2, unsigned long)\n   52: #define MMTIMER_GETBITS _IO(MMTIMER_IOCTL_BASE, 4)\n   53: #define MMTIMER_MMAPAVAIL _IO(MMTIMER_IOCTL_BASE, 6)\n   54: #define MMTIMER_GETCOUNTER _IOR(MMTIMER_IOCTL_BASE, 9, unsigned long)\n   55  \n   56  #endif /* _LINUX_MMTIMER_H */\n\n/usr/include/linux/msdos_fs.h:\n   98  \n   99  /*\n  100:  * ioctl commands\n  101   */\n  102: #define VFAT_IOCTL_READDIR_BOTH		_IOR('r', 1, struct __fat_dirent[2])\n  103: #define VFAT_IOCTL_READDIR_SHORT	_IOR('r', 2, struct __fat_dirent[2])\n  104  /* <linux/videotext.h> has used 0x72 ('r') in collision, so skip a few */\n  105: #define FAT_IOCTL_GET_ATTRIBUTES	_IOR('r', 0x10, __u32)\n  106: #define FAT_IOCTL_SET_ATTRIBUTES	_IOW('r', 0x11, __u32)\n  107  /*Android kernel has used 0x12, so we use 0x13*/\n  108: #define FAT_IOCTL_GET_VOLUME_ID		_IOR('r', 0x13, __u32)\n  109  \n  110  struct fat_boot_sector {\n\n/usr/include/linux/mtio.h:\n    2   * linux/mtio.h header file for Linux. Written by H. Bergman\n    3   *\n    4:  * Modified for special ioctls provided by zftape in September 1997\n    5   * by C.-J. Heine.\n    6   */\n    .\n   10  \n   11  #include <linux/types.h>\n   12: #include <linux/ioctl.h>\n   13  \n   14  /*\n   ..\n  167  #define MT_ST_SOFTERR_MASK	0xffff\n  168  \n  169: /* Bitfields for the MTSETDRVBUFFER ioctl */\n  170  #define MT_ST_OPTIONS		0xf0000000\n  171  #define MT_ST_BOOLEANS		0x10000000\n\n/usr/include/linux/n_r3964.h:\n   37   *\n   38   * Revision 1.2  1998/02/07 13:03:17  root\n   39:  * ioctl read_telegram\n   40   *\n   41   * Revision 1.1  1998/02/06 19:19:43  root\n   ..\n   52  \n   53  /*\n   54:  * Ioctl-commands\n   55   */\n   56  \n\n/usr/include/linux/ncp_fs.h:\n   18  \n   19  /*\n   20:  * ioctl commands\n   21   */\n   22  \n   23: struct ncp_ioctl_request {\n   24  	unsigned int function;\n   25  	unsigned int size;\n   ..\n   59  };\n   60  \n   61: struct ncp_lock_ioctl\n   62  {\n   63  #define NCP_LOCK_LOG	0\n   ..\n   74  };\n   75  \n   76: struct ncp_setroot_ioctl\n   77  {\n   78  	int		volNumber;\n   ..\n   81  };\n   82  \n   83: struct ncp_objectname_ioctl\n   84  {\n   85  #define NCP_AUTH_NONE	0x00\n   ..\n   91  };\n   92  \n   93: struct ncp_privatedata_ioctl\n   94  {\n   95  	size_t		len;\n   ..\n   97  };\n   98  \n   99: /* NLS charsets by ioctl */\n  100  #define NCP_IOCSNAME_LEN 20\n  101: struct ncp_nls_ioctl\n  102  {\n  103  	unsigned char codepage[NCP_IOCSNAME_LEN+1];\n  ...\n  105  };\n  106  \n  107: #define	NCP_IOC_NCPREQUEST		_IOR('n', 1, struct ncp_ioctl_request)\n  108  #define	NCP_IOC_GETMOUNTUID		_IOW('n', 2, __kernel_old_uid_t)\n  109  #define NCP_IOC_GETMOUNTUID2		_IOW('n', 2, unsigned long)\n  ...\n  120  #define NCP_IOC_SET_SIGN_WANTED		_IOW('n', 6, int)\n  121  \n  122: #define NCP_IOC_LOCKUNLOCK		_IOR('n', 7, struct ncp_lock_ioctl)\n  123  \n  124: #define NCP_IOC_GETROOT			_IOW('n', 8, struct ncp_setroot_ioctl)\n  125: #define NCP_IOC_SETROOT			_IOR('n', 8, struct ncp_setroot_ioctl)\n  126  \n  127: #define NCP_IOC_GETOBJECTNAME		_IOWR('n', 9, struct ncp_objectname_ioctl)\n  128: #define NCP_IOC_SETOBJECTNAME		_IOR('n', 9, struct ncp_objectname_ioctl)\n  129: #define NCP_IOC_GETPRIVATEDATA		_IOWR('n', 10, struct ncp_privatedata_ioctl)\n  130: #define NCP_IOC_SETPRIVATEDATA		_IOR('n', 10, struct ncp_privatedata_ioctl)\n  131  \n  132: #define NCP_IOC_GETCHARSETS		_IOWR('n', 11, struct ncp_nls_ioctl)\n  133: #define NCP_IOC_SETCHARSETS		_IOR('n', 11, struct ncp_nls_ioctl)\n  134  \n  135  #define NCP_IOC_GETDENTRYTTL		_IOW('n', 12, __u32)\n\n/usr/include/linux/nvme.h:\n  482  };\n  483  \n  484: #define NVME_IOCTL_ID		_IO('N', 0x40)\n  485: #define NVME_IOCTL_ADMIN_CMD	_IOWR('N', 0x41, struct nvme_admin_cmd)\n  486: #define NVME_IOCTL_SUBMIT_IO	_IOW('N', 0x42, struct nvme_user_io)\n  487  \n  488  #endif /* _LINUX_NVME_H */\n\n/usr/include/linux/nvram.h:\n    2  #define _LINUX_NVRAM_H\n    3  \n    4: #include <linux/ioctl.h>\n    5  \n    6: /* /dev/nvram ioctls */\n    7  #define NVRAM_INIT	_IO('p', 0x40) /* initialize NVRAM and set checksum */\n    8  #define NVRAM_SETCKS	_IO('p', 0x41) /* recalculate checksum */\n\n/usr/include/linux/omap3isp.h:\n   32  \n   33  /*\n   34:  * Private IOCTLs\n   35   *\n   36   * VIDIOC_OMAP3ISP_CCDC_CFG: Set CCDC configuration\n\n/usr/include/linux/omapfb.h:\n   26  \n   27  #include <linux/fb.h>\n   28: #include <linux/ioctl.h>\n   29  #include <linux/types.h>\n   30  \n   31: /* IOCTL commands. */\n   32  \n   33  #define OMAP_IOW(num, dtype)	_IOW('O', num, dtype)\n\n/usr/include/linux/pci.h:\n   32  #define PCI_FUNC(devfn)		((devfn) & 0x07)\n   33  \n   34: /* Ioctls for /proc/bus/pci/X/Y nodes. */\n   35  #define PCIIOC_BASE		('P' << 24 | 'C' << 16 | 'I' << 8)\n   36  #define PCIIOC_CONTROLLER	(PCIIOC_BASE | 0x00)	/* Get controller for PCI device. */\n\n/usr/include/linux/perf_event.h:\n   16  \n   17  #include <linux/types.h>\n   18: #include <linux/ioctl.h>\n   19  #include <asm/byteorder.h>\n   20  \n   ..\n  339  \n  340  /*\n  341:  * Ioctls that can be done on a perf event fd:\n  342   */\n  343  #define PERF_EVENT_IOC_ENABLE		_IO ('$', 0)\n\n/usr/include/linux/pg.h:\n   23          and in this case, no following read is expected, or permitted.\n   24  \n   25: 	There are no ioctl() operations.  Any single operation\n   26  	may transfer at most PG_MAX_DATA bytes.  Note that the driver must\n   27          copy the data through an internal buffer.  In keeping with all\n\n/usr/include/linux/phantom.h:\n   31  #define PHN_GET_REGS		_IOWR(PH_IOC_MAGIC, 2, struct phm_regs *)\n   32  #define PHN_SET_REGS		_IOW(PH_IOC_MAGIC, 3, struct phm_regs *)\n   33: /* this ioctl tells the driver, that the caller is not OpenHaptics and might\n   34   * use improved registers update (no more phantom switchoffs when using\n   35   * libphantom) */\n\n/usr/include/linux/phonet.h:\n   49  #define PNPIPE_ENCAP_IP		1\n   50  \n   51: /* ioctls */\n   52  #define SIOCPNGETOBJECT		(SIOCPROTOPRIVATE + 0)\n   53  #define SIOCPNENABLEPIPE	(SIOCPROTOPRIVATE + 13)\n   ..\n  181  }\n  182  \n  183: /* Phonet device ioctl requests */\n  184  \n  185  #endif /* LINUX_PHONET_H */\n\n/usr/include/linux/pktcdvd.h:\n  103  \n  104  /*\n  105:  * packet ioctls\n  106   */\n  107: #define PACKET_IOCTL_MAGIC	('X')\n  108: #define PACKET_CTRL_CMD		_IOWR(PACKET_IOCTL_MAGIC, 1, struct pkt_ctrl_command)\n  109  \n  110  \n\n/usr/include/linux/pmu.h:\n  117  	\n  118  /*\n  119:  * Ioctl commands for the /dev/pmu device\n  120   */\n  121: #include <linux/ioctl.h>\n  122  \n  123  /* no param */\n\n/usr/include/linux/ppdev.h:\n   15   */\n   16  \n   17: #define PP_IOCTL	'p'\n   18  \n   19  /* Set mode for read/write (e.g. IEEE1284_MODE_EPP) */\n   20: #define PPSETMODE	_IOW(PP_IOCTL, 0x80, int)\n   21  \n   22  /* Read status */\n   23: #define PPRSTATUS	_IOR(PP_IOCTL, 0x81, unsigned char)\n   24: #define PPWSTATUS	OBSOLETE__IOW(PP_IOCTL, 0x82, unsigned char)\n   25  \n   26  /* Read/write control */\n   27: #define PPRCONTROL	_IOR(PP_IOCTL, 0x83, unsigned char)\n   28: #define PPWCONTROL	_IOW(PP_IOCTL, 0x84, unsigned char)\n   29  \n   30  struct ppdev_frob_struct {\n   ..\n   32  	unsigned char val;\n   33  };\n   34: #define PPFCONTROL      _IOW(PP_IOCTL, 0x8e, struct ppdev_frob_struct)\n   35  \n   36  /* Read/write data */\n   37: #define PPRDATA		_IOR(PP_IOCTL, 0x85, unsigned char)\n   38: #define PPWDATA		_IOW(PP_IOCTL, 0x86, unsigned char)\n   39  \n   40  /* Read/write econtrol (not used) */\n   41: #define PPRECONTROL	OBSOLETE__IOR(PP_IOCTL, 0x87, unsigned char)\n   42: #define PPWECONTROL	OBSOLETE__IOW(PP_IOCTL, 0x88, unsigned char)\n   43  \n   44  /* Read/write FIFO (not used) */\n   45: #define PPRFIFO		OBSOLETE__IOR(PP_IOCTL, 0x89, unsigned char)\n   46: #define PPWFIFO		OBSOLETE__IOW(PP_IOCTL, 0x8a, unsigned char)\n   47  \n   48  /* Claim the port to start using it */\n   49: #define PPCLAIM		_IO(PP_IOCTL, 0x8b)\n   50  \n   51  /* Release the port when you aren't using it */\n   52: #define PPRELEASE	_IO(PP_IOCTL, 0x8c)\n   53  \n   54  /* Yield the port (release it if another driver is waiting,\n   55   * then reclaim) */\n   56: #define PPYIELD		_IO(PP_IOCTL, 0x8d)\n   57  \n   58  /* Register device exclusively (must be before PPCLAIM). */\n   59: #define PPEXCL		_IO(PP_IOCTL, 0x8f)\n   60  \n   61  /* Data line direction: non-zero for input mode. */\n   62: #define PPDATADIR	_IOW(PP_IOCTL, 0x90, int)\n   63  \n   64  /* Negotiate a particular IEEE 1284 mode. */\n   65: #define PPNEGOT		_IOW(PP_IOCTL, 0x91, int)\n   66  \n   67  /* Set control lines when an interrupt occurs. */\n   68: #define PPWCTLONIRQ	_IOW(PP_IOCTL, 0x92, unsigned char)\n   69  \n   70  /* Clear (and return) interrupt count. */\n   71: #define PPCLRIRQ	_IOR(PP_IOCTL, 0x93, int)\n   72  \n   73  /* Set the IEEE 1284 phase that we're in (e.g. IEEE1284_PH_FWD_IDLE) */\n   74: #define PPSETPHASE	_IOW(PP_IOCTL, 0x94, int)\n   75  \n   76  /* Set and get port timeout (struct timeval's) */\n   77: #define PPGETTIME	_IOR(PP_IOCTL, 0x95, struct timeval)\n   78: #define PPSETTIME	_IOW(PP_IOCTL, 0x96, struct timeval)\n   79  \n   80  /* Get available modes (what the hardware can do) */\n   81: #define PPGETMODES	_IOR(PP_IOCTL, 0x97, unsigned int)\n   82  \n   83  /* Get the current mode and phaze */\n   84: #define PPGETMODE	_IOR(PP_IOCTL, 0x98, int)\n   85: #define PPGETPHASE	_IOR(PP_IOCTL, 0x99, int)\n   86  \n   87  /* get/set flags */\n   88: #define PPGETFLAGS	_IOR(PP_IOCTL, 0x9a, int)\n   89: #define PPSETFLAGS	_IOW(PP_IOCTL, 0x9b, int)\n   90  \n   91  /* flags visible to the world */\n\n/usr/include/linux/ppp-ioctl.h:\n    1  /*\n    2:  * ppp-ioctl.h - PPP ioctl definitions.\n    3   *\n    4   * Copyright 1999-2002 Paul Mackerras.\n    .\n    8   *  version 2 as published by the Free Software Foundation.\n    9   */\n   10: #ifndef _PPP_IOCTL_H\n   11: #define _PPP_IOCTL_H\n   12  \n   13  #include <linux/types.h>\n   ..\n   51  \n   52  /* Used with PPPIOCGNPMODE/PPPIOCSNPMODE */\n   53: struct npioctl {\n   54  	int		protocol;	/* PPP protocol, e.g. PPP_IP */\n   55  	enum NPmode	mode;\n   ..\n   79  \n   80  /*\n   81:  * Ioctl definitions.\n   82   */\n   83  \n   ..\n   96  #define PPPIOCXFERUNIT	_IO('t', 78)		/* transfer PPP unit */\n   97  #define PPPIOCSCOMPRESS	_IOW('t', 77, struct ppp_option_data)\n   98: #define PPPIOCGNPMODE	_IOWR('t', 76, struct npioctl) /* get NP mode */\n   99: #define PPPIOCSNPMODE	_IOW('t', 75, struct npioctl)  /* set NP mode */\n  100  #define PPPIOCSPASS	_IOW('t', 71, struct sock_fprog) /* set pass filter */\n  101  #define PPPIOCSACTIVE	_IOW('t', 70, struct sock_fprog) /* set active filt */\n  ...\n  117  #define SIOCGPPPCSTATS  (SIOCDEVPRIVATE + 2)\n  118  \n  119: #endif /* _PPP_IOCTL_H */\n  120  \n\n/usr/include/linux/pps.h:\n  121  };\n  122  \n  123: #include <linux/ioctl.h>\n  124  \n  125  #define PPS_GETPARAMS		_IOR('p', 0xa1, struct pps_kparams *)\n\n/usr/include/linux/ptp_clock.h:\n   22  #define _PTP_CLOCK_H_\n   23  \n   24: #include <linux/ioctl.h>\n   25  #include <linux/types.h>\n   26  \n\n/usr/include/linux/radeonfb.h:\n    2  #define __LINUX_RADEONFB_H__\n    3  \n    4: #include <asm/ioctl.h>\n    5  #include <linux/types.h>\n    6  \n\n/usr/include/linux/random.h:\n    9  \n   10  #include <linux/types.h>\n   11: #include <linux/ioctl.h>\n   12  #include <linux/irqnr.h>\n   13  \n   14: /* ioctl()'s for the random number generator */\n   15  \n   16  /* Get the entropy count. */\n\n/usr/include/linux/reiserfs_fs.h:\n   15   */\n   16  \n   17: /* ioctl's command */\n   18  #define REISERFS_IOC_UNPACK		_IOW(0xCD,1,long)\n   19  /* define following flags to be the same as in ext2, so that chattr(1),\n\n/usr/include/linux/rfkill.h:\n  100  #define RFKILL_EVENT_SIZE_V1	8\n  101  \n  102: /* ioctl for turning off rfkill-input (if present) */\n  103  #define RFKILL_IOC_MAGIC	'R'\n  104  #define RFKILL_IOC_NOINPUT	1\n  105: #define RFKILL_IOCTL_NOINPUT	_IO(RFKILL_IOC_MAGIC, RFKILL_IOC_NOINPUT)\n  106  \n  107  /* and that's all userspace gets */\n\n/usr/include/linux/rtc.h:\n    3   * This version contains the part of the user interface to the Real Time Clock\n    4   * service. It is used with both the legacy mc146818 and also  EFI\n    5:  * Struct rtc_time and first 12 ioctl by Paul Gortmaker, 1996 - separated out\n    6   * from <linux/mc146818rtc.h> to this file for 2.4 kernels.\n    7   *\n    .\n   13  \n   14  /*\n   15:  * The struct used to pass data via the following ioctl. Similar to the\n   16   * struct tm in <time.h>, but it needs to be here so that the kernel\n   17   * source is self contained, allowing cross-compiles, etc. etc.\n   ..\n   64  \n   65  /*\n   66:  * ioctl calls that are permitted to the /dev/rtc interface, if\n   67   * any of the RTC drivers are enabled.\n   68   */\n\n/usr/include/linux/scc.h:\n   14  #define BAYCOM		0x10	/* hardware type for BayCom (U)SCC */\n   15  \n   16: /* DEV ioctl() commands */\n   17  \n   18: enum SCC_ioctl_cmds {\n   19  	SIOCSCCRESERVED = SIOCDEVPRIVATE,\n   20  	SIOCSCCCFG,\n\n/usr/include/linux/sdla.h:\n   47  #define SDLA_CPU_12M			0x06\n   48  \n   49: /* some private IOCTLs */\n   50: #define SDLA_IDENTIFY			(FRAD_LAST_IOCTL + 1)\n   51: #define SDLA_CPUSPEED			(FRAD_LAST_IOCTL + 2)\n   52: #define SDLA_PROTOCOL			(FRAD_LAST_IOCTL + 3)\n   53  \n   54: #define SDLA_CLEARMEM			(FRAD_LAST_IOCTL + 4)\n   55: #define SDLA_WRITEMEM			(FRAD_LAST_IOCTL + 5)\n   56: #define SDLA_READMEM			(FRAD_LAST_IOCTL + 6)\n   57  \n   58  struct sdla_mem {\n   ..\n   62  };\n   63  \n   64: #define SDLA_START			(FRAD_LAST_IOCTL + 7)\n   65: #define SDLA_STOP			(FRAD_LAST_IOCTL + 8)\n   66  \n   67  /* some offsets in the Z80's memory space */\n\n/usr/include/linux/serio.h:\n   10  \n   11  \n   12: #include <linux/ioctl.h>\n   13  \n   14  #define SPIOCSTYPE	_IOW('q', 0x01, unsigned long)\n\n/usr/include/linux/sockios.h:\n   21  #include <asm/sockios.h>\n   22  \n   23: /* Linux-specific socket ioctls */\n   24  #define SIOCINQ		FIONREAD\n   25  #define SIOCOUTQ	TIOCOUTQ        /* output queue size (not sent + not acked) */\n   ..\n  129  #define SIOCGHWTSTAMP	0x89b1		/* get config			*/\n  130  \n  131: /* Device private ioctl calls */\n  132  \n  133  /*\n  134:  *	These 16 ioctls are available to devices via the do_ioctl() device\n  135   *	vector. Each device should include this file and redefine these names\n  136   *	as their own. Because these are device dependent it is a good idea\n  137   *	_NOT_ to issue them to random objects and hope.\n  138   *\n  139:  *	THESE IOCTLS ARE _DEPRECATED_ AND WILL DISAPPEAR IN 2.5.X -DaveM\n  140   */\n  141   \n  ...\n  143  \n  144  /*\n  145:  *	These 16 ioctl calls are protocol private\n  146   */\n  147   \n\n/usr/include/linux/soundcard.h:\n   31   * it's a six digit hexadecimal value. For example value\n   32   * of 0x030600 represents OSS version 3.6.0.\n   33:  * Use ioctl(fd, OSS_GETVERSION, &int) to get the version number of\n   34   * the currently active driver.\n   35   */\n   ..\n   38  \n   39  /* In Linux we need to be prepared for cross compiling */\n   40: #include <linux/ioctl.h>\n   41  \n   42  /* Endian macros. */\n   ..\n   76  \n   77  /***********************************\n   78:  * IOCTL Commands for /dev/sequencer\n   79   */\n   80  \n   81  #ifndef _SIOWR\n   82: #if defined(_IOWR) && (defined(_AIX) || (!defined(sun) && !defined(sparc) && !defined(__sparc__) && !defined(__INCioctlh) && !defined(__Lynx__)))\n   83: /* Use already defined ioctl defines if they exist (except with Sun or Sparc) */\n   84  #define	SIOCPARM_MASK	IOCPARM_MASK\n   85  #define	SIOC_VOID	IOC_VOID\n   ..\n   98  #else\n   99  \n  100: /* Ioctl's have the command encoded in the lower word,\n  101   * and the size of any in or out parameters in the upper\n  102   * word.  The high 2 bits of the upper word are used\n  ...\n  110  #define	SIOC_IN		0x40000000	/* copy in parameters */\n  111  #define	SIOC_INOUT	(SIOC_IN|SIOC_OUT)\n  112: /* the 0x20000000 is so we can distinguish new ioctl's from old */\n  113  #define	_SIO(x,y)	((int)(SIOC_VOID|(x<<8)|y))\n  114  #define	_SIOR(x,y,t)	((int)(SIOC_OUT|((sizeof(t)&SIOCPARM_MASK)<<16)|(x<<8)|y))\n  ...\n  518  \n  519  /********************************************\n  520:  * ioctl commands for the /dev/midi##\n  521   */\n  522  typedef struct {\n  ...\n  531  \n  532  /********************************************\n  533:  * IOCTL commands for /dev/dsp and /dev/audio\n  534   */\n  535  \n  ...\n  687  \n  688  /*\n  689:  * ioctl calls to be used in communication with coprocessors and\n  690   * DSP chips.\n  691   */\n  ...\n  728  \n  729  /*********************************************\n  730:  * IOCTL commands for /dev/mixer\n  731   */\n  732  	\n  ...\n  928  \n  929  /*\n  930:  * Two ioctls for special souncard function\n  931   */\n  932  #define SOUND_MIXER_AGC  _SIOWR('M', 103, int)\n  ...\n  961  \n  962  /* \n  963:  * An ioctl for identifying the driver version. It will return value\n  964   * of the SOUND_VERSION macro used when compiling the driver.\n  965   * This call was introduced in OSS version 3.6 and it will not work\n\n/usr/include/linux/suspend_ioctls.h:\n    1: #ifndef _LINUX_SUSPEND_IOCTLS_H\n    2: #define _LINUX_SUSPEND_IOCTLS_H\n    3  \n    4  #include <linux/types.h>\n    .\n    6   * This structure is used to pass the values needed for the identification\n    7   * of the resume swap area from a user space to the kernel via the\n    8:  * SNAPSHOT_SET_SWAP_AREA ioctl\n    9   */\n   10  struct resume_swap_area {\n   ..\n   31  #define SNAPSHOT_IOC_MAXNR	20\n   32  \n   33: #endif /* _LINUX_SUSPEND_IOCTLS_H */\n   34  \n\n/usr/include/linux/synclink.h:\n  260  #define MgslEvent_IdleReceived	0x0200\n  261  \n  262: /* Private IOCTL codes:\n  263   *\n  264   * MGSL_IOCSPARAMS	set MGSL_PARAMS structure values\n\n/usr/include/linux/telephony.h:\n   61  /******************************************************************************\n   62  *\n   63: * The capabilities ioctls can inform you of the capabilities of each phone\n   64: * device installed in your system.  The PHONECTL_CAPABILITIES ioctl\n   65  * returns an integer value indicating the number of capabilities the   \n   66  * device has.  The PHONECTL_CAPABILITIES_LIST will fill an array of \n   ..\n  159  /******************************************************************************\n  160  * \n  161: * The wink duration is tunable with this ioctl.  The default wink duration  \n  162: * is 320ms.  You do not need to use this ioctl if you do not require a\n  163  * different wink duration.\n  164  * \n\n/usr/include/linux/udf_fs_i.h:\n   13  #define _UDF_FS_I_H 1\n   14  \n   15: /* exported IOCTLs, we have 'l', 0x40-0x7f */\n   16  #define UDF_GETEASIZE   _IOR('l', 0x40, int)\n   17  #define UDF_GETEABLOCK  _IOR('l', 0x41, void *)\n\n/usr/include/linux/uinput.h:\n   52  };\n   53  \n   54: /* ioctl */\n   55: #define UINPUT_IOCTL_BASE	'U'\n   56: #define UI_DEV_CREATE		_IO(UINPUT_IOCTL_BASE, 1)\n   57: #define UI_DEV_DESTROY		_IO(UINPUT_IOCTL_BASE, 2)\n   58  \n   59: #define UI_SET_EVBIT		_IOW(UINPUT_IOCTL_BASE, 100, int)\n   60: #define UI_SET_KEYBIT		_IOW(UINPUT_IOCTL_BASE, 101, int)\n   61: #define UI_SET_RELBIT		_IOW(UINPUT_IOCTL_BASE, 102, int)\n   62: #define UI_SET_ABSBIT		_IOW(UINPUT_IOCTL_BASE, 103, int)\n   63: #define UI_SET_MSCBIT		_IOW(UINPUT_IOCTL_BASE, 104, int)\n   64: #define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)\n   65: #define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)\n   66: #define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)\n   67: #define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)\n   68: #define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)\n   69: #define UI_SET_PROPBIT		_IOW(UINPUT_IOCTL_BASE, 110, int)\n   70  \n   71: #define UI_BEGIN_FF_UPLOAD	_IOWR(UINPUT_IOCTL_BASE, 200, struct uinput_ff_upload)\n   72: #define UI_END_FF_UPLOAD	_IOW(UINPUT_IOCTL_BASE, 201, struct uinput_ff_upload)\n   73: #define UI_BEGIN_FF_ERASE	_IOWR(UINPUT_IOCTL_BASE, 202, struct uinput_ff_erase)\n   74: #define UI_END_FF_ERASE		_IOW(UINPUT_IOCTL_BASE, 203, struct uinput_ff_erase)\n   75  \n   76  /*\n   ..\n   79   * The uinput driver will generate a fake input event when one of\n   80   * these callbacks are invoked. The userspace code then uses\n   81:  * ioctls to retrieve additional parameters and send the return code.\n   82   * The callback blocks until this return code is sent.\n   83   *\n   ..\n   90   *   2. Allocate a uinput_ff_upload struct, fill in request_id with\n   91   *      the 'value' from the EV_UINPUT event.\n   92:  *   3. Issue a UI_BEGIN_FF_UPLOAD ioctl, giving it the\n   93   *      uinput_ff_upload struct. It will be filled in with the\n   94   *      ff_effects passed to upload_effect().\n   95   *   4. Perform the effect upload, and place a return code back into\n   96          the uinput_ff_upload struct.\n   97:  *   5. Issue a UI_END_FF_UPLOAD ioctl, also giving it the\n   98   *      uinput_ff_upload_effect struct. This will complete execution\n   99   *      of our upload_effect() handler.\n  ...\n  104   *   2. Allocate a uinput_ff_erase struct, fill in request_id with\n  105   *      the 'value' from the EV_UINPUT event.\n  106:  *   3. Issue a UI_BEGIN_FF_ERASE ioctl, giving it the\n  107   *      uinput_ff_erase struct. It will be filled in with the\n  108   *      effect ID passed to erase_effect().\n  109   *   4. Perform the effect erasure, and place a return code back\n  110   *      into the uinput_ff_erase struct.\n  111:  *   5. Issue a UI_END_FF_ERASE ioctl, also giving it the\n  112   *      uinput_ff_erase_effect struct. This will complete execution\n  113   *      of our erase_effect() handler.\n\n/usr/include/linux/usbdevice_fs.h:\n   35  /* --------------------------------------------------------------------- */\n   36  \n   37: /* usbdevfs ioctl codes */\n   38  \n   39  struct usbdevfs_ctrltransfer {\n   ..\n  111  };\n  112  \n  113: /* ioctls for talking directly to drivers */\n  114: struct usbdevfs_ioctl {\n  115  	int	ifno;		/* interface 0..N ; negative numbers reserved */\n  116: 	int	ioctl_code;	/* MUST encode size + direction of data so the\n  117: 				 * macros in <asm/ioctl.h> give correct values */\n  118  	void *data;	/* param buffer (in, or out) */\n  119  };\n  ...\n  166  #define USBDEVFS_RELEASEINTERFACE  _IOR('U', 16, unsigned int)\n  167  #define USBDEVFS_CONNECTINFO       _IOW('U', 17, struct usbdevfs_connectinfo)\n  168: #define USBDEVFS_IOCTL             _IOWR('U', 18, struct usbdevfs_ioctl)\n  169: #define USBDEVFS_IOCTL32           _IOWR('U', 18, struct usbdevfs_ioctl32)\n  170  #define USBDEVFS_HUB_PORTINFO      _IOR('U', 19, struct usbdevfs_hub_portinfo)\n  171  #define USBDEVFS_RESET             _IO('U', 20)\n\n/usr/include/linux/uvcvideo.h:\n    2  #define __LINUX_UVCVIDEO_H_\n    3  \n    4: #include <linux/ioctl.h>\n    5  #include <linux/types.h>\n    6  \n\n/usr/include/linux/v4l2-subdev.h:\n   24  #define __LINUX_V4L2_SUBDEV_H\n   25  \n   26: #include <linux/ioctl.h>\n   27  #include <linux/types.h>\n   28  #include <linux/v4l2-common.h>\n\n/usr/include/linux/vfio.h:\n   13  \n   14  #include <linux/types.h>\n   15: #include <linux/ioctl.h>\n   16  \n   17  #define VFIO_API_VERSION	0\n   18  \n   19  \n   20: /* Kernel & User level defines for VFIO IOCTLs. */\n   21  \n   22  /* Extensions */\n   ..\n   26  \n   27  /*\n   28:  * The IOCTL interface is designed for extensibility by embedding the\n   29   * structure length (argsz) and flags into structures passed between\n   30   * kernel and userspace.  We therefore use the _IO() macro for these\n   31:  * defines to avoid implicitly embedding a size into the ioctl request.\n   32   * As structure fields are added, argsz will increase to match and flag\n   33   * bits will be defined to indicate additional fields with valid data.\n   ..\n   39  #define VFIO_BASE	100\n   40  \n   41: /* -------- IOCTLs for VFIO file descriptor (/dev/vfio/vfio) -------- */\n   42  \n   43  /**\n   ..\n   67   * iommu driver as verified by calling CHECK_EXTENSION using the same\n   68   * type.  A group must be set to this file descriptor before this\n   69:  * ioctl is available.  The IOMMU interfaces enabled by this call are\n   70   * specific to the value set.\n   71   * Return: 0 on success, -errno on failure\n   ..\n   74  #define VFIO_SET_IOMMU			_IO(VFIO_TYPE, VFIO_BASE + 2)\n   75  \n   76: /* -------- IOCTLs for GROUP file descriptors (/dev/vfio/$GROUP) -------- */\n   77  \n   78  /**\n   ..\n  134  #define VFIO_GROUP_GET_DEVICE_FD	_IO(VFIO_TYPE, VFIO_BASE + 6)\n  135  \n  136: /* --------------- IOCTLs for DEVICE file descriptors --------------- */\n  137  \n  138  /**\n  ...\n  246   * flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,\n  247   * data = {fd1, -1, fd2}\n  248:  * If index [0,1] is previously set, two count = 1 ioctls calls would be\n  249   * required to set [0,0] and [0,2] without changing [0,1].\n  250   *\n  ...\n  420  \n  421  /*\n  422:  * IOCTLs to enable/disable IOMMU container usage.\n  423   * No parameters are supported.\n  424   */\n  ...\n  434   *\n  435   * The DMA 32 bit window start is an absolute PCI bus address.\n  436:  * The IOVA address passed via map/unmap ioctls are absolute PCI bus\n  437   * addresses too so the window works as a filter rather than an offset\n  438   * for IOVA addresses.\n\n/usr/include/linux/vhost.h:\n   13  #include <linux/types.h>\n   14  \n   15: #include <linux/ioctl.h>\n   16  #include <linux/virtio_config.h>\n   17  #include <linux/virtio_ring.h>\n   ..\n   64  };\n   65  \n   66: /* ioctls */\n   67  \n   68  #define VHOST_VIRTIO 0xAF\n   ..\n  104  #define VHOST_GET_VRING_BASE _IOWR(VHOST_VIRTIO, 0x12, struct vhost_vring_state)\n  105  \n  106: /* The following ioctls use eventfd file descriptors to signal and poll\n  107   * for events. */\n  108  \n  ...\n  134   *\n  135   * ABI Rev 0: July 2012 version starting point for v3.6-rc merge candidate +\n  136:  *            RFC-v2 vhost-scsi userspace.  Add GET_ABI_VERSION ioctl usage\n  137   * ABI Rev 1: January 2013. Ignore vhost_tpgt filed in struct vhost_scsi_target.\n  138   *            All the targets under vhost_wwpn can be seen and used by guset.\n\n/usr/include/linux/videodev2.h:\n   59  #include <sys/time.h>\n   60  \n   61: #include <linux/ioctl.h>\n   62  #include <linux/types.h>\n   63  #include <linux/v4l2-common.h>\n   ..\n  265  #define V4L2_CAP_READWRITE              0x01000000  /* read/write systemcalls */\n  266  #define V4L2_CAP_ASYNCIO                0x02000000  /* async I/O */\n  267: #define V4L2_CAP_STREAMING              0x04000000  /* streaming I/O ioctls */\n  268  \n  269  #define V4L2_CAP_DEVICE_CAPS            0x80000000  /* sets device capabilities field */\n  ...\n 1254  };\n 1255  \n 1256: /*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */\n 1257  struct v4l2_queryctrl {\n 1258  	__u32		     id;\n ....\n 1267  };\n 1268  \n 1269: /*  Used in the VIDIOC_QUERYMENU ioctl for querying menu items */\n 1270  struct v4l2_querymenu {\n 1271  	__u32		id;\n ....\n 1917  /* Experimental, meant for debugging, testing and internal use.\n 1918     Only implemented if CONFIG_VIDEO_ADV_DEBUG is defined.\n 1919:    You must be root to use these ioctls. Never use these in applications! */\n 1920  #define	VIDIOC_DBG_S_REGISTER 	 _IOW('V', 79, struct v4l2_dbg_register)\n 1921  #define	VIDIOC_DBG_G_REGISTER 	_IOWR('V', 80, struct v4l2_dbg_register)\n ....\n 1929  #define	VIDIOC_UNSUBSCRIBE_EVENT _IOW('V', 91, struct v4l2_event_subscription)\n 1930  \n 1931: /* Experimental, the below two ioctls may change over the next couple of kernel\n 1932     versions */\n 1933  #define VIDIOC_CREATE_BUFS	_IOWR('V', 92, struct v4l2_create_buffers)\n ....\n 1938  #define VIDIOC_S_SELECTION	_IOWR('V', 95, struct v4l2_selection)\n 1939  \n 1940: /* Experimental, these two ioctls may change over the next couple of kernel\n 1941     versions. */\n 1942  #define VIDIOC_DECODER_CMD	_IOWR('V', 96, struct v4l2_decoder_cmd)\n 1943  #define VIDIOC_TRY_DECODER_CMD	_IOWR('V', 97, struct v4l2_decoder_cmd)\n 1944  \n 1945: /* Experimental, these three ioctls may change over the next couple of kernel\n 1946     versions. */\n 1947  #define VIDIOC_ENUM_DV_TIMINGS  _IOWR('V', 98, struct v4l2_enum_dv_timings)\n ....\n 1949  #define VIDIOC_DV_TIMINGS_CAP   _IOWR('V', 100, struct v4l2_dv_timings_cap)\n 1950  \n 1951: /* Experimental, this ioctl may change over the next couple of kernel\n 1952     versions. */\n 1953  #define VIDIOC_ENUM_FREQ_BANDS	_IOWR('V', 101, struct v4l2_frequency_band)\n ....\n 1957  #define VIDIOC_DBG_G_CHIP_INFO  _IOWR('V', 102, struct v4l2_dbg_chip_info)\n 1958  \n 1959: /* Reminder: when adding new ioctls please add support for them to\n 1960:    drivers/media/video/v4l2-compat-ioctl32.c as well! */\n 1961  \n 1962  #define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */\n\n/usr/include/linux/vt.h:\n   10  #define MAX_NR_CONSOLES	63	/* serial lines start at 64 */\n   11  #define MAX_NR_USER_CONSOLES 63	/* must be root to allocate above this */\n   12: 		/* Note: the ioctl VT_GETSTATE does not work for\n   13  		   consoles 16 and higher (since it returns a short) */\n   14  \n\n/usr/include/linux/watchdog.h:\n   10  #define _LINUX_WATCHDOG_H\n   11  \n   12: #include <linux/ioctl.h>\n   13  #include <linux/types.h>\n   14  \n   15: #define	WATCHDOG_IOCTL_BASE	'W'\n   16  \n   17  struct watchdog_info {\n   ..\n   21  };\n   22  \n   23: #define	WDIOC_GETSUPPORT	_IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)\n   24: #define	WDIOC_GETSTATUS		_IOR(WATCHDOG_IOCTL_BASE, 1, int)\n   25: #define	WDIOC_GETBOOTSTATUS	_IOR(WATCHDOG_IOCTL_BASE, 2, int)\n   26: #define	WDIOC_GETTEMP		_IOR(WATCHDOG_IOCTL_BASE, 3, int)\n   27: #define	WDIOC_SETOPTIONS	_IOR(WATCHDOG_IOCTL_BASE, 4, int)\n   28: #define	WDIOC_KEEPALIVE		_IOR(WATCHDOG_IOCTL_BASE, 5, int)\n   29: #define	WDIOC_SETTIMEOUT        _IOWR(WATCHDOG_IOCTL_BASE, 6, int)\n   30: #define	WDIOC_GETTIMEOUT        _IOR(WATCHDOG_IOCTL_BASE, 7, int)\n   31: #define	WDIOC_SETPRETIMEOUT	_IOWR(WATCHDOG_IOCTL_BASE, 8, int)\n   32: #define	WDIOC_GETPRETIMEOUT	_IOR(WATCHDOG_IOCTL_BASE, 9, int)\n   33: #define	WDIOC_GETTIMELEFT	_IOR(WATCHDOG_IOCTL_BASE, 10, int)\n   34  \n   35  #define	WDIOF_UNKNOWN		-1	/* Unknown flag error */\n\n/usr/include/linux/wireless.h:\n   15   * Initial APIs (1996 -> onward) :\n   16   * -----------------------------\n   17:  * Basically, the wireless extensions are for now a set of standard ioctl\n   18   * call + /proc/net/wireless\n   19   *\n   ..\n   23   * its centralised and we may remove the driver module safely.\n   24   *\n   25:  * Ioctl are used to configure the driver and issue commands.  This is\n   26   * better than command line options of insmod because we may want to\n   27   * change dynamically (while the driver is running) some parameters.\n   28   *\n   29:  * The ioctl mechanimsm are copied from standard devices ioctl.\n   30   * We have the list of command plus a structure descibing the\n   31   * data exchanged...\n   32:  * Note that to add these ioctl, I was obliged to modify :\n   33   *	# net/core/dev.c (two place + add include)\n   34   *	# net/ipv4/af_inet.c (one place + add include)\n   ..\n  103   * V5 to V6\n  104   * --------\n  105:  *	- 802.11 support (ESSID ioctls)\n  106   *\n  107   * V6 to V7\n  ...\n  128   *	- Add PM modifier : MAX/MIN/RELATIVE\n  129   *	- Add encoding option : IW_ENCODE_NOKEY\n  130:  *	- Add TxPower ioctls (work like TxRate)\n  131   *\n  132   * V10 to V11\n  133   * ----------\n  134   *	- Add WE version in range (help backward/forward compatibility)\n  135:  *	- Add retry ioctls (work like PM)\n  136   *\n  137   * V11 to V12\n  138   * ----------\n  139   *	- Add SIOCSIWSTATS to get /proc/net/wireless programatically\n  140:  *	- Add DEV PRIVATE IOCTL to avoid collisions in SIOCDEVPRIVATE space\n  141   *	- Add new statistics (frag, retry, beacon)\n  142   *	- Add average quality (for user space calibration)\n  ...\n  204   *	- Add IW_QUAL_ALL_UPDATED and IW_QUAL_ALL_INVALID macros\n  205   *	- Add explicit flag to tell stats are in dBm : IW_QUAL_DBM\n  206:  *	- Add IW_IOCTL_IDX() and IW_EVENT_IDX() macros\n  207   *\n  208   * V19 to V20\n  ...\n  225  /**************************** CONSTANTS ****************************/\n  226  \n  227: /* -------------------------- IOCTL LIST -------------------------- */\n  228  \n  229  /* Wireless Identification */\n  ...\n  248  #define SIOCGIWRANGE	0x8B0B		/* Get range of parameters */\n  249  #define SIOCSIWPRIV	0x8B0C		/* Unused */\n  250: #define SIOCGIWPRIV	0x8B0D		/* get private ioctl interface info */\n  251  #define SIOCSIWSTATS	0x8B0E		/* Unused */\n  252  #define SIOCGIWSTATS	0x8B0F		/* Get /proc/net/wireless stats */\n  ...\n  296  \n  297  /* WPA : Generic IEEE 802.11 informatiom element (e.g., for WPA/RSN/WMM).\n  298:  * This ioctl uses struct iw_point and data buffer that includes IE id and len\n  299   * fields. More than one IE may be included in the request. Setting the generic\n  300   * IE to empty buffer (len=0) removes the generic IE from the driver. Drivers\n  ...\n  319  #define SIOCSIWPMKSA	0x8B36		/* PMKSA cache operation */\n  320  \n  321: /* -------------------- DEV PRIVATE IOCTL LIST -------------------- */\n  322  \n  323: /* These 32 ioctl are wireless device private, for 16 commands.\n  324   * Each driver is free to use them for whatever purpose it chooses,\n  325:  * however the driver *must* export the description of those ioctls\n  326   * with SIOCGIWPRIV and *must* use arguments as defined below.\n  327   * If you don't follow those rules, DaveM is going to hate you (reason :\n  ...\n  341   */\n  342  \n  343: /* ------------------------- IOCTL STUFF ------------------------- */\n  344  \n  345  /* The first and the last (range) */\n  346  #define SIOCIWFIRST	0x8B00\n  347  #define SIOCIWLAST	SIOCIWLASTPRIV		/* 0x8BFF */\n  348: #define IW_IOCTL_IDX(cmd)	((cmd) - SIOCIWFIRST)\n  349  #define IW_HANDLER(id, func)			\\\n  350: 	[IW_IOCTL_IDX(id)] = func\n  351  \n  352  /* Odd : get (world access), even : set (root access) */\n  ...\n  355  \n  356  /* ----------------------- WIRELESS EVENTS ----------------------- */\n  357: /* Those are *NOT* ioctls, do not issue request on them !!! */\n  358: /* Most events use the same identifier as ioctl requests */\n  359  \n  360  #define IWEVTXDROP	0x8C00		/* Packet dropped to excessive retry */\n  ...\n  398  /*\n  399   * The following is used with SIOCGIWPRIV. It allow a driver to define\n  400:  * the interface (name, type of data) for its private ioctl.\n  401:  * Privates ioctl are SIOCIWFIRSTPRIV -> SIOCIWLASTPRIV\n  402   */\n  403  \n  ...\n  896  };\n  897  \n  898: /* ------------------------ IOCTL REQUEST ------------------------ */\n  899  /*\n  900:  * This structure defines the payload of an ioctl, and is used \n  901   * below.\n  902   *\n  ...\n  940  \n  941  /*\n  942:  * The structure to exchange data for ioctl.\n  943   * This structure is the same as 'struct ifreq', but (re)defined for\n  944   * convenience...\n  ...\n  956  };\n  957  \n  958: /* -------------------------- IOCTL DATA -------------------------- */\n  959  /*\n  960:  *	For those ioctl which want to exchange mode data that what could\n  961   *	fit in the above structure...\n  962   */\n  ...\n 1068  \n 1069  /*\n 1070:  * Private ioctl interface information\n 1071   */\n 1072   \n 1073  struct	iw_priv_args\n 1074  {\n 1075: 	__u32		cmd;		/* Number of the ioctl to issue */\n 1076  	__u16		set_args;	/* Type and number of args */\n 1077  	__u16		get_args;	/* Type and number of args */\n ....\n 1087  \n 1088  /*\n 1089:  * A Wireless Event. Contains basically the same data as the ioctl...\n 1090   */\n 1091  struct iw_event\n 1092  {\n 1093  	__u16		len;			/* Real length of this stuff */\n 1094: 	__u16		cmd;			/* Wireless IOCTL */\n 1095: 	union iwreq_data	u;		/* IOCTL fixed payload */\n 1096  };\n 1097  \n\n/usr/include/linux/dvb/frontend.h:\n  100  	__u8 msg [4];	/*  { framing, data [3] } */\n  101  	__u8 msg_len;	/*  valid values are 0...4, 0 means no msg  */\n  102: 	int  timeout;	/*  return from ioctl after timeout ms with */\n  103  };			/*  errorcode when no message was received  */\n  104  \n  ...\n  541  } __attribute__ ((packed));\n  542  \n  543: /* num of properties cannot exceed DTV_IOCTL_MAX_MSGS per ioctl */\n  544: #define DTV_IOCTL_MAX_MSGS 64\n  545  \n  546  struct dtv_properties {\n\n/usr/include/linux/fmd/ioctls.h:\n   32  \n   33  /**************************************************************************//**\n   34:  @File          ioctls.h\n   35  \n   36:  @Description   Structures and definitions for Command Relay Ioctls\n   37  *//***************************************************************************/\n   38  \n   39: #ifndef __IOCTLS_H__\n   40: #define __IOCTLS_H__\n   41  \n   42: #include <asm/ioctl.h>\n   43  \n   44: #include \"integration_ioctls.h\"\n   45  \n   46  \n   47  /**************************************************************************//**\n   48:  @Group         lnx_ioctl_ncsw_grp    NetCommSw Linux User-Space (IOCTL) API\n   49   @{\n   50  *//***************************************************************************/\n   51  \n   52: #define NCSW_IOC_TYPE_BASE          0xe0    /**< defines the IOCTL type for all\n   53                                                   the NCSW Linux module commands */\n   54  \n   55  \n   56  /**************************************************************************//**\n   57:  @Description   IOCTL Memory allocation types.\n   58  *//***************************************************************************/\n   59  typedef enum ioc_mem_type {\n   ..\n   91  } ioc_diag_mode;\n   92  \n   93: /** @} */ /* end of lnx_ioctl_ncsw_grp */\n   94  \n   95  \n   96: #endif /* __IOCTLS_H__ */\n   97  \n\n/usr/include/linux/fmd/net_ioctls.h:\n   32  \n   33  /**************************************************************************//**\n   34:  @File          net_ioctls.h\n   35  \n   36   @Description   This file contains common and general netcomm headers definitions.\n   37  *//***************************************************************************/\n   38: #ifndef __NET_IOCTLS_H\n   39: #define __NET_IOCTLS_H\n   40  \n   41: #include \"ioctls.h\"\n   42  \n   43  \n   ..\n  381  \n  382  \n  383: #endif /* __NET_IOCTLS_H */\n  384  \n\n/usr/include/linux/fmd/Peripherals/fm_ioctls.h:\n   32  \n   33  /**************************************************************************//**\n   34:  @File          fm_ioctls.h\n   35  \n   36:  @Description   FM Char device ioctls\n   37  *//***************************************************************************/\n   38: #ifndef __FM_IOCTLS_H\n   39: #define __FM_IOCTLS_H\n   40  \n   41  \n   42  /**************************************************************************//**\n   43:  @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API\n   44  \n   45:  @Description   FM Linux ioctls definitions and enums\n   46  \n   47   @{\n   ..\n   49  \n   50  /**************************************************************************//**\n   51:  @Collection    FM IOCTL device ('/dev') definitions\n   52  *//***************************************************************************/\n   53  #define DEV_FM_NAME                 \"fm\" /**< Name of the FM chardev */\n   ..\n  117  \n  118  /**************************************************************************//**\n  119:  @Group         lnx_ioctl_FM_lib_grp FM library\n  120  \n  121   @Description   FM API functions, definitions and enums\n  ...\n  156  \n  157  /**************************************************************************//**\n  158:  @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit\n  159  \n  160   @Description   FM Runtime control unit API functions, definitions and enums.\n  ...\n  315  #define FM_IOC_FORCE_INTR                                    _IOW(FM_IOC_TYPE_BASE, FM_IOC_NUM(6), ioc_fm_exceptions)\n  316  \n  317: /** @} */ /* end of lnx_ioctl_FM_runtime_control_grp group */\n  318: /** @} */ /* end of lnx_ioctl_FM_lib_grp group */\n  319: /** @} */ /* end of lnx_ioctl_FM_grp */\n  320  \n  321  \n  322: #endif /* __FM_IOCTLS_H */\n  323  \n\n/usr/include/linux/fmd/Peripherals/fm_pcd_ioctls.h:\n   32  \n   33  /******************************************************************************\n   34:  @File          fm_pcd_ioctls.h\n   35  \n   36   @Description   FM PCD ...\n   37  *//***************************************************************************/\n   38: #ifndef __FM_PCD_IOCTLS_H\n   39: #define __FM_PCD_IOCTLS_H\n   40  \n   41: #include \"net_ioctls.h\"\n   42: #include \"fm_ioctls.h\"\n   43  \n   44  \n   45  /**************************************************************************//**\n   46:  @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API\n   47  \n   48:  @Description   FM Linux ioctls definitions and enums\n   49  \n   50   @{\n   ..\n   52  \n   53  /**************************************************************************//**\n   54:  @Group         lnx_ioctl_FM_PCD_grp FM PCD\n   55  \n   56   @Description   FM PCD API functions, definitions and enums\n   ..\n  108  \n  109  /**************************************************************************//**\n  110:  @Group         lnx_ioctl_FM_PCD_Runtime_grp FM PCD Runtime Unit\n  111  \n  112   @Description   FM PCD Runtime Unit\n  ...\n 1533  #define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)\n 1534  \n 1535: #endif /* __FM_PCD_IOCTLS_H */\n 1536: /** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */\n 1537: /** @} */ /* end of lnx_ioctl_FM_PCD_grp group */\n 1538: /** @} */ /* end of lnx_ioctl_FM_grp group */\n 1539  \n\n/usr/include/linux/fmd/Peripherals/fm_port_ioctls.h:\n   32  \n   33  /******************************************************************************\n   34:  @File          fm_port_ioctls.h\n   35  \n   36   @Description   FM Port routines\n   37  *//***************************************************************************/\n   38: #ifndef __FM_PORT_IOCTLS_H\n   39: #define __FM_PORT_IOCTLS_H\n   40  \n   41: #include \"net_ioctls.h\"\n   42: #include \"fm_ioctls.h\"\n   43: #include \"fm_pcd_ioctls.h\"\n   44  \n   45  \n   46  /**************************************************************************//**\n   47:  @Group         lnx_ioctl_FM_grp Frame Manager Linux IOCTL API\n   48  \n   49:  @Description   FM Linux ioctls definitions and enums\n   50  \n   51   @{\n   ..\n   53  \n   54  /**************************************************************************//**\n   55:  @Group         lnx_ioctl_FM_PORT_grp FM Port\n   56  \n   57   @Description   FM Port API\n   ..\n   76  \n   77  /**************************************************************************//**\n   78:  @Group         lnx_ioctl_FM_PORT_runtime_control_grp FM Port Runtime Control Unit\n   79  \n   80   @Description   FM Port Runtime control unit API functions, definitions and enums.\n   ..\n  262  \n  263  /**************************************************************************//**\n  264:  @Group         lnx_ioctl_FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit\n  265  \n  266   @Description   FM Port PCD Runtime control unit API functions, definitions and enums.\n  ...\n  675  #define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)\n  676  \n  677: /** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */\n  678: /** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */\n  679: /** @} */ /* end of lnx_ioctl_FM_PORT_grp group */\n  680: /** @} */ /* end of lnx_ioctl_FM_grp group */\n  681  \n  682  \n  683: #endif /* __FM_PORT_IOCTLS_H */\n  684  \n\n/usr/include/linux/fmd/Peripherals/fm_test_ioctls.h:\n   32  \n   33  /**************************************************************************//**\n   34:  @File          fm_test_ioctls.h\n   35  \n   36:  @Description   FM Char device ioctls\n   37  *//***************************************************************************/\n   38: #ifndef __FM_TEST_IOCTLS_H\n   39: #define __FM_TEST_IOCTLS_H\n   40  \n   41: #include \"ioctls.h\"\n   42  \n   43  \n   44  /**************************************************************************//**\n   45:  @Group         lnx_ioctl_FMT_grp Frame Manager Test Linux IOCTL API\n   46  \n   47:  @Description   FM-Test Linux ioctls definitions and enums\n   48  \n   49   @{\n   ..\n   67  \n   68  /**************************************************************************//**\n   69:  @Group         lnx_ioctl_FMT_lib_grp FM-Test library\n   70  \n   71   @Description   TODO\n   ..\n  105  \n  106  /**************************************************************************//**\n  107:  @Group         lnx_ioctl_FMT_runtime_control_grp FM-Test Runtime Control Unit\n  108  \n  109   @Description   TODO\n  ...\n  111  *//***************************************************************************/\n  112  \n  113: /** @} */ /* end of lnx_ioctl_FMT_runtime_control_grp group */\n  114  \n  115  \n  116  /**************************************************************************//**\n  117:  @Group         lnx_ioctl_FMTP_lib_grp FM-Port-Test library\n  118  \n  119   @Description   TODO\n  ...\n  185  #define FMT_PORT_IOC_SET_DPAECHO_MODE     _IOW(FMT_IOC_TYPE_BASE, FMT_PORT_IOC_NUM(3), int)\n  186  \n  187: /** @} */ /* end of lnx_ioctl_FMTP_lib_grp group */\n  188: /** @} */ /* end of lnx_ioctl_FMT_lib_grp group */\n  189: /** @} */ /* end of lnx_ioctl_FMT_grp */\n  190  \n  191  \n  192: #endif /* __FM_TEST_IOCTLS_H */\n  193  \n\n/usr/include/linux/fmd/integrations/integration_ioctls.h:\n   32  \n   33  /**************************************************************************//**\n   34:  @File          integration_ioctls.h\n   35  \n   36   @Description   External header file for Integration unit routines.\n   37  *//***************************************************************************/\n   38  \n   39: #ifndef __INTG_IOCTLS_H\n   40: #define __INTG_IOCTLS_H\n   41  \n   42  \n   ..\n   45  \n   46  \n   47: #endif /* __INTG_IOCTLS_H */\n   48  \n\n/usr/include/linux/hdlc/ioctl.h:\n    1: #ifndef __HDLC_IOCTL_H__\n    2: #define __HDLC_IOCTL_H__\n    3  \n    4  \n    .\n   79  } cisco_proto;\n   80  \n   81: /* PPP doesn't need any info now - supply length = 0 to ioctl */\n   82  \n   83  #endif /* __ASSEMBLY__ */\n   84: #endif /* __HDLC_IOCTL_H__ */\n   85  \n\n/usr/include/linux/mmc/ioctl.h:\n    1: #ifndef LINUX_MMC_IOCTL_H\n    2: #define LINUX_MMC_IOCTL_H\n    3  \n    4  #include <linux/types.h>\n    .\n   49  \n   50  /*\n   51:  * Since this ioctl is only meant to enhance (and not replace) normal access\n   52   * to the mmc bus device, an upper data transfer limit of MMC_IOC_MAX_BYTES\n   53:  * is enforced per ioctl call.  For larger data transfers, use the normal\n   54   * block device operations.\n   55   */\n   56  #define MMC_IOC_MAX_BYTES  (512L * 256)\n   57: #endif /* LINUX_MMC_IOCTL_H */\n   58  \n\n/usr/include/linux/raid/md_u.h:\n   34  #define MD_PATCHLEVEL_VERSION           3\n   35  \n   36: /* ioctls */\n   37  \n   38  /* status */\n\n/usr/include/linux/spi/spidev.h:\n   46  /*---------------------------------------------------------------------------*/\n   47  \n   48: /* IOCTL commands */\n   49  \n   50  #define SPI_IOC_MAGIC			'k'\n   ..\n   75   *	struct spi_ioc_transfer mesg[4];\n   76   *	...\n   77:  *	status = ioctl(fd, SPI_IOC_MESSAGE(4), mesg);\n   78   *\n   79   * So for example one transfer might send a nine bit command (right aligned\n   ..\n   96  \n   97  	/* If the contents of 'struct spi_ioc_transfer' ever change\n   98: 	 * incompatibly, then the ioctl number (currently 0) must change;\n   99: 	 * ioctls with constant size fields get a bit more in the way of\n  100  	 * error checking than ones (like this) where that field varies.\n  101  	 *\n  ...\n  104  };\n  105  \n  106: /* not all platforms use <asm-generic/ioctl.h> or _IOC_TYPECHECK() ... */\n  107  #define SPI_MSGSIZE(N) \\\n  108  	((((N)*(sizeof (struct spi_ioc_transfer))) < (1 << _IOC_SIZEBITS)) \\\n\n/usr/include/linux/usb/functionfs.h:\n    4  \n    5  #include <linux/types.h>\n    6: #include <linux/ioctl.h>\n    7  \n    8  #include <linux/usb/ch9.h>\n    .\n  128  \n  129  \n  130: /* Endpoint ioctls */\n  131  /* The same as in gadgetfs */\n  132  \n\n/usr/include/linux/usb/g_printer.h:\n   26  #define PRINTER_PAPER_EMPTY	0x20\n   27  \n   28: /* The 'g' code is also used by gadgetfs ioctl requests.\n   29   * Don't add any colliding codes to either driver, and keep\n   30   * them in unique ranges (size 0x20 for now).\n\n/usr/include/linux/usb/gadgetfs.h:\n    7   * i/o requests.  When ep0 is configured, the device can enumerate;\n    8   * when it's closed, the device disconnects from usb.  Operations on\n    9:  * ep0 require ioctl() operations.\n   10   *\n   11   * Configuration and device descriptors get written to /dev/gadget/$CHIP,\n   ..\n   20  \n   21  #include <linux/types.h>\n   22: #include <linux/ioctl.h>\n   23  \n   24  #include <linux/usb/ch9.h>\n   ..\n   62  \n   63  \n   64: /* The 'g' code is also used by printer gadget ioctl requests.\n   65   * Don't add any colliding codes to either driver, and keep\n   66   * them in unique ranges (size 0x20 for now).\n   67   */\n   68  \n   69: /* endpoint ioctls */\n   70  \n   71  /* IN transfers may be reported to the gadget driver as complete\n\n/usr/include/linux/usb/tmc.h:\n    7   * Definition for Test and Measurement devices published by the USB-IF.\n    8   *\n    9:  * It also has the ioctl definitions for the usbtmc kernel driver that\n   10   * userspace needs to know about.\n   11   */\n   ..\n   32  #define USBTMC_REQUEST_INDICATOR_PULSE			64\n   33  \n   34: /* Request values for USBTMC driver's ioctl entry point */\n   35  #define USBTMC_IOC_NR			91\n   36: #define USBTMC_IOCTL_INDICATOR_PULSE	_IO(USBTMC_IOC_NR, 1)\n   37: #define USBTMC_IOCTL_CLEAR		_IO(USBTMC_IOC_NR, 2)\n   38: #define USBTMC_IOCTL_ABORT_BULK_OUT	_IO(USBTMC_IOC_NR, 3)\n   39: #define USBTMC_IOCTL_ABORT_BULK_IN	_IO(USBTMC_IOC_NR, 4)\n   40: #define USBTMC_IOCTL_CLEAR_OUT_HALT	_IO(USBTMC_IOC_NR, 6)\n   41: #define USBTMC_IOCTL_CLEAR_IN_HALT	_IO(USBTMC_IOC_NR, 7)\n   42  \n   43  #endif\n\n/usr/include/mtd/mtd-abi.h:\n   55   *			this mode implies %MTD_OPS_PLACE_OOB\n   56   *\n   57:  * These modes can be passed to ioctl(MEMWRITE) and are also used internally.\n   58   * See notes on \"MTD file modes\" for discussion on %MTD_OPS_RAW vs.\n   59   * %MTD_FILE_MODE_RAW.\n   ..\n   76   * @padding:	reserved, must be set to 0\n   77   *\n   78:  * This structure supports ioctl(MEMWRITE) operations, allowing data and/or OOB\n   79   * writes in various modes. To write to OOB-only, set @usr_data == NULL, and to\n   80   * write data-only, set @usr_oob == NULL. However, setting both @usr_data and\n   ..\n  148  \n  149  /*\n  150:  * Note, the following ioctl existed in the past and was removed:\n  151   * #define MEMSETOOBSEL           _IOW('M', 9, struct nand_oobinfo)\n  152:  * Try to avoid adding a new ioctl with the same ioctl number.\n  153   */\n  154  \n  ...\n  199  /*\n  200   * Most generic write interface; can write in-band and/or out-of-band in various\n  201:  * modes (see \"struct mtd_write_req\"). This ioctl is not supported for flashes\n  202   * without OOB, e.g., NOR flash.\n  203   */\n  ...\n  223  #define MTD_MAX_ECCPOS_ENTRIES	64\n  224  /*\n  225:  * OBSOLETE: ECC layout control structure. Exported to user-space via ioctl\n  226   * ECCGETLAYOUT for backwards compatbility and should not be mistaken as a\n  227:  * complete set of ECC information. The ioctl truncates the larger internal\n  228   * structure to retain binary compatibility with the static declaration of the\n  229:  * ioctl. Note that the \"MTD_MAX_..._ENTRIES\" macros represent the max size of\n  230   * the user struct, not the MAX size of the internal struct nand_ecclayout.\n  231   */\n  ...\n  260   * @MTD_FILE_MODE_RAW:		OTP disabled, ECC disabled\n  261   *\n  262:  * These modes can be set via ioctl(MTDFILEMODE). The mode mode will be retained\n  263   * separately for each open file descriptor.\n  264   *\n  ...\n  266   * raw access to the flash, without error correction or autoplacement schemes.\n  267   * Wherever possible, the MTD_OPS_* mode will override the MTD_FILE_MODE_* mode\n  268:  * (e.g., when using ioctl(MEMWRITE)), but in some cases, the MTD_FILE_MODE is\n  269:  * used out of necessity (e.g., `write()', ioctl(MEMWRITEOOB64)).\n  270   */\n  271  enum mtd_file_modes {\n\n/usr/include/mtd/ubi-user.h:\n   28   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   29   *\n   30:  * MTD devices may be attached using %UBI_IOCATT ioctl command of the UBI\n   31   * control device. The caller has to properly fill and pass\n   32   * &struct ubi_attach_req object - UBI will attach the MTD device specified in\n   33:  * the request and return the newly created UBI device number as the ioctl\n   34   * return value.\n   35   *\n   ..\n   37   * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n   38   *\n   39:  * An UBI device maybe deleted with %UBI_IOCDET ioctl command of the UBI\n   40   * control device.\n   41   *\n   ..\n   43   * ~~~~~~~~~~~~~~~~~~~\n   44   *\n   45:  * UBI volumes are created via the %UBI_IOCMKVOL ioctl command of UBI character\n   46   * device. A &struct ubi_mkvol_req object has to be properly filled and a\n   47:  * pointer to it has to be passed to the ioctl.\n   48   *\n   49   * UBI volume deletion\n   50   * ~~~~~~~~~~~~~~~~~~~\n   51   *\n   52:  * To delete a volume, the %UBI_IOCRMVOL ioctl command of the UBI character\n   53   * device should be used. A pointer to the 32-bit volume ID hast to be passed\n   54:  * to the ioctl.\n   55   *\n   56   * UBI volume re-size\n   57   * ~~~~~~~~~~~~~~~~~~\n   58   *\n   59:  * To re-size a volume, the %UBI_IOCRSVOL ioctl command of the UBI character\n   60   * device should be used. A &struct ubi_rsvol_req object has to be properly\n   61:  * filled and a pointer to it has to be passed to the ioctl.\n   62   *\n   63   * UBI volumes re-name\n   ..\n   66   * To re-name several volumes atomically at one go, the %UBI_IOCRNVOL command\n   67   * of the UBI character device should be used. A &struct ubi_rnvol_req object\n   68:  * has to be properly filled and a pointer to it has to be passed to the ioctl.\n   69   *\n   70   * UBI volume update\n   71   * ~~~~~~~~~~~~~~~~~\n   72   *\n   73:  * Volume update should be done via the %UBI_IOCVOLUP ioctl command of the\n   74   * corresponding UBI volume character device. A pointer to a 64-bit update\n   75:  * size should be passed to the ioctl. After this, UBI expects user to write\n   76   * this number of bytes to the volume character device. The update is finished\n   77   * when the claimed number of bytes is passed. So, the volume update sequence\n   ..\n   79   *\n   80   * fd = open(\"/dev/my_volume\");\n   81:  * ioctl(fd, UBI_IOCVOLUP, &image_size);\n   82   * write(fd, buf, image_size);\n   83   * close(fd);\n   ..\n   86   * ~~~~~~~~~~~~~~~~~~~~~~~~\n   87   *\n   88:  * To erase a logical eraseblock, the %UBI_IOCEBER ioctl command of the\n   89   * corresponding UBI volume character device should be used. This command\n   90   * unmaps the requested logical eraseblock, makes sure the corresponding\n   ..\n   95   *\n   96   * Atomic logical eraseblock change operation is called using the %UBI_IOCEBCH\n   97:  * ioctl command of the corresponding UBI volume character device. A pointer to\n   98:  * a &struct ubi_leb_change_req object has to be passed to the ioctl. Then the\n   99   * user is expected to write the requested amount of bytes (similarly to what\n  100:  * should be done in case of the \"volume update\" ioctl).\n  101   *\n  102   * Logical eraseblock map\n  ...\n  104   *\n  105   * To map a logical eraseblock to a physical eraseblock, the %UBI_IOCEBMAP\n  106:  * ioctl command should be used. A pointer to a &struct ubi_map_req object is\n  107:  * expected to be passed. The ioctl maps the requested logical eraseblock to\n  108   * a physical eraseblock and returns.  Only non-mapped logical eraseblocks can\n  109   * be mapped. If the logical eraseblock specified in the request is already\n  110:  * mapped to a physical eraseblock, the ioctl fails and returns error.\n  111   *\n  112   * Logical eraseblock unmap\n  ...\n  114   *\n  115   * To unmap a logical eraseblock to a physical eraseblock, the %UBI_IOCEBUNMAP\n  116:  * ioctl command should be used. The ioctl unmaps the logical eraseblocks,\n  117   * schedules corresponding physical eraseblock for erasure, and returns. Unlike\n  118   * the \"LEB erase\" command, it does not wait for the physical eraseblock being\n  119   * erased. Note, the side effect of this is that if an unclean reboot happens\n  120:  * after the unmap ioctl returns, you may find the LEB mapped again to the same\n  121   * physical eraseblock after the UBI is run again.\n  122   *\n  ...\n  125   *\n  126   * To check if a logical eraseblock is mapped to a physical eraseblock, the\n  127:  * %UBI_IOCEBISMAP ioctl command should be used. It returns %0 if the LEB is\n  128   * not mapped, and %1 if it is mapped.\n  129   *\n  ...\n  131   * ~~~~~~~~~~~~~~~~~~~~~~~~~\n  132   *\n  133:  * To set an UBI volume property the %UBI_IOCSETPROP ioctl command should be\n  134   * used. A pointer to a &struct ubi_set_vol_prop_req object is expected to be\n  135   * passed. The object describes which property should be set, and to which value\n  ...\n  148  #define UBI_MAX_VOLUME_NAME 127\n  149  \n  150: /* ioctl commands of UBI character devices */\n  151  \n  152  #define UBI_IOC_MAGIC 'o'\n  ...\n  161  #define UBI_IOCRNVOL _IOW(UBI_IOC_MAGIC, 3, struct ubi_rnvol_req)\n  162  \n  163: /* ioctl commands of the UBI control character device */\n  164  \n  165  #define UBI_CTRL_IOC_MAGIC 'o'\n  ...\n  170  #define UBI_IOCDET _IOW(UBI_CTRL_IOC_MAGIC, 65, __s32)\n  171  \n  172: /* ioctl commands of UBI volume character devices */\n  173  \n  174  #define UBI_VOL_IOC_MAGIC 'O'\n  ...\n  211  \n  212  /*\n  213:  * UBI set volume property ioctl constants.\n  214   *\n  215   * @UBI_VOL_PROP_DIRECT_WRITE: allow (any non-zero value) or disallow (value 0)\n\n/usr/include/net/if.h:\n  120    };\n  121  \n  122: /* Interface request structure used for socket ioctl's.  All interface\n  123:    ioctl's must have parameter definitions which begin with ifr_name.\n  124     The remainder may be interface specific.  */\n  125  \n\n/usr/include/net/if_arp.h:\n  135  \n  136  \n  137: /* ARP ioctl request.  */\n  138  struct arpreq\n  139    {\n\n/usr/include/net/if_ppp.h:\n   53  \n   54  #include <net/if.h>\n   55: #include <sys/ioctl.h>\n   56  #include <net/ppp_defs.h>\n   57  \n   ..\n  105  \n  106  /*\n  107:  * Ioctl definitions.\n  108   */\n  109  \n  110: struct npioctl {\n  111      int		protocol;	/* PPP protocol, e.g. PPP_IP */\n  112      enum NPmode	mode;\n  ...\n  134  \n  135  /*\n  136:  * Ioctl definitions.\n  137   */\n  138  \n  ...\n  151  #define PPPIOCXFERUNIT	_IO('t', 78)		/* transfer PPP unit */\n  152  #define PPPIOCSCOMPRESS	_IOW('t', 77, struct ppp_option_data)\n  153: #define PPPIOCGNPMODE	_IOWR('t', 76, struct npioctl) /* get NP mode */\n  154: #define PPPIOCSNPMODE	_IOW('t', 75, struct npioctl)  /* set NP mode */\n  155  #define PPPIOCGDEBUG	_IOR('t', 65, int)	/* Read debug level */\n  156  #define PPPIOCSDEBUG	_IOW('t', 64, int)	/* Set debug level */\n\n/usr/include/net/if_shaper.h:\n   22  #include <sys/types.h>\n   23  #include <net/if.h>\n   24: #include <sys/ioctl.h>\n   25  \n   26  __BEGIN_DECLS\n\n/usr/include/netax25/ax25.h:\n   40  #define AX25_KILL	99\n   41  \n   42: /* AX.25 socket ioctls: */\n   43  #define SIOCAX25GETUID		(SIOCPROTOPRIVATE)\n   44  #define SIOCAX25ADDUID		(SIOCPROTOPRIVATE+1)\n   ..\n   98    };\n   99  \n  100: /* The AX.25 ioctl structure: */\n  101  struct ax25_ctl_struct\n  102    {\n\n/usr/include/netrom/netrom.h:\n   51    };\n   52  \n   53: /* NetRom socket ioctls: */\n   54  #define	SIOCNRGETPARMS		(SIOCPROTOPRIVATE+0)\n   55  #define	SIOCNRSETPARMS		(SIOCPROTOPRIVATE+1)\n\n/usr/include/rdma/ib_user_mad.h:\n   36  \n   37  #include <linux/types.h>\n   38: #include <linux/ioctl.h>\n   39  \n   40  /*\n   ..\n   93   *   This layout allows specifying/receiving the P_Key index.  To use\n   94   *   this capability, an application must call the\n   95:  *   IB_USER_MAD_ENABLE_PKEY ioctl on the user MAD file handle before\n   96   *   any other actions with the file handle.\n   97   * @id - ID of agent MAD received with/to be sent with\n   ..\n  158   * method_mask[] to use unsigned long and handle the conversion from\n  159   * 32-bit userspace to 64-bit kernel for big-endian systems in the\n  160:  * compat_ioctl method.  Unfortunately, to keep the structure layout\n  161   * the same, we need the method_mask[] array to be aligned only to 4\n  162   * bytes even when long is 64 bits, which forces us into this ugly\n  ...\n  192  };\n  193  \n  194: #define IB_IOCTL_MAGIC		0x1b\n  195  \n  196: #define IB_USER_MAD_REGISTER_AGENT	_IOWR(IB_IOCTL_MAGIC, 1, \\\n  197  					      struct ib_user_mad_reg_req)\n  198  \n  199: #define IB_USER_MAD_UNREGISTER_AGENT	_IOW(IB_IOCTL_MAGIC, 2, __u32)\n  200  \n  201: #define IB_USER_MAD_ENABLE_PKEY		_IO(IB_IOCTL_MAGIC, 3)\n  202  \n  203  #endif /* IB_USER_MAD_H */\n\n/usr/include/rpc/clnt.h:\n  141      void (*cl_destroy) (CLIENT *); /* destroy this structure */\n  142      bool_t (*cl_control) (CLIENT *, int, char *);\n  143: 				/* the ioctl() of rpc */\n  144    } *cl_ops;\n  145    caddr_t cl_private;		/* private stuff */\n\n/usr/include/rpc/rpc_des.h:\n   50  \n   51  /*\n   52:  * parameters to ioctl call\n   53   */\n   54  struct desparams\n\n/usr/include/scsi/scsi.h:\n  206  \n  207  /*\n  208:  * Here are some scsi specific ioctl commands which are sometimes useful.\n  209   */\n  210  /* These are a few other constants only used by scsi devices.  */\n  211  \n  212: #define SCSI_IOCTL_GET_IDLUN 0x5382\n  213  \n  214  /* Used to turn on and off tagged queuing for scsi devices.  */\n  215  \n  216: #define SCSI_IOCTL_TAGGED_ENABLE 0x5383\n  217: #define SCSI_IOCTL_TAGGED_DISABLE 0x5384\n  218  \n  219  /* Used to obtain the host number of a device.  */\n  220: #define SCSI_IOCTL_PROBE_HOST 0x5385\n  221  \n  222  /* Used to get the bus number for a device.  */\n  223: #define SCSI_IOCTL_GET_BUS_NUMBER 0x5386\n  224  \n  225  #endif /* scsi/scsi.h */\n\n/usr/include/scsi/scsi_ioctl.h:\n   16     <http://www.gnu.org/licenses/>.  */\n   17  \n   18: #ifndef _SCSI_IOCTL_H\n   19: #define _SCSI_IOCTL_H\n   20  \n   21: /* IOCTLs for SCSI.  */\n   22: #define SCSI_IOCTL_SEND_COMMAND		1	/* Send a command to the SCSI host.  */\n   23: #define SCSI_IOCTL_TEST_UNIT_READY	2	/* Test if unit is ready.  */\n   24: #define SCSI_IOCTL_BENCHMARK_COMMAND	3\n   25: #define SCSI_IOCTL_SYNC			4	/* Request synchronous parameters.  */\n   26: #define SCSI_IOCTL_START_UNIT		5\n   27: #define SCSI_IOCTL_STOP_UNIT		6\n   28: #define SCSI_IOCTL_DOORLOCK		0x5380	/* Lock the eject mechanism.  */\n   29: #define SCSI_IOCTL_DOORUNLOCK		0x5381	/* Unlock the mechanism.  */\n   30  \n   31  #endif\n\n/usr/include/scsi/sg.h:\n   99  \n  100  /* Request information about a specific SG device, used by\n  101:    SG_GET_SCSI_ID ioctl ().  */\n  102  struct sg_scsi_id {\n  103    /* Host number as in \"scsi<n>\" where 'n' is one of 0, 1, 2 etc.  */\n  ...\n  117  };\n  118  \n  119: /* Used by SG_GET_REQUEST_TABLE ioctl().  */\n  120  typedef struct sg_req_info {\n  121      char req_state;     /* 0 -> not used, 1 -> written, 2 -> ready to read */\n  ...\n  131  \n  132  \n  133: /* IOCTLs: Those ioctls that are relevant to the SG 3.x drivers follow.\n  134   [Those that only apply to the SG 2.x drivers are at the end of the file.]\n  135   (_GET_s yield result via 'int *' 3rd argument unless otherwise indicated) */\n  ...\n  146  #define SG_GET_RESERVED_SIZE 0x2272  /* actual size of reserved buffer */\n  147  \n  148: /* The following ioctl has a 'sg_scsi_id_t *' object as its 3rd argument. */\n  149  #define SG_GET_SCSI_ID 0x2276   /* Yields fd's bus, chan, dev, lun + type */\n  150: /* SCSI id information can also be obtained from SCSI_IOCTL_GET_IDLUN */\n  151  \n  152  /* Override host setting and always DMA using low memory ( <16MB on i386) */\n  ...\n  176  #define SG_SCSI_RESET_HOST	3\n  177  \n  178: /* synchronous SCSI command ioctl, (only in version 3 interface) */\n  179  #define SG_IO 0x2285   /* similar effect as write() followed by read() */\n  180  \n  181  #define SG_GET_REQUEST_TABLE 0x2286   /* yields table of active requests */\n  182  \n  183: /* How to treat EINTR during SG_IO ioctl(), only in SG 3.x series */\n  184  #define SG_SET_KEEP_ORPHAN 0x2287 /* 1 -> hold for read(), 0 -> drop (def) */\n  185  #define SG_GET_KEEP_ORPHAN 0x2288\n  ...\n  248  \n  249  \n  250: /* IOCTLs: The following are not required (or ignored) when the sg_io_hdr_t\n  251  	   interface is used. They are kept for backward compatibility with\n  252  	   the original and version 2 drivers. */\n\n/usr/include/sound/asequencer.h:\n  567  \n  568  /*\n  569:  *  IOCTL commands\n  570   */\n  571  \n  572: #define SNDRV_SEQ_IOCTL_PVERSION	_IOR ('S', 0x00, int)\n  573: #define SNDRV_SEQ_IOCTL_CLIENT_ID	_IOR ('S', 0x01, int)\n  574: #define SNDRV_SEQ_IOCTL_SYSTEM_INFO	_IOWR('S', 0x02, struct snd_seq_system_info)\n  575: #define SNDRV_SEQ_IOCTL_RUNNING_MODE	_IOWR('S', 0x03, struct snd_seq_running_info)\n  576  \n  577: #define SNDRV_SEQ_IOCTL_GET_CLIENT_INFO	_IOWR('S', 0x10, struct snd_seq_client_info)\n  578: #define SNDRV_SEQ_IOCTL_SET_CLIENT_INFO	_IOW ('S', 0x11, struct snd_seq_client_info)\n  579  \n  580: #define SNDRV_SEQ_IOCTL_CREATE_PORT	_IOWR('S', 0x20, struct snd_seq_port_info)\n  581: #define SNDRV_SEQ_IOCTL_DELETE_PORT	_IOW ('S', 0x21, struct snd_seq_port_info)\n  582: #define SNDRV_SEQ_IOCTL_GET_PORT_INFO	_IOWR('S', 0x22, struct snd_seq_port_info)\n  583: #define SNDRV_SEQ_IOCTL_SET_PORT_INFO	_IOW ('S', 0x23, struct snd_seq_port_info)\n  584  \n  585: #define SNDRV_SEQ_IOCTL_SUBSCRIBE_PORT	_IOW ('S', 0x30, struct snd_seq_port_subscribe)\n  586: #define SNDRV_SEQ_IOCTL_UNSUBSCRIBE_PORT _IOW ('S', 0x31, struct snd_seq_port_subscribe)\n  587  \n  588: #define SNDRV_SEQ_IOCTL_CREATE_QUEUE	_IOWR('S', 0x32, struct snd_seq_queue_info)\n  589: #define SNDRV_SEQ_IOCTL_DELETE_QUEUE	_IOW ('S', 0x33, struct snd_seq_queue_info)\n  590: #define SNDRV_SEQ_IOCTL_GET_QUEUE_INFO	_IOWR('S', 0x34, struct snd_seq_queue_info)\n  591: #define SNDRV_SEQ_IOCTL_SET_QUEUE_INFO	_IOWR('S', 0x35, struct snd_seq_queue_info)\n  592: #define SNDRV_SEQ_IOCTL_GET_NAMED_QUEUE	_IOWR('S', 0x36, struct snd_seq_queue_info)\n  593: #define SNDRV_SEQ_IOCTL_GET_QUEUE_STATUS _IOWR('S', 0x40, struct snd_seq_queue_status)\n  594: #define SNDRV_SEQ_IOCTL_GET_QUEUE_TEMPO	_IOWR('S', 0x41, struct snd_seq_queue_tempo)\n  595: #define SNDRV_SEQ_IOCTL_SET_QUEUE_TEMPO	_IOW ('S', 0x42, struct snd_seq_queue_tempo)\n  596: #define SNDRV_SEQ_IOCTL_GET_QUEUE_OWNER	_IOWR('S', 0x43, struct snd_seq_queue_owner)\n  597: #define SNDRV_SEQ_IOCTL_SET_QUEUE_OWNER	_IOW ('S', 0x44, struct snd_seq_queue_owner)\n  598: #define SNDRV_SEQ_IOCTL_GET_QUEUE_TIMER	_IOWR('S', 0x45, struct snd_seq_queue_timer)\n  599: #define SNDRV_SEQ_IOCTL_SET_QUEUE_TIMER	_IOW ('S', 0x46, struct snd_seq_queue_timer)\n  600  /* XXX\n  601: #define SNDRV_SEQ_IOCTL_GET_QUEUE_SYNC	_IOWR('S', 0x53, struct snd_seq_queue_sync)\n  602: #define SNDRV_SEQ_IOCTL_SET_QUEUE_SYNC	_IOW ('S', 0x54, struct snd_seq_queue_sync)\n  603  */\n  604: #define SNDRV_SEQ_IOCTL_GET_QUEUE_CLIENT	_IOWR('S', 0x49, struct snd_seq_queue_client)\n  605: #define SNDRV_SEQ_IOCTL_SET_QUEUE_CLIENT	_IOW ('S', 0x4a, struct snd_seq_queue_client)\n  606: #define SNDRV_SEQ_IOCTL_GET_CLIENT_POOL	_IOWR('S', 0x4b, struct snd_seq_client_pool)\n  607: #define SNDRV_SEQ_IOCTL_SET_CLIENT_POOL	_IOW ('S', 0x4c, struct snd_seq_client_pool)\n  608: #define SNDRV_SEQ_IOCTL_REMOVE_EVENTS	_IOW ('S', 0x4e, struct snd_seq_remove_events)\n  609: #define SNDRV_SEQ_IOCTL_QUERY_SUBS	_IOWR('S', 0x4f, struct snd_seq_query_subs)\n  610: #define SNDRV_SEQ_IOCTL_GET_SUBSCRIPTION	_IOWR('S', 0x50, struct snd_seq_port_subscribe)\n  611: #define SNDRV_SEQ_IOCTL_QUERY_NEXT_CLIENT	_IOWR('S', 0x51, struct snd_seq_client_info)\n  612: #define SNDRV_SEQ_IOCTL_QUERY_NEXT_PORT	_IOWR('S', 0x52, struct snd_seq_port_info)\n  613  \n  614  #endif /* __SOUND_ASEQUENCER_H */\n\n/usr/include/sound/asound.h:\n  127  };\n  128  \n  129: #define SNDRV_HWDEP_IOCTL_PVERSION	_IOR ('H', 0x00, int)\n  130: #define SNDRV_HWDEP_IOCTL_INFO		_IOR ('H', 0x01, struct snd_hwdep_info)\n  131: #define SNDRV_HWDEP_IOCTL_DSP_STATUS	_IOR('H', 0x02, struct snd_hwdep_dsp_status)\n  132: #define SNDRV_HWDEP_IOCTL_DSP_LOAD	_IOW('H', 0x03, struct snd_hwdep_dsp_image)\n  133  \n  134  /*****************************************************************************\n  ...\n  257  #define SNDRV_PCM_INFO_OVERRANGE	0x00020000	/* hardware supports ADC (capture) overrange detection */\n  258  #define SNDRV_PCM_INFO_RESUME		0x00040000	/* hardware supports stream resume after suspend */\n  259: #define SNDRV_PCM_INFO_PAUSE		0x00080000	/* pause ioctl is supported */\n  260  #define SNDRV_PCM_INFO_HALF_DUPLEX	0x00100000	/* only half duplex */\n  261  #define SNDRV_PCM_INFO_JOINT_DUPLEX	0x00200000	/* playback and capture stream are somewhat correlated */\n  ...\n  513  #define SNDRV_CHMAP_DRIVER_SPEC		(0x02 << 16)\n  514  \n  515: #define SNDRV_PCM_IOCTL_PVERSION	_IOR('A', 0x00, int)\n  516: #define SNDRV_PCM_IOCTL_INFO		_IOR('A', 0x01, struct snd_pcm_info)\n  517: #define SNDRV_PCM_IOCTL_TSTAMP		_IOW('A', 0x02, int)\n  518: #define SNDRV_PCM_IOCTL_TTSTAMP		_IOW('A', 0x03, int)\n  519: #define SNDRV_PCM_IOCTL_HW_REFINE	_IOWR('A', 0x10, struct snd_pcm_hw_params)\n  520: #define SNDRV_PCM_IOCTL_HW_PARAMS	_IOWR('A', 0x11, struct snd_pcm_hw_params)\n  521: #define SNDRV_PCM_IOCTL_HW_FREE		_IO('A', 0x12)\n  522: #define SNDRV_PCM_IOCTL_SW_PARAMS	_IOWR('A', 0x13, struct snd_pcm_sw_params)\n  523: #define SNDRV_PCM_IOCTL_STATUS		_IOR('A', 0x20, struct snd_pcm_status)\n  524: #define SNDRV_PCM_IOCTL_DELAY		_IOR('A', 0x21, snd_pcm_sframes_t)\n  525: #define SNDRV_PCM_IOCTL_HWSYNC		_IO('A', 0x22)\n  526: #define SNDRV_PCM_IOCTL_SYNC_PTR	_IOWR('A', 0x23, struct snd_pcm_sync_ptr)\n  527: #define SNDRV_PCM_IOCTL_CHANNEL_INFO	_IOR('A', 0x32, struct snd_pcm_channel_info)\n  528: #define SNDRV_PCM_IOCTL_PREPARE		_IO('A', 0x40)\n  529: #define SNDRV_PCM_IOCTL_RESET		_IO('A', 0x41)\n  530: #define SNDRV_PCM_IOCTL_START		_IO('A', 0x42)\n  531: #define SNDRV_PCM_IOCTL_DROP		_IO('A', 0x43)\n  532: #define SNDRV_PCM_IOCTL_DRAIN		_IO('A', 0x44)\n  533: #define SNDRV_PCM_IOCTL_PAUSE		_IOW('A', 0x45, int)\n  534: #define SNDRV_PCM_IOCTL_REWIND		_IOW('A', 0x46, snd_pcm_uframes_t)\n  535: #define SNDRV_PCM_IOCTL_RESUME		_IO('A', 0x47)\n  536: #define SNDRV_PCM_IOCTL_XRUN		_IO('A', 0x48)\n  537: #define SNDRV_PCM_IOCTL_FORWARD		_IOW('A', 0x49, snd_pcm_uframes_t)\n  538: #define SNDRV_PCM_IOCTL_WRITEI_FRAMES	_IOW('A', 0x50, struct snd_xferi)\n  539: #define SNDRV_PCM_IOCTL_READI_FRAMES	_IOR('A', 0x51, struct snd_xferi)\n  540: #define SNDRV_PCM_IOCTL_WRITEN_FRAMES	_IOW('A', 0x52, struct snd_xfern)\n  541: #define SNDRV_PCM_IOCTL_READN_FRAMES	_IOR('A', 0x53, struct snd_xfern)\n  542: #define SNDRV_PCM_IOCTL_LINK		_IOW('A', 0x60, int)\n  543: #define SNDRV_PCM_IOCTL_UNLINK		_IO('A', 0x61)\n  544  \n  545  /*****************************************************************************\n  ...\n  595  };\n  596  \n  597: #define SNDRV_RAWMIDI_IOCTL_PVERSION	_IOR('W', 0x00, int)\n  598: #define SNDRV_RAWMIDI_IOCTL_INFO	_IOR('W', 0x01, struct snd_rawmidi_info)\n  599: #define SNDRV_RAWMIDI_IOCTL_PARAMS	_IOWR('W', 0x10, struct snd_rawmidi_params)\n  600: #define SNDRV_RAWMIDI_IOCTL_STATUS	_IOWR('W', 0x20, struct snd_rawmidi_status)\n  601: #define SNDRV_RAWMIDI_IOCTL_DROP	_IOW('W', 0x30, int)\n  602: #define SNDRV_RAWMIDI_IOCTL_DRAIN	_IOW('W', 0x31, int)\n  603  \n  604  /*\n  ...\n  709  };\n  710  \n  711: #define SNDRV_TIMER_IOCTL_PVERSION	_IOR('T', 0x00, int)\n  712: #define SNDRV_TIMER_IOCTL_NEXT_DEVICE	_IOWR('T', 0x01, struct snd_timer_id)\n  713: #define SNDRV_TIMER_IOCTL_TREAD		_IOW('T', 0x02, int)\n  714: #define SNDRV_TIMER_IOCTL_GINFO		_IOWR('T', 0x03, struct snd_timer_ginfo)\n  715: #define SNDRV_TIMER_IOCTL_GPARAMS	_IOW('T', 0x04, struct snd_timer_gparams)\n  716: #define SNDRV_TIMER_IOCTL_GSTATUS	_IOWR('T', 0x05, struct snd_timer_gstatus)\n  717: #define SNDRV_TIMER_IOCTL_SELECT	_IOW('T', 0x10, struct snd_timer_select)\n  718: #define SNDRV_TIMER_IOCTL_INFO		_IOR('T', 0x11, struct snd_timer_info)\n  719: #define SNDRV_TIMER_IOCTL_PARAMS	_IOW('T', 0x12, struct snd_timer_params)\n  720: #define SNDRV_TIMER_IOCTL_STATUS	_IOR('T', 0x14, struct snd_timer_status)\n  721: /* The following four ioctls are changed since 1.0.9 due to confliction */\n  722: #define SNDRV_TIMER_IOCTL_START		_IO('T', 0xa0)\n  723: #define SNDRV_TIMER_IOCTL_STOP		_IO('T', 0xa1)\n  724: #define SNDRV_TIMER_IOCTL_CONTINUE	_IO('T', 0xa2)\n  725: #define SNDRV_TIMER_IOCTL_PAUSE		_IO('T', 0xa3)\n  726  \n  727  struct snd_timer_read {\n  ...\n  904  };\n  905  \n  906: #define SNDRV_CTL_IOCTL_PVERSION	_IOR('U', 0x00, int)\n  907: #define SNDRV_CTL_IOCTL_CARD_INFO	_IOR('U', 0x01, struct snd_ctl_card_info)\n  908: #define SNDRV_CTL_IOCTL_ELEM_LIST	_IOWR('U', 0x10, struct snd_ctl_elem_list)\n  909: #define SNDRV_CTL_IOCTL_ELEM_INFO	_IOWR('U', 0x11, struct snd_ctl_elem_info)\n  910: #define SNDRV_CTL_IOCTL_ELEM_READ	_IOWR('U', 0x12, struct snd_ctl_elem_value)\n  911: #define SNDRV_CTL_IOCTL_ELEM_WRITE	_IOWR('U', 0x13, struct snd_ctl_elem_value)\n  912: #define SNDRV_CTL_IOCTL_ELEM_LOCK	_IOW('U', 0x14, struct snd_ctl_elem_id)\n  913: #define SNDRV_CTL_IOCTL_ELEM_UNLOCK	_IOW('U', 0x15, struct snd_ctl_elem_id)\n  914: #define SNDRV_CTL_IOCTL_SUBSCRIBE_EVENTS _IOWR('U', 0x16, int)\n  915: #define SNDRV_CTL_IOCTL_ELEM_ADD	_IOWR('U', 0x17, struct snd_ctl_elem_info)\n  916: #define SNDRV_CTL_IOCTL_ELEM_REPLACE	_IOWR('U', 0x18, struct snd_ctl_elem_info)\n  917: #define SNDRV_CTL_IOCTL_ELEM_REMOVE	_IOWR('U', 0x19, struct snd_ctl_elem_id)\n  918: #define SNDRV_CTL_IOCTL_TLV_READ	_IOWR('U', 0x1a, struct snd_ctl_tlv)\n  919: #define SNDRV_CTL_IOCTL_TLV_WRITE	_IOWR('U', 0x1b, struct snd_ctl_tlv)\n  920: #define SNDRV_CTL_IOCTL_TLV_COMMAND	_IOWR('U', 0x1c, struct snd_ctl_tlv)\n  921: #define SNDRV_CTL_IOCTL_HWDEP_NEXT_DEVICE _IOWR('U', 0x20, int)\n  922: #define SNDRV_CTL_IOCTL_HWDEP_INFO	_IOR('U', 0x21, struct snd_hwdep_info)\n  923: #define SNDRV_CTL_IOCTL_PCM_NEXT_DEVICE	_IOR('U', 0x30, int)\n  924: #define SNDRV_CTL_IOCTL_PCM_INFO	_IOWR('U', 0x31, struct snd_pcm_info)\n  925: #define SNDRV_CTL_IOCTL_PCM_PREFER_SUBDEVICE _IOW('U', 0x32, int)\n  926: #define SNDRV_CTL_IOCTL_RAWMIDI_NEXT_DEVICE _IOWR('U', 0x40, int)\n  927: #define SNDRV_CTL_IOCTL_RAWMIDI_INFO	_IOWR('U', 0x41, struct snd_rawmidi_info)\n  928: #define SNDRV_CTL_IOCTL_RAWMIDI_PREFER_SUBDEVICE _IOW('U', 0x42, int)\n  929: #define SNDRV_CTL_IOCTL_POWER		_IOWR('U', 0xd0, int)\n  930: #define SNDRV_CTL_IOCTL_POWER_STATE	_IOR('U', 0xd1, int)\n  931  \n  932  /*\n\n/usr/include/sound/asound_fm.h:\n   94  \n   95  /*\n   96:  *  FM mode ioctl settings\n   97   */\n   98  \n   99: #define SNDRV_DM_FM_IOCTL_INFO		_IOR('H', 0x20, struct snd_dm_fm_info)\n  100: #define SNDRV_DM_FM_IOCTL_RESET		_IO ('H', 0x21)\n  101: #define SNDRV_DM_FM_IOCTL_PLAY_NOTE	_IOW('H', 0x22, struct snd_dm_fm_note)\n  102: #define SNDRV_DM_FM_IOCTL_SET_VOICE	_IOW('H', 0x23, struct snd_dm_fm_voice)\n  103: #define SNDRV_DM_FM_IOCTL_SET_PARAMS	_IOW('H', 0x24, struct snd_dm_fm_params)\n  104: #define SNDRV_DM_FM_IOCTL_SET_MODE	_IOW('H', 0x25, int)\n  105  /* for OPL3 only */\n  106: #define SNDRV_DM_FM_IOCTL_SET_CONNECTION	_IOW('H', 0x26, int)\n  107  /* SBI patch management */\n  108: #define SNDRV_DM_FM_IOCTL_CLEAR_PATCHES	_IO ('H', 0x40)\n  109  \n  110: #define SNDRV_DM_FM_OSS_IOCTL_RESET		0x20\n  111: #define SNDRV_DM_FM_OSS_IOCTL_PLAY_NOTE		0x21\n  112: #define SNDRV_DM_FM_OSS_IOCTL_SET_VOICE		0x22\n  113: #define SNDRV_DM_FM_OSS_IOCTL_SET_PARAMS	0x23\n  114: #define SNDRV_DM_FM_OSS_IOCTL_SET_MODE		0x24\n  115: #define SNDRV_DM_FM_OSS_IOCTL_SET_OPL		0x25\n  116  \n  117  /*\n\n/usr/include/sound/compress_offload.h:\n  144  \n  145  /**\n  146:  * compress path ioctl definitions\n  147   * SNDRV_COMPRESS_GET_CAPS: Query capability of DSP\n  148   * SNDRV_COMPRESS_GET_CODEC_CAPS: Query capability of a codec\n  ...\n  159   * and the buffers currently with DSP\n  160   * SNDRV_COMPRESS_DRAIN: Play till end of buffers and stop after that\n  161:  * SNDRV_COMPRESS_IOCTL_VERSION: Query the API version\n  162   */\n  163: #define SNDRV_COMPRESS_IOCTL_VERSION	_IOR('C', 0x00, int)\n  164  #define SNDRV_COMPRESS_GET_CAPS		_IOWR('C', 0x10, struct snd_compr_caps)\n  165  #define SNDRV_COMPRESS_GET_CODEC_CAPS	_IOWR('C', 0x11,\\\n\n/usr/include/sound/emu10k1.h:\n  347  #define SNDRV_EMU10K1_VERSION		SNDRV_PROTOCOL_VERSION(1, 0, 1)\n  348  \n  349: #define SNDRV_EMU10K1_IOCTL_INFO	_IOR ('H', 0x10, struct snd_emu10k1_fx8010_info)\n  350: #define SNDRV_EMU10K1_IOCTL_CODE_POKE	_IOW ('H', 0x11, struct snd_emu10k1_fx8010_code)\n  351: #define SNDRV_EMU10K1_IOCTL_CODE_PEEK	_IOWR('H', 0x12, struct snd_emu10k1_fx8010_code)\n  352: #define SNDRV_EMU10K1_IOCTL_TRAM_SETUP	_IOW ('H', 0x20, int)\n  353: #define SNDRV_EMU10K1_IOCTL_TRAM_POKE	_IOW ('H', 0x21, struct snd_emu10k1_fx8010_tram)\n  354: #define SNDRV_EMU10K1_IOCTL_TRAM_PEEK	_IOWR('H', 0x22, struct snd_emu10k1_fx8010_tram)\n  355: #define SNDRV_EMU10K1_IOCTL_PCM_POKE	_IOW ('H', 0x30, struct snd_emu10k1_fx8010_pcm_rec)\n  356: #define SNDRV_EMU10K1_IOCTL_PCM_PEEK	_IOWR('H', 0x31, struct snd_emu10k1_fx8010_pcm_rec)\n  357: #define SNDRV_EMU10K1_IOCTL_PVERSION	_IOR ('H', 0x40, int)\n  358: #define SNDRV_EMU10K1_IOCTL_STOP	_IO  ('H', 0x80)\n  359: #define SNDRV_EMU10K1_IOCTL_CONTINUE	_IO  ('H', 0x81)\n  360: #define SNDRV_EMU10K1_IOCTL_ZERO_TRAM_COUNTER _IO ('H', 0x82)\n  361: #define SNDRV_EMU10K1_IOCTL_SINGLE_STEP	_IOW ('H', 0x83, int)\n  362: #define SNDRV_EMU10K1_IOCTL_DBG_READ	_IOR ('H', 0x84, int)\n  363  \n  364  /* typedefs for compatibility to user-space */\n\n/usr/include/sound/firewire.h:\n    2  #define _SOUND_FIREWIRE_H_INCLUDED\n    3  \n    4: #include <linux/ioctl.h>\n    5  \n    6  /* events can be read() from the hwdep device */\n    .\n   30  \n   31  \n   32: #define SNDRV_FIREWIRE_IOCTL_GET_INFO _IOR('H', 0xf8, struct snd_firewire_get_info)\n   33: #define SNDRV_FIREWIRE_IOCTL_LOCK      _IO('H', 0xf9)\n   34: #define SNDRV_FIREWIRE_IOCTL_UNLOCK    _IO('H', 0xfa)\n   35  \n   36  #define SNDRV_FIREWIRE_TYPE_DICE	1\n   ..\n   45  \n   46  /*\n   47:  * SNDRV_FIREWIRE_IOCTL_LOCK prevents the driver from streaming.\n   48   * Returns -EBUSY if the driver is already streaming.\n   49   */\n\n/usr/include/sound/hdsp.h:\n   43  };\n   44  \n   45: #define SNDRV_HDSP_IOCTL_GET_PEAK_RMS _IOR('H', 0x40, struct hdsp_peak_rms)\n   46  \n   47  struct hdsp_config_info {\n   ..\n   71  };\n   72  \n   73: #define SNDRV_HDSP_IOCTL_GET_CONFIG_INFO _IOR('H', 0x41, struct hdsp_config_info)\n   74  \n   75  struct hdsp_firmware {\n   ..\n   77  };\n   78  \n   79: #define SNDRV_HDSP_IOCTL_UPLOAD_FIRMWARE _IOW('H', 0x42, struct hdsp_firmware)\n   80  \n   81  struct hdsp_version {\n   ..\n   84  };\n   85  \n   86: #define SNDRV_HDSP_IOCTL_GET_VERSION _IOR('H', 0x43, struct hdsp_version)\n   87  \n   88  struct hdsp_mixer {\n   ..\n   90  };\n   91  \n   92: #define SNDRV_HDSP_IOCTL_GET_MIXER _IOR('H', 0x44, struct hdsp_mixer)\n   93  \n   94  struct hdsp_9632_aeb {\n   ..\n   97  };\n   98  \n   99: #define SNDRV_HDSP_IOCTL_GET_9632_AEB _IOR('H', 0x45, struct hdsp_9632_aeb)\n  100  \n  101  /* typedefs for compatibility to user-space */\n\n/usr/include/sound/hdspm.h:\n   38  };\n   39  \n   40: /* -------------------- IOCTL Peak/RMS Meters -------------------- */\n   41  \n   42  struct hdspm_peak_rms {\n   ..\n   53  };\n   54  \n   55: #define SNDRV_HDSPM_IOCTL_GET_PEAK_RMS \\\n   56  	_IOR('H', 0x42, struct hdspm_peak_rms)\n   57  \n   58: /* ------------ CONFIG block IOCTL ---------------------- */\n   59  \n   60  struct hdspm_config {\n   ..\n   72  };\n   73  \n   74: #define SNDRV_HDSPM_IOCTL_GET_CONFIG \\\n   75  	_IOR('H', 0x41, struct hdspm_config)\n   76  \n   ..\n   80   * The hdspm_ltc structure contains the current SMPTE\n   81   * timecode and some status information and can be\n   82:  * obtained via SNDRV_HDSPM_IOCTL_GET_LTC or in the\n   83   * hdspm_status struct.\n   84   **/\n   ..\n  112  };\n  113  \n  114: #define SNDRV_HDSPM_IOCTL_GET_LTC _IOR('H', 0x46, struct hdspm_ltc)\n  115  \n  116  /**\n  ...\n  169  };\n  170  \n  171: #define SNDRV_HDSPM_IOCTL_GET_STATUS \\\n  172  	_IOR('H', 0x47, struct hdspm_status)\n  173  \n  ...\n  186  };\n  187  \n  188: #define SNDRV_HDSPM_IOCTL_GET_VERSION _IOR('H', 0x48, struct hdspm_version)\n  189  \n  190: /* ------------- get Matrix Mixer IOCTL --------------- */\n  191  \n  192  /* MADI mixer: 64inputs+64playback in 64outputs = 8192 => *4Byte =\n  ...\n  212  };\n  213  \n  214: struct hdspm_mixer_ioctl {\n  215  	struct hdspm_mixer *mixer;\n  216  };\n  217  \n  218: /* use indirect access due to the limit of ioctl bit size */\n  219: #define SNDRV_HDSPM_IOCTL_GET_MIXER _IOR('H', 0x44, struct hdspm_mixer_ioctl)\n  220  \n  221  /* typedefs for compatibility to user-space */\n\n/usr/include/sound/sb16_csp.h:\n   98  /* HWDEP controls */\n   99  /* get CSP information */\n  100: #define SNDRV_SB_CSP_IOCTL_INFO		_IOR('H', 0x10, struct snd_sb_csp_info)\n  101  /* load microcode to CSP */\n  102  /* NOTE: struct snd_sb_csp_microcode overflows the max size (13 bits)\n  ...\n  106   * normal _IOW() macro but _IOC() with the manual argument.\n  107   */\n  108: #define SNDRV_SB_CSP_IOCTL_LOAD_CODE	\\\n  109  	_IOC(_IOC_WRITE, 'H', 0x11, sizeof(struct snd_sb_csp_microcode))\n  110  /* unload microcode from CSP */\n  111: #define SNDRV_SB_CSP_IOCTL_UNLOAD_CODE	_IO('H', 0x12)\n  112  /* start CSP */\n  113: #define SNDRV_SB_CSP_IOCTL_START		_IOW('H', 0x13, struct snd_sb_csp_start)\n  114  /* stop CSP */\n  115: #define SNDRV_SB_CSP_IOCTL_STOP		_IO('H', 0x14)\n  116  /* pause CSP and DMA transfer */\n  117: #define SNDRV_SB_CSP_IOCTL_PAUSE		_IO('H', 0x15)\n  118  /* restart CSP and DMA transfer */\n  119: #define SNDRV_SB_CSP_IOCTL_RESTART	_IO('H', 0x16)\n  120  \n  121  \n\n/usr/include/sound/sfnt_info.h:\n  189  \n  190  /*\n  191:  * ioctls for hwdep\n  192   */\n  193  \n  ...\n  203  };\n  204  \n  205: #define SNDRV_EMUX_IOCTL_VERSION	_IOR('H', 0x80, unsigned int)\n  206: #define SNDRV_EMUX_IOCTL_LOAD_PATCH	_IOWR('H', 0x81, struct soundfont_patch_info)\n  207: #define SNDRV_EMUX_IOCTL_RESET_SAMPLES	_IO('H', 0x82)\n  208: #define SNDRV_EMUX_IOCTL_REMOVE_LAST_SAMPLES _IO('H', 0x83)\n  209: #define SNDRV_EMUX_IOCTL_MEM_AVAIL	_IOW('H', 0x84, int)\n  210: #define SNDRV_EMUX_IOCTL_MISC_MODE	_IOWR('H', 0x84, struct snd_emux_misc_mode)\n  211  \n  212  #endif /* __SOUND_SFNT_INFO_H */\n\n/usr/include/video/sisfb.h:\n   23  \n   24  #include <linux/types.h>\n   25: #include <asm/ioctl.h>\n   26  \n   27  /**********************************************/\n   ..\n   74  #define VB_DISPLAY_MODE		(SINGLE_MODE | MIRROR_MODE | DUALVIEW_MODE)\n   75  \n   76: /* Structure argument for SISFB_GET_INFO ioctl  */\n   77  struct sisfb_info {\n   78  	__u32	sisfb_id;		/* for identifying sisfb */\n   ..\n  145  #define SISFB_CMD_ERR_OTHER	0x80010000	/* Other error */\n  146  \n  147: /* Argument for SISFB_CMD ioctl */\n  148  struct sisfb_cmd {\n  149  	__u32  sisfb_cmd;\n  ...\n  152  };\n  153  \n  154: /* Additional IOCTLs for communication sisfb <> X driver                */\n  155  /* If changing this, vgatypes.h must also be changed (for X driver)    */\n  156  \n  157: /* ioctl for identifying and giving some info (esp. memory heap start) */\n  158  #define SISFB_GET_INFO_SIZE	_IOR(0xF3,0x00,__u32)\n  159  #define SISFB_GET_INFO		_IOR(0xF3,0x01,struct sisfb_info)\n  ...\n  162  #define SISFB_GET_VBRSTATUS	_IOR(0xF3,0x02,__u32)\n  163  \n  164: /* ioctl to enable/disable panning auto-maximize (like nomax parameter) */\n  165  #define SISFB_GET_AUTOMAXIMIZE	_IOR(0xF3,0x03,__u32)\n  166  #define SISFB_SET_AUTOMAXIMIZE	_IOW(0xF3,0x03,__u32)\n  167  \n  168: /* ioctls to relocate TV output (x=D[31:16], y=D[15:0], + 32)*/\n  169  #define SISFB_GET_TVPOSOFFSET	_IOR(0xF3,0x04,__u32)\n  170  #define SISFB_SET_TVPOSOFFSET	_IOW(0xF3,0x04,__u32)\n  171  \n  172: /* ioctl for internal sisfb commands (sisfbctrl) */\n  173  #define SISFB_COMMAND		_IOWR(0xF3,0x05,struct sisfb_cmd)\n  174  \n  175: /* ioctl for locking sisfb (no register access during lock) */\n  176  /* As of now, only used to avoid register access during\n  177:  * the ioctls listed above.\n  178   */\n  179  #define SISFB_SET_LOCK		_IOW(0xF3,0x06,__u32)\n  180  \n  181: /* ioctls 0xF3 up to 0x3F reserved for sisfb */\n  182  \n  183  /****************************************************************/\n  184  /* The following are deprecated and should not be used anymore: */\n  185  /****************************************************************/\n  186: /* ioctl for identifying and giving some info (esp. memory heap start) */\n  187  #define SISFB_GET_INFO_OLD	   _IOR('n',0xF8,__u32)\n  188  /* ioctrl to get current vertical retrace status */\n  189  #define SISFB_GET_VBRSTATUS_OLD	   _IOR('n',0xF9,__u32)\n  190: /* ioctl to enable/disable panning auto-maximize (like nomax parameter) */\n  191  #define SISFB_GET_AUTOMAXIMIZE_OLD _IOR('n',0xFA,__u32)\n  192  #define SISFB_SET_AUTOMAXIMIZE_OLD _IOW('n',0xFA,__u32)\n  193  /****************************************************************/\n  194: /*               End of deprecated ioctl numbers                */\n  195  /****************************************************************/\n  196  \n\n/usr/include/x86_64-linux-gnu/asm/ioctl.h:\n    1: #include <asm-generic/ioctl.h>\n    2  \n\n/usr/include/x86_64-linux-gnu/asm/ioctls.h:\n    1: #include <asm-generic/ioctls.h>\n    2  \n\n/usr/include/x86_64-linux-gnu/asm/kvm.h:\n    8  \n    9  #include <linux/types.h>\n   10: #include <linux/ioctl.h>\n   11  \n   12  #define DE_VECTOR 0\n\n/usr/include/x86_64-linux-gnu/asm/mce.h:\n    3  \n    4  #include <linux/types.h>\n    5: #include <asm/ioctls.h>\n    6  \n    7  /* Fields are zero when not available */\n\n/usr/include/x86_64-linux-gnu/asm/msr.h:\n    7  \n    8  #include <linux/types.h>\n    9: #include <linux/ioctl.h>\n   10  \n   11  #define X86_IOC_RDMSR_REGS	_IOWR('c', 0xA0, __u32[8])\n\n/usr/include/x86_64-linux-gnu/asm/mtrr.h:\n    1: /*  Generic MTRR (Memory Type Range Register) ioctls.\n    2  \n    3      Copyright (C) 1997-1999  Richard Gooch\n    .\n   25  \n   26  #include <linux/types.h>\n   27: #include <linux/ioctl.h>\n   28  #include <linux/errno.h>\n   29  \n   30: #define	MTRR_IOCTL_BASE	'M'\n   31  \n   32  /* Warning: this structure has a different order from i386\n   ..\n   92  #define MTRRphysMask_MSR(reg) (0x200 + 2 * (reg) + 1)\n   93  \n   94: /*  These are the various ioctls  */\n   95: #define MTRRIOC_ADD_ENTRY        _IOW(MTRR_IOCTL_BASE,  0, struct mtrr_sentry)\n   96: #define MTRRIOC_SET_ENTRY        _IOW(MTRR_IOCTL_BASE,  1, struct mtrr_sentry)\n   97: #define MTRRIOC_DEL_ENTRY        _IOW(MTRR_IOCTL_BASE,  2, struct mtrr_sentry)\n   98: #define MTRRIOC_GET_ENTRY        _IOWR(MTRR_IOCTL_BASE, 3, struct mtrr_gentry)\n   99: #define MTRRIOC_KILL_ENTRY       _IOW(MTRR_IOCTL_BASE,  4, struct mtrr_sentry)\n  100: #define MTRRIOC_ADD_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  5, struct mtrr_sentry)\n  101: #define MTRRIOC_SET_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  6, struct mtrr_sentry)\n  102: #define MTRRIOC_DEL_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  7, struct mtrr_sentry)\n  103: #define MTRRIOC_GET_PAGE_ENTRY   _IOWR(MTRR_IOCTL_BASE, 8, struct mtrr_gentry)\n  104: #define MTRRIOC_KILL_PAGE_ENTRY  _IOW(MTRR_IOCTL_BASE,  9, struct mtrr_sentry)\n  105  \n  106  /*  These are the region types  */\n\n/usr/include/x86_64-linux-gnu/asm/unistd_32.h:\n   56  #define __NR_umount2 52\n   57  #define __NR_lock 53\n   58: #define __NR_ioctl 54\n   59  #define __NR_fcntl 55\n   60  #define __NR_mpx 56\n\n/usr/include/x86_64-linux-gnu/asm/unistd_64.h:\n   18  #define __NR_rt_sigprocmask 14\n   19  #define __NR_rt_sigreturn 15\n   20: #define __NR_ioctl 16\n   21  #define __NR_pread64 17\n   22  #define __NR_pwrite64 18\n\n/usr/include/x86_64-linux-gnu/asm/unistd_x32.h:\n  278  #define __NR_rt_sigaction (__X32_SYSCALL_BIT + 512)\n  279  #define __NR_rt_sigreturn (__X32_SYSCALL_BIT + 513)\n  280: #define __NR_ioctl (__X32_SYSCALL_BIT + 514)\n  281  #define __NR_readv (__X32_SYSCALL_BIT + 515)\n  282  #define __NR_writev (__X32_SYSCALL_BIT + 516)\n\n/usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n    1: /* Structure types for pre-termios terminal ioctls.  Linux version.\n    2     Copyright (C) 1996-2014 Free Software Foundation, Inc.\n    3     This file is part of the GNU C Library.\n    .\n   17     <http://www.gnu.org/licenses/>.  */\n   18  \n   19: #ifndef _SYS_IOCTL_H\n   20: # error \"Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead.\"\n   21  #endif\n   22  \n   23: /* Get definition of constants for use with `ioctl'.  */\n   24: #include <asm/ioctls.h>\n   25  \n   26  \n   ..\n   57  #define TIOCM_RI	TIOCM_RNG\n   58  \n   59: /* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */\n   60  \n   61  /* line disciplines */\n\n/usr/include/x86_64-linux-gnu/bits/ioctls.h:\n   16     <http://www.gnu.org/licenses/>.  */\n   17  \n   18: #ifndef _SYS_IOCTL_H\n   19: # error \"Never use <bits/ioctls.h> directly; include <sys/ioctl.h> instead.\"\n   20  #endif\n   21  \n   22  /* Use the definitions from the kernel header files.  */\n   23: #include <asm/ioctls.h>\n   24  \n   25  /* Routing table calls.  */\n   ..\n   93  #define SIOCDELDLCI	0x8981		/* Delete DLCI device		*/\n   94  \n   95: /* Device private ioctl calls.  */\n   96  \n   97: /* These 16 ioctls are available to devices via the do_ioctl() device\n   98     vector.  Each device should include this file and redefine these\n   99     names as their own. Because these are device dependent it is a good\n  ...\n  103  \n  104  /*\n  105:  *	These 16 ioctl calls are protocol private\n  106   */\n  107  \n\n/usr/include/x86_64-linux-gnu/bits/stropts.h:\n   25  #include <bits/types.h>\n   26  \n   27: /* Macros used as `request' argument to `ioctl'.  */\n   28  #define __SID		('S' << 8)\n   29  \n   ..\n   40  #define I_SRDOPT    (__SID | 6)	/* Sets the read mode.  */\n   41  #define I_GRDOPT    (__SID | 7)	/* Returns the current read mode setting.  */\n   42: #define I_STR	    (__SID | 8)	/* Construct an internal STREAMS `ioctl'\n   43  				   message and send that message downstream. */\n   44  #define I_SETSIG    (__SID | 9)	/* Inform the STREAM head that the process\n   ..\n  170  \n  171  \n  172: /* Structure used for the I_FLUSHBAND ioctl on streams.  */\n  173  struct bandinfo\n  174    {\n  ...\n  200    };\n  201  \n  202: struct strioctl\n  203    {\n  204      int ic_cmd;\n\n/usr/include/x86_64-linux-gnu/bits/syscall.h:\n  129  #define SYS_io_setup __NR_io_setup\n  130  #define SYS_io_submit __NR_io_submit\n  131: #define SYS_ioctl __NR_ioctl\n  132  #define SYS_ioperm __NR_ioperm\n  133  #define SYS_iopl __NR_iopl\n  ...\n  470  #define SYS_io_setup __NR_io_setup\n  471  #define SYS_io_submit __NR_io_submit\n  472: #define SYS_ioctl __NR_ioctl\n  473  #define SYS_ioperm __NR_ioperm\n  474  #define SYS_iopl __NR_iopl\n  ...\n  784  #define SYS_io_setup __NR_io_setup\n  785  #define SYS_io_submit __NR_io_submit\n  786: #define SYS_ioctl __NR_ioctl\n  787  #define SYS_ioperm __NR_ioperm\n  788  #define SYS_iopl __NR_iopl\n\n/usr/include/x86_64-linux-gnu/bits/termios.h:\n  216  \n  217  \n  218: #define _IOT_termios /* Hurd ioctl type field.  */ \\\n  219    _IOT (_IOTS (cflag_t), 4, _IOTS (cc_t), NCCS, _IOTS (speed_t), 2)\n  220  \n\n/usr/include/x86_64-linux-gnu/c++/4.8/bits/c++config.h:\n  849  /* #undef _GLIBCXX_HAVE_SYS_FILIO_H */\n  850  \n  851: /* Define to 1 if you have the <sys/ioctl.h> header file. */\n  852: #define _GLIBCXX_HAVE_SYS_IOCTL_H 1\n  853  \n  854  /* Define to 1 if you have the <sys/ipc.h> header file. */\n\n/usr/include/x86_64-linux-gnu/sys/ioctl.h:\n   16     <http://www.gnu.org/licenses/>.  */\n   17  \n   18: #ifndef	_SYS_IOCTL_H\n   19: #define	_SYS_IOCTL_H	1\n   20  \n   21  #include <features.h>\n   ..\n   23  __BEGIN_DECLS\n   24  \n   25: /* Get the list of `ioctl' requests and related constants.  */\n   26: #include <bits/ioctls.h>\n   27  \n   28: /* Define some types used by `ioctl' requests.  */\n   29: #include <bits/ioctl-types.h>\n   30  \n   31: /* On a Unix system, the system <sys/ioctl.h> probably defines some of\n   32     the symbols we define in <sys/ttydefaults.h> (usually with the same\n   33:    values).  The code to generate <bits/ioctls.h> has omitted these\n   34:    symbols to avoid the conflict, but a Unix program expects <sys/ioctl.h>\n   35     to define them, so we must include <sys/ttydefaults.h> here.  */\n   36  #include <sys/ttydefaults.h>\n   ..\n   39     One argument may follow; its presence and type depend on REQUEST.\n   40     Return value depends on REQUEST.  Usually -1 indicates error.  */\n   41: extern int ioctl (int __fd, unsigned long int __request, ...) __THROW;\n   42  \n   43  __END_DECLS\n   44  \n   45: #endif /* sys/ioctl.h */\n   46  \n\n/usr/include/x86_64-linux-gnu/sys/mount.h:\n   23  \n   24  #include <features.h>\n   25: #include <sys/ioctl.h>\n   26  \n   27  #define BLOCK_SIZE	1024\n\n/usr/include/x86_64-linux-gnu/sys/mtio.h:\n   24  /* Get necessary definitions from system and kernel headers.  */\n   25  #include <sys/types.h>\n   26: #include <sys/ioctl.h>\n   27  \n   28  \n   ..\n   33      int mt_count;		/* How many of them.  */\n   34    };\n   35: #define _IOT_mtop /* Hurd ioctl type field.  */ \\\n   36    _IOT (_IOTS (short), 1, _IOTS (int), 1, 0, 0)\n   37  \n   ..\n   94      __daddr_t mt_blkno;		/* Current block number.  */\n   95    };\n   96: #define _IOT_mtget /* Hurd ioctl type field.  */ \\\n   97    _IOT (_IOTS (long), 7, 0, 0, 0, 0)\n   98  \n   ..\n  159      long int mt_blkno;	/* Current block number.  */\n  160    };\n  161: #define _IOT_mtpos /* Hurd ioctl type field.  */ \\\n  162    _IOT_SIMPLE (long)\n  163  \n  ...\n  190      char reserved[10];\n  191    };\n  192: #define _IOT_mtconfiginfo /* Hurd ioctl type field.  */ \\\n  193    _IOT (_IOTS (long), 2, _IOTS (short), 3, _IOTS (long), 1) /* XXX wrong */\n  194  \n  ...\n  237  #define MT_ST_SOFTERR_MASK	0xffff\n  238  \n  239: /* Bitfields for the MTSETDRVBUFFER ioctl.  */\n  240  #define MT_ST_OPTIONS		0xf0000000\n  241  #define MT_ST_BOOLEANS		0x10000000\n\n/usr/include/x86_64-linux-gnu/sys/raw.h:\n   20  \n   21  #include <stdint.h>\n   22: #include <sys/ioctl.h>\n   23  \n   24  /* The major device number for raw devices.  */\n   25  #define RAW_MAJOR	162\n   26  \n   27: /* `ioctl' commands for raw devices.  */\n   28  #define RAW_SETBIND     _IO(0xac, 0)\n   29  #define RAW_GETBIND     _IO(0xac, 1)\n\n/usr/include/xen/evtchn.h:\n   38   * Return allocated port.\n   39   */\n   40: #define IOCTL_EVTCHN_BIND_VIRQ				\\\n   41: 	_IOC(_IOC_NONE, 'E', 0, sizeof(struct ioctl_evtchn_bind_virq))\n   42: struct ioctl_evtchn_bind_virq {\n   43  	unsigned int virq;\n   44  };\n   ..\n   48   * Return allocated port.\n   49   */\n   50: #define IOCTL_EVTCHN_BIND_INTERDOMAIN			\\\n   51: 	_IOC(_IOC_NONE, 'E', 1, sizeof(struct ioctl_evtchn_bind_interdomain))\n   52: struct ioctl_evtchn_bind_interdomain {\n   53  	unsigned int remote_domain, remote_port;\n   54  };\n   ..\n   58   * Return allocated port.\n   59   */\n   60: #define IOCTL_EVTCHN_BIND_UNBOUND_PORT			\\\n   61: 	_IOC(_IOC_NONE, 'E', 2, sizeof(struct ioctl_evtchn_bind_unbound_port))\n   62: struct ioctl_evtchn_bind_unbound_port {\n   63  	unsigned int remote_domain;\n   64  };\n   ..\n   67   * Unbind previously allocated @port.\n   68   */\n   69: #define IOCTL_EVTCHN_UNBIND				\\\n   70: 	_IOC(_IOC_NONE, 'E', 3, sizeof(struct ioctl_evtchn_unbind))\n   71: struct ioctl_evtchn_unbind {\n   72  	unsigned int port;\n   73  };\n   ..\n   76   * Unbind previously allocated @port.\n   77   */\n   78: #define IOCTL_EVTCHN_NOTIFY				\\\n   79: 	_IOC(_IOC_NONE, 'E', 4, sizeof(struct ioctl_evtchn_notify))\n   80: struct ioctl_evtchn_notify {\n   81  	unsigned int port;\n   82  };\n   83  \n   84  /* Clear and reinitialise the event buffer. Clear error condition. */\n   85: #define IOCTL_EVTCHN_RESET				\\\n   86  	_IOC(_IOC_NONE, 'E', 5, 0)\n   87  \n\n/usr/include/xen/privcmd.h:\n   75  \n   76  /*\n   77:  * @cmd: IOCTL_PRIVCMD_HYPERCALL\n   78   * @arg: &privcmd_hypercall_t\n   79   * Return: Value returned from execution of the specified hypercall.\n   80   *\n   81:  * @cmd: IOCTL_PRIVCMD_MMAPBATCH_V2\n   82   * @arg: &struct privcmd_mmapbatch_v2\n   83   * Return: 0 on success (i.e., arg->err contains valid error codes for\n   ..\n   87   * -ENOENT, then -1 is returned and errno is set to ENOENT.\n   88   */\n   89: #define IOCTL_PRIVCMD_HYPERCALL					\\\n   90  	_IOC(_IOC_NONE, 'P', 0, sizeof(struct privcmd_hypercall))\n   91: #define IOCTL_PRIVCMD_MMAP					\\\n   92  	_IOC(_IOC_NONE, 'P', 2, sizeof(struct privcmd_mmap))\n   93: #define IOCTL_PRIVCMD_MMAPBATCH					\\\n   94  	_IOC(_IOC_NONE, 'P', 3, sizeof(struct privcmd_mmapbatch))\n   95: #define IOCTL_PRIVCMD_MMAPBATCH_V2				\\\n   96  	_IOC(_IOC_NONE, 'P', 4, sizeof(struct privcmd_mmapbatch_v2))\n   97  \n\n/home/jack/projects/opensource/bluez/ChangeLog:\n 1995  \n 1996  ver 2.0-pre8:\n 1997: 	Additional HCI ioctls and defines.\n 1998  	All strings and buffers are allocated dynamically.\n 1999  	ba2str, str2ba automatically swap bdaddress.\n 2000: 	Additional hciconfig commands. Support for ACL and SCO MTU ioctls.\n 2001  	Support for Inventel and COM1 UART based devices.\n 2002  	Minor hcitool fixes.\n\n/home/jack/projects/opensource/bluez/autoscan.log:\n 2556  	src/adapter.c:36\n 2557  	src/textfile.c:35\n 2558: autoscan: warning: missing AC_CHECK_HEADERS([sys/ioctl.h]) wanted by: \n 2559  	src/uinput.h:33\n 2560  	src/adapter.c:35\n\n/home/jack/projects/opensource/bluez/configure.scan:\n   20  # Checks for header files.\n   21  AC_FUNC_ALLOCA\n   22: AC_CHECK_HEADERS([arpa/inet.h fcntl.h inttypes.h limits.h malloc.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h strings.h sys/file.h sys/ioctl.h sys/param.h sys/socket.h sys/statvfs.h sys/time.h syslog.h termios.h unistd.h])\n   23  \n   24  # Checks for typedefs, structures, and compiler characteristics.\n\n/home/jack/projects/opensource/bluez/android/avctp.c:\n  743  		DBG(\"AVCTP: closing uinput\");\n  744  \n  745: 		ioctl(session->uinput, UI_DEV_DESTROY);\n  746  		close(session->uinput);\n  747  		session->uinput = -1;\n  ...\n 1060  	}\n 1061  \n 1062: 	ioctl(fd, UI_SET_EVBIT, EV_KEY);\n 1063: 	ioctl(fd, UI_SET_EVBIT, EV_REL);\n 1064: 	ioctl(fd, UI_SET_EVBIT, EV_REP);\n 1065: 	ioctl(fd, UI_SET_EVBIT, EV_SYN);\n 1066  \n 1067  	for (i = 0; key_map[i].name != NULL; i++)\n 1068: 		ioctl(fd, UI_SET_KEYBIT, key_map[i].uinput);\n 1069  \n 1070: 	if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n 1071  		err = -errno;\n 1072  		error(\"Can't create uinput device: %s (%d)\",\n\n/home/jack/projects/opensource/bluez/android/bluetoothd.te:\n   28  # Allow user bluetooth apps to use sockets and fds\n   29  allow bluetoothdomain bluetoothd:fd use;\n   30: allow bluetoothdomain bluetoothd:unix_stream_socket { getopt setopt getattr read write ioctl shutdown };\n   31  \n   32  # Other domains that can create and use bluetooth sockets.\n   ..\n   45  # tethering\n   46  allow bluetoothd self:udp_socket create_socket_perms;\n   47: allow bluetoothd self:tcp_socket { create ioctl };\n   48  \n\n/home/jack/projects/opensource/bluez/android/main.c:\n  657  	 * CAP_NET_ADMIN: Allow use of MGMT interface\n  658  	 * CAP_NET_BIND_SERVICE: Allow use of privileged PSM\n  659: 	 * CAP_NET_RAW: Allow use of bnep ioctl calls\n  660  	 */\n  661  	cap.effective = cap.permitted =\n\n/home/jack/projects/opensource/bluez/android/pan.c:\n   32  #include <fcntl.h>\n   33  #include <glib.h>\n   34: #include <sys/ioctl.h>\n   35  #include <sys/socket.h>\n   36  #include <sys/wait.h>\n   ..\n   92  	ifr.ifr_data = (char *) args;\n   93  \n   94: 	if (ioctl(sk, SIOCDEVPRIVATE, &ifr) < 0) {\n   95  		error(\"pan: setting forward delay failed: %d (%s)\",\n   96  							errno, strerror(errno));\n   ..\n  114  		return -EOPNOTSUPP;\n  115  \n  116: 	if (ioctl(sk, SIOCBRADDBR, BNEP_BRIDGE) < 0) {\n  117  		err = -errno;\n  118  		if (err != -EEXIST) {\n  ...\n  124  	err = set_forward_delay(sk);\n  125  	if (err < 0)\n  126: 		ioctl(sk, SIOCBRDELBR, BNEP_BRIDGE);\n  127  \n  128  	close(sk);\n  ...\n  146  \n  147  	/* Bring down the interface */\n  148: 	err = ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);\n  149  \n  150  	close(sk);\n  ...\n  173  		return -EOPNOTSUPP;\n  174  \n  175: 	err = ioctl(sk, SIOCBRDELBR, BNEP_BRIDGE);\n  176  	if (err < 0)\n  177  		err = -errno;\n\n~/projects/opensource/bluez/attrib/gatttool:\n    <binary>\n\n/home/jack/projects/opensource/bluez/emulator/server.c:\n   34  #include <string.h>\n   35  #include <sys/epoll.h>\n   36: #include <sys/ioctl.h>\n   37  #include <sys/socket.h>\n   38  #include <sys/un.h>\n\n~/projects/opensource/bluez/lib/.hci.h.swp:\n    <binary>\n\n/home/jack/projects/opensource/bluez/lib/bnep.h:\n  122  } __attribute__((packed));\n  123  \n  124: /* BNEP ioctl defines */\n  125  #define BNEPCONNADD	_IOW('B', 200, int)\n  126  #define BNEPCONNDEL	_IOW('B', 201, int)\n\n/home/jack/projects/opensource/bluez/lib/cmtp.h:\n   33  #define CMTP_DEFAULT_MTU 672\n   34  \n   35: /* CMTP ioctl defines */\n   36  #define CMTPCONNADD	_IOW('C', 200, int)\n   37  #define CMTPCONNDEL	_IOW('C', 201, int)\n\n/home/jack/projects/opensource/bluez/lib/hci.c:\n   39  #include <sys/uio.h>\n   40  #include <sys/types.h>\n   41: #include <sys/ioctl.h>\n   42  #include <sys/socket.h>\n   43  \n   ..\n  850  	dr = dl->dev_req;\n  851  \n  852: 	if (ioctl(sk, HCIGETDEVLIST, (void *) dl) < 0) {\n  853  		err = errno;\n  854  		goto free;\n  ...\n  880  	struct hci_dev_info di = { .dev_id = dev_id };\n  881  \n  882: 	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))\n  883  		return 0;\n  884  \n  ...\n  893  	struct hci_dev_info di = { .dev_id = dev_id };\n  894  \n  895: 	if (ioctl(dd, HCIGETDEVINFO, (void *) &di))\n  896  		return 0;\n  897  \n  ...\n  941  \n  942  	di->dev_id = dev_id;\n  943: 	ret = ioctl(dd, HCIGETDEVINFO, (void *) di);\n  944  \n  945  	err = errno;\n  ...\n 1012  	}\n 1013  \n 1014: 	ret = ioctl(dd, HCIINQUIRY, (unsigned long) buf);\n 1015  	if (ret < 0)\n 1016  		goto free;\n\n/home/jack/projects/opensource/bluez/lib/hci.h:\n   82  };\n   83  \n   84: /* HCI ioctl defines */\n   85  #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   ..\n 2361  #define HCI_FLT_OCF_BITS	127\n 2362  \n 2363: /* Ioctl requests structures */\n 2364  struct hci_dev_stats {\n 2365  	uint32_t err_rx;\n\n/home/jack/projects/opensource/bluez/lib/hidp.h:\n   33  #define HIDP_DEFAULT_MTU 48\n   34  \n   35: /* HIDP ioctl defines */\n   36  #define HIDPCONNADD	_IOW('H', 200, int)\n   37  #define HIDPCONNDEL	_IOW('H', 201, int)\n\n/home/jack/projects/opensource/bluez/lib/.deps/hci.Plo:\n   67   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   68   /usr/include/asm-generic/param.h /usr/include/x86_64-linux-gnu/sys/uio.h \\\n   69:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   70:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   71:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   72:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   73:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   74:  /usr/include/asm-generic/ioctl.h \\\n   75:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   76   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   77   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  265  /usr/include/x86_64-linux-gnu/sys/uio.h:\n  266  \n  267: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  268  \n  269: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  270  \n  271: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  272  \n  273: /usr/include/asm-generic/ioctls.h:\n  274  \n  275: /usr/include/linux/ioctl.h:\n  276  \n  277: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  278  \n  279: /usr/include/asm-generic/ioctl.h:\n  280  \n  281: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  282  \n  283  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/bnep.h:\n  122  } __attribute__((packed));\n  123  \n  124: /* BNEP ioctl defines */\n  125  #define BNEPCONNADD	_IOW('B', 200, int)\n  126  #define BNEPCONNDEL	_IOW('B', 201, int)\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/cmtp.h:\n   33  #define CMTP_DEFAULT_MTU 672\n   34  \n   35: /* CMTP ioctl defines */\n   36  #define CMTPCONNADD	_IOW('C', 200, int)\n   37  #define CMTPCONNDEL	_IOW('C', 201, int)\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/hci.h:\n   82  };\n   83  \n   84: /* HCI ioctl defines */\n   85  #define HCIDEVUP	_IOW('H', 201, int)\n   86  #define HCIDEVDOWN	_IOW('H', 202, int)\n   ..\n 2361  #define HCI_FLT_OCF_BITS	127\n 2362  \n 2363: /* Ioctl requests structures */\n 2364  struct hci_dev_stats {\n 2365  	uint32_t err_rx;\n\n/home/jack/projects/opensource/bluez/lib/bluetooth/hidp.h:\n   33  #define HIDP_DEFAULT_MTU 48\n   34  \n   35: /* HIDP ioctl defines */\n   36  #define HIDPCONNADD	_IOW('H', 200, int)\n   37  #define HIDPCONNDEL	_IOW('H', 201, int)\n\n~/projects/opensource/bluez/monitor/btmon:\n    <binary>\n\n/home/jack/projects/opensource/bluez/monitor/display.c:\n   35  #include <sys/wait.h>\n   36  #include <sys/prctl.h>\n   37: #include <sys/ioctl.h>\n   38  #include <termios.h>\n   39  \n   ..\n   59  		struct winsize ws;\n   60  \n   61: 		if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) < 0 ||\n   62  								ws.ws_col == 0)\n   63  			cached_num_columns = FALLBACK_TERMINAL_WIDTH;\n\n/home/jack/projects/opensource/bluez/monitor/hcidump.c:\n   32  #include <stdlib.h>\n   33  #include <string.h>\n   34: #include <sys/ioctl.h>\n   35  #include <sys/socket.h>\n   36  \n   ..\n  206  	di.dev_id = index;\n  207  \n  208: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0) {\n  209  		perror(\"Failed to get device information\");\n  210  		return;\n  ...\n  235  	dr = dl->dev_req;\n  236  \n  237: 	if (ioctl(fd, HCIGETDEVLIST, (void *) dl) < 0) {\n  238  		perror(\"Failed to get device list\");\n  239  		goto done;\n\n/home/jack/projects/opensource/bluez/monitor/.deps/display.Po:\n   49   /usr/include/x86_64-linux-gnu/sys/wait.h \\\n   50   /usr/include/x86_64-linux-gnu/sys/prctl.h /usr/include/linux/prctl.h \\\n   51:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   52:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   53:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   54:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   55:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   56:  /usr/include/asm-generic/ioctl.h \\\n   57:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   58   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h /usr/include/termios.h \\\n   59   /usr/include/x86_64-linux-gnu/bits/termios.h monitor/display.h \\\n   ..\n  194  /usr/include/linux/prctl.h:\n  195  \n  196: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  197  \n  198: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  199  \n  200: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  201  \n  202: /usr/include/asm-generic/ioctls.h:\n  203  \n  204: /usr/include/linux/ioctl.h:\n  205  \n  206: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  207  \n  208: /usr/include/asm-generic/ioctl.h:\n  209  \n  210: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  211  \n  212  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/monitor/.deps/hcidump.Po:\n   40   /usr/include/x86_64-linux-gnu/bits/string2.h \\\n   41   /usr/include/x86_64-linux-gnu/bits/string3.h \\\n   42:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   43:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   44:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   45:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   46:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   47:  /usr/include/asm-generic/ioctl.h \\\n   48:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   49   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   50   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  187  /usr/include/x86_64-linux-gnu/bits/string3.h:\n  188  \n  189: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  190  \n  191: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  192  \n  193: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  194  \n  195: /usr/include/asm-generic/ioctls.h:\n  196  \n  197: /usr/include/linux/ioctl.h:\n  198  \n  199: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  200  \n  201: /usr/include/asm-generic/ioctl.h:\n  202  \n  203: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  204  \n  205  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n~/projects/opensource/bluez/obexd/src/obexd:\n    <binary>\n\n/home/jack/projects/opensource/bluez/plugins/sixaxis.c:\n   33  #include <unistd.h>\n   34  #include <stdlib.h>\n   35: #include <sys/ioctl.h>\n   36  #include <linux/hidraw.h>\n   37  #include <linux/input.h>\n   ..\n   96  	buf[0] = 0xf2;\n   97  \n   98: 	ret = ioctl(fd, HIDIOCGFEATURE(sizeof(buf)), buf);\n   99  	if (ret < 0) {\n  100  		error(\"sixaxis: failed to read device address (%s)\",\n  ...\n  117  	buf[0] = 0xf5;\n  118  \n  119: 	ret = ioctl(fd, HIDIOCGFEATURE(sizeof(buf)), buf);\n  120  	if (ret < 0) {\n  121  		error(\"sixaxis: failed to read master address (%s)\",\n  ...\n  139  	baswap((bdaddr_t *) (buf + 2), bdaddr);\n  140  \n  141: 	ret = ioctl(fd, HIDIOCSFEATURE(sizeof(buf)), buf);\n  142  	if (ret < 0)\n  143  		error(\"sixaxis: failed to write master address (%s)\",\n\n/home/jack/projects/opensource/bluez/profiles/audio/avctp.c:\n  563  		DBG(\"AVCTP: closing uinput for %s\", address);\n  564  \n  565: 		ioctl(session->uinput, UI_DEV_DESTROY);\n  566  		close(session->uinput);\n  567  		session->uinput = -1;\n  ...\n 1079  	}\n 1080  \n 1081: 	ioctl(fd, UI_SET_EVBIT, EV_KEY);\n 1082: 	ioctl(fd, UI_SET_EVBIT, EV_REL);\n 1083: 	ioctl(fd, UI_SET_EVBIT, EV_REP);\n 1084: 	ioctl(fd, UI_SET_EVBIT, EV_SYN);\n 1085  \n 1086  	for (i = 0; key_map[i].name != NULL; i++)\n 1087: 		ioctl(fd, UI_SET_KEYBIT, key_map[i].uinput);\n 1088  \n 1089: 	if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {\n 1090  		err = -errno;\n 1091  		error(\"Can't create uinput device: %s (%d)\",\n\n/home/jack/projects/opensource/bluez/profiles/audio/.deps/bluetoothd-avctp.Po:\n  162   /usr/include/dbus-1.0/dbus/dbus-threads.h src/device.h src/log.h \\\n  163   src/error.h src/uinput.h /usr/include/x86_64-linux-gnu/sys/time.h \\\n  164:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n  165:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n  166:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n  167:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n  168:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n  169:  /usr/include/asm-generic/ioctl.h \\\n  170:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n  171   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h profiles/audio/avctp.h \\\n  172   profiles/audio/avrcp.h\n  ...\n  594  /usr/include/x86_64-linux-gnu/sys/time.h:\n  595  \n  596: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  597  \n  598: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  599  \n  600: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  601  \n  602: /usr/include/asm-generic/ioctls.h:\n  603  \n  604: /usr/include/linux/ioctl.h:\n  605  \n  606: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  607  \n  608: /usr/include/asm-generic/ioctl.h:\n  609  \n  610: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  611  \n  612  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n~/projects/opensource/bluez/profiles/cups/bluetooth:\n    <binary>\n\n/home/jack/projects/opensource/bluez/profiles/input/device.c:\n   32  #include <fcntl.h>\n   33  #include <unistd.h>\n   34: #include <sys/ioctl.h>\n   35  \n   36  #include \"lib/bluetooth.h\"\n   ..\n  765  }\n  766  \n  767: static int ioctl_connadd(struct hidp_connadd_req *req)\n  768  {\n  769  	int ctl, err = 0;\n  ...\n  773  		return -errno;\n  774  \n  775: 	if (ioctl(ctl, HIDPCONNADD, req) < 0)\n  776  		err = -errno;\n  777  \n  ...\n  781  }\n  782  \n  783: static bool ioctl_is_connected(struct input_device *idev)\n  784  {\n  785  	struct hidp_conninfo ci;\n  ...\n  795  	memset(&ci, 0, sizeof(ci));\n  796  	bacpy(&ci.bdaddr, &idev->dst);\n  797: 	if (ioctl(ctl, HIDPGETCONNINFO, &ci) < 0) {\n  798  		error(\"Can't get HIDP connection info\");\n  799  		close(ctl);\n  ...\n  809  }\n  810  \n  811: static int ioctl_disconnect(struct input_device *idev, uint32_t flags)\n  812  {\n  813  	struct hidp_conndel_req req;\n  ...\n  823  	memset(&ci, 0, sizeof(ci));\n  824  	bacpy(&ci.bdaddr, &idev->dst);\n  825: 	if ((ioctl(ctl, HIDPGETCONNINFO, &ci) < 0) ||\n  826  						(ci.state != BT_CONNECTED)) {\n  827  		close(ctl);\n  ...\n  832  	bacpy(&req.bdaddr, &idev->dst);\n  833  	req.flags = flags;\n  834: 	if (ioctl(ctl, HIDPCONNDEL, &req) < 0) {\n  835  		err = -errno;\n  836  		error(\"Can't delete the HID device: %s (%d)\",\n  ...\n  891  		err = uhid_connadd(idev, idev->req);\n  892  	else\n  893: 		err = ioctl_connadd(idev->req);\n  894  \n  895  	if (err < 0) {\n  896: 		error(\"ioctl_connadd(): %s (%d)\", strerror(-err), -err);\n  897  \n  898  		if (idev->ctrl_io) {\n  ...\n  992  		err = uhid_connadd(idev, req);\n  993  	else\n  994: 		err = ioctl_connadd(req);\n  995  \n  996  cleanup:\n  ...\n 1006  		return (idev->intr_io != NULL && idev->ctrl_io != NULL);\n 1007  	else\n 1008: 		return ioctl_is_connected(idev);\n 1009  }\n 1010  \n ....\n 1023  		return 0;\n 1024  	else\n 1025: 		return ioctl_disconnect(idev, flags);\n 1026  }\n 1027  \n\n/home/jack/projects/opensource/bluez/profiles/input/.deps/bluetoothd-device.Po:\n   37   /usr/include/x86_64-linux-gnu/bits/confname.h /usr/include/getopt.h \\\n   38   /usr/include/x86_64-linux-gnu/bits/unistd.h \\\n   39:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   40:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   41:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   42:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   43:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   44:  /usr/include/asm-generic/ioctl.h \\\n   45:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   46   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h lib/bluetooth.h \\\n   47   /usr/include/stdio.h /usr/include/libio.h /usr/include/_G_config.h \\\n   ..\n  282  /usr/include/x86_64-linux-gnu/bits/unistd.h:\n  283  \n  284: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  285  \n  286: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  287  \n  288: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  289  \n  290: /usr/include/asm-generic/ioctls.h:\n  291  \n  292: /usr/include/linux/ioctl.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  295  \n  296: /usr/include/asm-generic/ioctl.h:\n  297  \n  298: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  299  \n  300  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/profiles/input/.deps/bluetoothd-hog.Po:\n  164   profiles/input/uhid_copy.h /usr/include/linux/input.h \\\n  165   /usr/include/x86_64-linux-gnu/sys/time.h \\\n  166:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n  167:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n  168:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n  169:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n  170:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n  171:  /usr/include/asm-generic/ioctl.h \\\n  172:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n  173   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n  174   /usr/include/linux/types.h /usr/include/x86_64-linux-gnu/asm/types.h \\\n  ...\n  607  /usr/include/x86_64-linux-gnu/sys/time.h:\n  608  \n  609: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  610  \n  611: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  612  \n  613: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  614  \n  615: /usr/include/asm-generic/ioctls.h:\n  616  \n  617: /usr/include/linux/ioctl.h:\n  618  \n  619: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  620  \n  621: /usr/include/asm-generic/ioctl.h:\n  622  \n  623: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  624  \n  625  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/profiles/network/bnep.c:\n   31  #include <stdlib.h>\n   32  #include <sys/param.h>\n   33: #include <sys/ioctl.h>\n   34  #include <sys/socket.h>\n   35  #include <sys/wait.h>\n   ..\n  106  	baswap((bdaddr_t *)&req.dst, dst);\n  107  	req.flags = 0;\n  108: 	if (ioctl(ctl, BNEPCONNDEL, &req) < 0) {\n  109  		int err = -errno;\n  110  		error(\"bnep: Failed to kill connection: %s (%d)\",\n  ...\n  125  	req.sock = sk;\n  126  	req.role = role;\n  127: 	if (ioctl(ctl, BNEPCONNADD, &req) < 0) {\n  128  		int err = -errno;\n  129  		error(\"bnep: Failed to add device %s: %s(%d)\",\n  ...\n  149  	ifr.ifr_flags |= IFF_MULTICAST;\n  150  \n  151: 	if (ioctl(sk, SIOCSIFFLAGS, (void *) &ifr) < 0) {\n  152  		err = -errno;\n  153  		error(\"bnep: Could not bring up %s: %s(%d)\",\n  ...\n  173  \n  174  	/* Bring down the interface */\n  175: 	if (ioctl(sk, SIOCSIFFLAGS, (void *) &ifr) < 0) {\n  176  		err = -errno;\n  177  		error(\"bnep: Could not bring down %s: %s(%d)\",\n  ...\n  441  	ifr.ifr_ifindex = ifindex;\n  442  \n  443: 	if (ioctl(sk, SIOCBRADDIF, &ifr) < 0) {\n  444  		err = -errno;\n  445  		error(\"bnep: Can't add %s to the bridge %s: %s(%d)\",\n  ...\n  473  	ifr.ifr_ifindex = ifindex;\n  474  \n  475: 	if (ioctl(sk, SIOCBRDELIF, &ifr) < 0) {\n  476  		err = -errno;\n  477  		error(\"bnep: Can't delete %s from the bridge %s: %s(%d)\",\n\n/home/jack/projects/opensource/bluez/profiles/network/.deps/bluetoothd-bnep.Po:\n   55   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   56   /usr/include/asm-generic/param.h \\\n   57:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   58:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   59:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   60:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   61:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   62:  /usr/include/asm-generic/ioctl.h \\\n   63:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   64   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   65   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  299  /usr/include/asm-generic/param.h:\n  300  \n  301: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  302  \n  303: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  304  \n  305: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  306  \n  307: /usr/include/asm-generic/ioctls.h:\n  308  \n  309: /usr/include/linux/ioctl.h:\n  310  \n  311: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  312  \n  313: /usr/include/asm-generic/ioctl.h:\n  314  \n  315: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  316  \n  317  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/src/adapter.c:\n   33  #include <stdlib.h>\n   34  #include <stdbool.h>\n   35: #include <sys/ioctl.h>\n   36  #include <sys/file.h>\n   37  #include <sys/stat.h>\n\n/home/jack/projects/opensource/bluez/src/agent.c:\n   32  #include <stdbool.h>\n   33  #include <sys/socket.h>\n   34: #include <sys/ioctl.h>\n   35  \n   36  #include <glib.h>\n\n~/projects/opensource/bluez/src/bluetoothd:\n    <binary>\n\n/home/jack/projects/opensource/bluez/src/service.c:\n   33  #include <stdbool.h>\n   34  #include <sys/stat.h>\n   35: #include <sys/ioctl.h>\n   36  #include <errno.h>\n   37  \n\n/home/jack/projects/opensource/bluez/src/uinput.h:\n   31  #include <stdint.h>\n   32  #include <sys/time.h>\n   33: #include <sys/ioctl.h>\n   34  \n   35  /* Events */\n   ..\n  672  /* User input interface */\n  673  \n  674: #define UINPUT_IOCTL_BASE	'U'\n  675  \n  676: #define UI_DEV_CREATE		_IO(UINPUT_IOCTL_BASE, 1)\n  677: #define UI_DEV_DESTROY		_IO(UINPUT_IOCTL_BASE, 2)\n  678  \n  679: #define UI_SET_EVBIT		_IOW(UINPUT_IOCTL_BASE, 100, int)\n  680: #define UI_SET_KEYBIT		_IOW(UINPUT_IOCTL_BASE, 101, int)\n  681: #define UI_SET_RELBIT		_IOW(UINPUT_IOCTL_BASE, 102, int)\n  682: #define UI_SET_ABSBIT		_IOW(UINPUT_IOCTL_BASE, 103, int)\n  683: #define UI_SET_MSCBIT		_IOW(UINPUT_IOCTL_BASE, 104, int)\n  684: #define UI_SET_LEDBIT		_IOW(UINPUT_IOCTL_BASE, 105, int)\n  685: #define UI_SET_SNDBIT		_IOW(UINPUT_IOCTL_BASE, 106, int)\n  686: #define UI_SET_FFBIT		_IOW(UINPUT_IOCTL_BASE, 107, int)\n  687: #define UI_SET_PHYS		_IOW(UINPUT_IOCTL_BASE, 108, char*)\n  688: #define UI_SET_SWBIT		_IOW(UINPUT_IOCTL_BASE, 109, int)\n  689  \n  690  #ifndef NBITS\n\n/home/jack/projects/opensource/bluez/src/.deps/bluetoothd-adapter.Po:\n   40   /usr/include/x86_64-linux-gnu/bits/stdlib.h \\\n   41   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdbool.h \\\n   42:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   43:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   44:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   45:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   46:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   47:  /usr/include/asm-generic/ioctl.h \\\n   48:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   49   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   50   /usr/include/x86_64-linux-gnu/sys/file.h /usr/include/fcntl.h \\\n   ..\n  292  /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdbool.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  295  \n  296: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  297  \n  298: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  299  \n  300: /usr/include/asm-generic/ioctls.h:\n  301  \n  302: /usr/include/linux/ioctl.h:\n  303  \n  304: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  305  \n  306: /usr/include/asm-generic/ioctl.h:\n  307  \n  308: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  309  \n  310  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/src/.deps/bluetoothd-agent.Po:\n   45   /usr/include/asm-generic/sockios.h \\\n   46   /usr/include/x86_64-linux-gnu/bits/socket2.h \\\n   47:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   48:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   49:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   50:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   51:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   52:  /usr/include/asm-generic/ioctl.h \\\n   53:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   54   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   55   /usr/include/glib-2.0/glib.h /usr/include/glib-2.0/glib/galloca.h \\\n   ..\n  280  /usr/include/x86_64-linux-gnu/bits/socket2.h:\n  281  \n  282: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  283  \n  284: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  285  \n  286: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  287  \n  288: /usr/include/asm-generic/ioctls.h:\n  289  \n  290: /usr/include/linux/ioctl.h:\n  291  \n  292: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  293  \n  294: /usr/include/asm-generic/ioctl.h:\n  295  \n  296: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  297  \n  298  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/src/.deps/bluetoothd-service.Po:\n   41   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdbool.h \\\n   42   /usr/include/x86_64-linux-gnu/sys/stat.h \\\n   43:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   44:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   45:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   46:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   47:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   48:  /usr/include/asm-generic/ioctl.h \\\n   49:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   50   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h /usr/include/errno.h \\\n   51   /usr/include/x86_64-linux-gnu/bits/errno.h /usr/include/linux/errno.h \\\n   ..\n  282  /usr/include/x86_64-linux-gnu/sys/stat.h:\n  283  \n  284: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  285  \n  286: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  287  \n  288: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  289  \n  290: /usr/include/asm-generic/ioctls.h:\n  291  \n  292: /usr/include/linux/ioctl.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  295  \n  296: /usr/include/asm-generic/ioctl.h:\n  297  \n  298: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  299  \n  300  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/src/shared/.deps/uhid.Plo:\n   51   src/shared/queue.h src/shared/uhid.h profiles/input/uhid_copy.h \\\n   52   /usr/include/linux/input.h /usr/include/x86_64-linux-gnu/sys/time.h \\\n   53:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   54:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   55:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   56:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   57:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   58:  /usr/include/asm-generic/ioctl.h \\\n   59:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   60   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   61   /usr/include/linux/types.h /usr/include/x86_64-linux-gnu/asm/types.h \\\n   ..\n  218  /usr/include/x86_64-linux-gnu/sys/time.h:\n  219  \n  220: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  221  \n  222: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  223  \n  224: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  225  \n  226: /usr/include/asm-generic/ioctls.h:\n  227  \n  228: /usr/include/linux/ioctl.h:\n  229  \n  230: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  231  \n  232: /usr/include/asm-generic/ioctl.h:\n  233  \n  234: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  235  \n  236  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/amptest.c:\n   34  #include <stdbool.h>\n   35  #include <poll.h>\n   36: #include <sys/ioctl.h>\n   37  #include <sys/socket.h>\n   38  \n   ..\n   57  	di.dev_id = dev_id;\n   58  \n   59: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0) {\n   60  		perror(\"Failed to get HCI device info\");\n   61  		close(fd);\n   ..\n   64  \n   65  	if (!hci_test_bit(HCI_UP, &di.flags)) {\n   66: 		if (ioctl(fd, HCIDEVUP, dev_id) < 0) {\n   67  			if (errno != EALREADY) {\n   68  				perror(\"Failed to bring up HCI device\");\n   ..\n  515  	dr = dl->dev_req;\n  516  \n  517: 	if (ioctl(fd, HCIGETDEVLIST, (void *) dl) < 0) {\n  518  		perror(\"Failed to get HCI device list\");\n  519  		result = false;\n  ...\n  526  		di.dev_id = (dr + i)->dev_id;\n  527  \n  528: 		if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0)\n  529  			continue;\n  530  \n\n/home/jack/projects/opensource/bluez/tools/avinfo.c:\n   37  #include <stdint.h>\n   38  #include <sys/param.h>\n   39: #include <sys/ioctl.h>\n   40  #include <sys/socket.h>\n   41  \n\n~/projects/opensource/bluez/tools/bccmd:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/bdaddr.c:\n   31  #include <getopt.h>\n   32  #include <unistd.h>\n   33: #include <sys/ioctl.h>\n   34  #include <sys/socket.h>\n   35  \n   ..\n  456  					printf(\"Reset device manually\\n\");\n  457  				} else {\n  458: 					ioctl(dd, HCIDEVRESET, dev);\n  459  					printf(\"Device reset successfully\\n\");\n  460  				}\n  ...\n  463  			}\n  464  \n  465: 			//ioctl(dd, HCIDEVRESET, dev);\n  466: 			//ioctl(dd, HCIDEVDOWN, dev);\n  467: 			//ioctl(dd, HCIDEVUP, dev);\n  468  \n  469  			hci_close_dev(dd);\n\n/home/jack/projects/opensource/bluez/tools/bneptest.c:\n   33  #include <errno.h>\n   34  #include <unistd.h>\n   35: #include <sys/ioctl.h>\n   36  #include <net/if.h>\n   37  #include <linux/sockios.h>\n   ..\n   93  	ifr.ifr_data = (char *) args;\n   94  \n   95: 	if (ioctl(sk, SIOCDEVPRIVATE, &ifr) < 0) {\n   96  		error(\"setting forward delay failed: %d (%s)\",\n   97  							errno, strerror(errno));\n   ..\n  110  		return -EOPNOTSUPP;\n  111  \n  112: 	if (ioctl(sk, SIOCBRADDBR, bridge) < 0) {\n  113  		if (errno != EEXIST) {\n  114  			close(sk);\n  ...\n  120  	if (err < 0) {\n  121  		printf(\"failed to set forward delay\\n\");\n  122: 		ioctl(sk, SIOCBRDELBR, bridge);\n  123  	}\n  124  \n\n/home/jack/projects/opensource/bluez/tools/btattach.c:\n   35  #include <getopt.h>\n   36  #include <termios.h>\n   37: #include <sys/ioctl.h>\n   38  #include <poll.h>\n   39  \n   ..\n   66  	}\n   67  \n   68: 	if (ioctl(fd, TIOCGETD, &saved_ldisc) < 0) {\n   69  		perror(\"Failed get serial line discipline\");\n   70  		close(fd);\n   ..\n   87  	}\n   88  \n   89: 	if (ioctl(fd, TIOCSETD, &ldisc) < 0) {\n   90  		perror(\"Failed set serial line discipline\");\n   91  		close(fd);\n   ..\n  115  		return -1;\n  116  \n  117: 	if (ioctl(fd, HCIUARTSETFLAGS, flags) < 0) {\n  118  		perror(\"Failed to set flags\");\n  119  		close(fd);\n  ...\n  121  	}\n  122  \n  123: 	if (ioctl(fd, HCIUARTSETPROTO, proto) < 0) {\n  124  		perror(\"Failed to set protocol\");\n  125  		close(fd);\n  ...\n  127  	}\n  128  \n  129: 	dev_id = ioctl(fd, HCIUARTGETDEVICE);\n  130  	if (dev_id < 0) {\n  131  		perror(\"Failed to get device id\");\n\n/home/jack/projects/opensource/bluez/tools/btinfo.c:\n   33  #include <string.h>\n   34  #include <getopt.h>\n   35: #include <sys/ioctl.h>\n   36  #include <sys/socket.h>\n   37  \n   ..\n  302  	hci_info.dev_id = index;\n  303  \n  304: 	if (ioctl(fd, HCIGETDEVINFO, (void *) &hci_info) < 0) {\n  305  		perror(\"Failed to get HCI device information\");\n  306  		close(fd);\n  ...\n  311  		printf(\"Powering on controller\\n\");\n  312  \n  313: 		if (ioctl(fd, HCIDEVUP, hci_info.dev_id) < 0) {\n  314  			perror(\"Failed to power on controller\");\n  315  			close(fd);\n  ...\n  355  			printf(\"Powering down controller\\n\");\n  356  \n  357: 			if (ioctl(fd, HCIDEVDOWN, hci_info.dev_id) < 0)\n  358  				perror(\"Failed to power down controller\");\n  359  \n\n~/projects/opensource/bluez/tools/ciptool:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/ciptool.c:\n   34  #include <signal.h>\n   35  #include <poll.h>\n   36: #include <sys/ioctl.h>\n   37  #include <sys/socket.h>\n   38  \n   ..\n  186  	req.flags = flags;\n  187  \n  188: 	if (ioctl(ctl, CMTPCONNADD, &req) < 0) {\n  189  		perror(\"Can't create connection\");\n  190  		exit(1);\n  ...\n  204  	req.ci   = ci;\n  205  \n  206: 	if (ioctl(ctl, CMTPGETCONNLIST, &req) < 0) {\n  207  		perror(\"Can't get connection list\");\n  208  		exit(1);\n  ...\n  304  		cl.ci   = ci;\n  305  \n  306: 		if (ioctl(ctl, CMTPGETCONNLIST, &cl) < 0) {\n  307  			perror(\"Can't get connection list\");\n  308  			exit(1);\n  ...\n  321  		str2ba(argv[1], &req.bdaddr);\n  322  \n  323: 	if (ioctl(ctl, CMTPCONNDEL, &req) < 0) {\n  324  		perror(\"Can't release connection\");\n  325  		exit(1);\n  ...\n  394  \n  395  	bacpy(&req.bdaddr, &dst);\n  396: 	ioctl(ctl, CMTPCONNDEL, &req);\n  397  }\n  398  \n\n/home/jack/projects/opensource/bluez/tools/cltest.c:\n   34  #include <stdbool.h>\n   35  #include <poll.h>\n   36: #include <sys/ioctl.h>\n   37  #include <sys/socket.h>\n   38  \n   ..\n  157  		printf(\"Activating controller %s\\n\", addr);\n  158  \n  159: 		if (ioctl(fd, HCIDEVUP, di->dev_id) < 0) {\n  160  			if (errno != EALREADY) {\n  161  				perror(\"Failed to bring up HCI device\");\n  ...\n  179  		dr.dev_opt = SCAN_PAGE;\n  180  \n  181: 		if (ioctl(fd, HCISETSCAN, (unsigned long) &dr) < 0) {\n  182  			perror(\"Failed to enable connections\");\n  183  			return false;\n  ...\n  213  	dr = dl->dev_req;\n  214  \n  215: 	if (ioctl(fd, HCIGETDEVLIST, (void *) dl) < 0) {\n  216  		perror(\"Failed to get HCI device list\");\n  217  		result = false;\n  ...\n  226  		di.dev_id = (dr + i)->dev_id;\n  227  \n  228: 		if (ioctl(fd, HCIGETDEVINFO, (void *) &di) < 0)\n  229  			continue;\n  230  \n\n/home/jack/projects/opensource/bluez/tools/csr_usb.c:\n   35  #include <dirent.h>\n   36  #include <limits.h>\n   37: #include <sys/ioctl.h>\n   38  \n   39  #include \"csr.h\"\n   ..\n   63  };\n   64  \n   65: #define USBFS_IOCTL_CONTROL	_IOWR('U', 0, struct usbfs_ctrltransfer)\n   66: #define USBFS_IOCTL_BULK	_IOWR('U', 2, struct usbfs_bulktransfer)\n   67: #define USBFS_IOCTL_CLAIMINTF	_IOR('U', 15, unsigned int)\n   68: #define USBFS_IOCTL_RELEASEINTF	_IOR('U', 16, unsigned int)\n   69  \n   70  static int read_value(const char *name, const char *attr, const char *format)\n   ..\n  173  	}\n  174  \n  175: 	if (ioctl(handle, USBFS_IOCTL_CLAIMINTF, &interface) < 0) {\n  176  		fprintf(stderr, \"Can't claim interface: %s (%d)\\n\",\n  177  						strerror(errno), errno);\n  ...\n  197  	transfer.data = data;\n  198  \n  199: 	if (ioctl(fd, USBFS_IOCTL_CONTROL, &transfer) < 0) {\n  200  		fprintf(stderr, \"Control transfer failed: %s (%d)\\n\",\n  201  						strerror(errno), errno);\n  ...\n  216  	transfer.data = data;\n  217  \n  218: 	return ioctl(fd, USBFS_IOCTL_BULK, &transfer);\n  219  }\n  220  \n  ...\n  297  	int interface = 0;\n  298  \n  299: 	ioctl(handle, USBFS_IOCTL_RELEASEINTF, &interface);\n  300  \n  301  	close(handle);\n\n~/projects/opensource/bluez/tools/hciattach:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/hciattach.c:\n   41  #include <sys/time.h>\n   42  #include <sys/param.h>\n   43: #include <sys/ioctl.h>\n   44  \n   45  #include \"lib/bluetooth.h\"\n   ..\n 1252  	/* Set TTY to N_HCI line discipline */\n 1253  	i = N_HCI;\n 1254: 	if (ioctl(fd, TIOCSETD, &i) < 0) {\n 1255  		perror(\"Can't set line discipline\");\n 1256  		goto fail;\n 1257  	}\n 1258  \n 1259: 	if (flags && ioctl(fd, HCIUARTSETFLAGS, flags) < 0) {\n 1260  		perror(\"Can't set UART flags\");\n 1261  		goto fail;\n 1262  	}\n 1263  \n 1264: 	if (ioctl(fd, HCIUARTSETPROTO, u->proto) < 0) {\n 1265  		perror(\"Can't set device\");\n 1266  		goto fail;\n ....\n 1477  	/* Restore TTY line discipline */\n 1478  	ld = N_TTY;\n 1479: 	if (ioctl(n, TIOCSETD, &ld) < 0) {\n 1480  		perror(\"Can't restore line discipline\");\n 1481  		exit(1);\n\n/home/jack/projects/opensource/bluez/tools/hciattach_ath3k.c:\n   32  #include <sys/types.h>\n   33  #include <sys/param.h>\n   34: #include <sys/ioctl.h>\n   35  \n   36  #include \"lib/bluetooth.h\"\n   ..\n  873  	sleep(1);\n  874  \n  875: 	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);\n  876  	if (dev_id < 0) {\n  877  		perror(\"cannot get device id\");\n  ...\n  885  	}\n  886  \n  887: 	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {\n  888  		perror(\"hci down:Power management Disabled\");\n  889  		hci_close_dev(dd);\n\n/home/jack/projects/opensource/bluez/tools/hciattach_intel.c:\n   33  #include <fcntl.h>\n   34  #include <sys/param.h>\n   35: #include <sys/ioctl.h>\n   36  #include <time.h>\n   37  \n   ..\n  454  	int arg;\n  455  \n  456: 	if (ioctl(dev, TIOCMGET, &arg) < 0) {\n  457  		perror(\"cannot get TIOCMGET\");\n  458  		return -errno;\n  ...\n  463  		arg &= ~TIOCM_RTS;\n  464  \n  465: 	if (ioctl(dev, TIOCMSET, &arg) == -1) {\n  466  		perror(\"cannot set TIOCMGET\");\n  467  		return -errno;\n\n/home/jack/projects/opensource/bluez/tools/hciattach_qualcomm.c:\n   40  #include <sys/time.h>\n   41  #include <sys/param.h>\n   42: #include <sys/ioctl.h>\n   43  #include <sys/uio.h>\n   44  \n\n/home/jack/projects/opensource/bluez/tools/hciattach_ti.c:\n   36  #include <sys/types.h>\n   37  #include <sys/param.h>\n   38: #include <sys/ioctl.h>\n   39  \n   40  #include \"lib/bluetooth.h\"\n   ..\n  505  	sleep(1);\n  506  \n  507: 	dev_id = ioctl(fd, HCIUARTGETDEVICE, 0);\n  508  	if (dev_id < 0) {\n  509  		perror(\"cannot get device id\");\n  ...\n  519  	}\n  520  \n  521: 	if (ioctl(dd, HCIDEVUP, dev_id) < 0 && errno != EALREADY) {\n  522  		fprintf(stderr, \"Can't init device hci%d: %s (%d)\", dev_id,\n  523  							strerror(errno), errno);\n\n/home/jack/projects/opensource/bluez/tools/hciattach_tialt.c:\n   39  #include <sys/time.h>\n   40  #include <sys/param.h>\n   41: #include <sys/ioctl.h>\n   42  #include <sys/uio.h>\n   43  \n\n~/projects/opensource/bluez/tools/hciconfig:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/hciconfig.c:\n   36  #include <getopt.h>\n   37  #include <sys/param.h>\n   38: #include <sys/ioctl.h>\n   39  #include <sys/socket.h>\n   40  #include <sys/stat.h>\n   ..\n   68  	dr = dl->dev_req;\n   69  \n   70: 	if (ioctl(ctl, HCIGETDEVLIST, (void *) dl) < 0) {\n   71  		perror(\"Can't get device list\");\n   72  		exit(1);\n   ..\n   75  	for (i = 0; i< dl->dev_num; i++) {\n   76  		di.dev_id = (dr+i)->dev_id;\n   77: 		if (ioctl(ctl, HCIGETDEVINFO, (void *) &di) < 0)\n   78  			continue;\n   79  		print_dev_info(ctl, &di);\n   ..\n  165  {\n  166  	/* Reset HCI device stat counters */\n  167: 	if (ioctl(ctl, HCIDEVRESTAT, hdev) < 0) {\n  168  		fprintf(stderr, \"Can't reset stats counters hci%d: %s (%d)\\n\",\n  169  						hdev, strerror(errno), errno);\n  ...\n  185  		dr.dev_opt = SCAN_PAGE | SCAN_INQUIRY;\n  186  \n  187: 	if (ioctl(ctl, HCISETSCAN, (unsigned long) &dr) < 0) {\n  188  		fprintf(stderr, \"Can't set scan mode on hci%d: %s (%d)\\n\",\n  189  						hdev, strerror(errno), errno);\n  ...\n  446  		dr.dev_opt = AUTH_DISABLED;\n  447  \n  448: 	if (ioctl(ctl, HCISETAUTH, (unsigned long) &dr) < 0) {\n  449  		fprintf(stderr, \"Can't set auth on hci%d: %s (%d)\\n\",\n  450  						hdev, strerror(errno), errno);\n  ...\n  463  		dr.dev_opt = ENCRYPT_DISABLED;\n  464  \n  465: 	if (ioctl(ctl, HCISETENCRYPT, (unsigned long) &dr) < 0) {\n  466  		fprintf(stderr, \"Can't set encrypt on hci%d: %s (%d)\\n\",\n  467  						hdev, strerror(errno), errno);\n  ...\n  473  {\n  474  	/* Start HCI device */\n  475: 	if (ioctl(ctl, HCIDEVUP, hdev) < 0) {\n  476  		if (errno == EALREADY)\n  477  			return;\n  ...\n  485  {\n  486  	/* Stop HCI device */\n  487: 	if (ioctl(ctl, HCIDEVDOWN, hdev) < 0) {\n  488  		fprintf(stderr, \"Can't down device hci%d: %s (%d)\\n\",\n  489  						hdev, strerror(errno), errno);\n  ...\n  496  	/* Reset HCI device */\n  497  #if 0\n  498: 	if (ioctl(ctl, HCIDEVRESET, hdev) < 0 ){\n  499  		fprintf(stderr, \"Reset failed for device hci%d: %s (%d)\\n\",\n  500  						hdev, strerror(errno), errno);\n  ...\n  513  \n  514  	if (hci_strtoptype(opt, &dr.dev_opt)) {\n  515: 		if (ioctl(ctl, HCISETPTYPE, (unsigned long) &dr) < 0) {\n  516  			fprintf(stderr, \"Can't set pkttype on hci%d: %s (%d)\\n\",\n  517  						hdev, strerror(errno), errno);\n  ...\n  531  \n  532  	if (hci_strtolp(opt, &dr.dev_opt)) {\n  533: 		if (ioctl(ctl, HCISETLINKPOL, (unsigned long) &dr) < 0) {\n  534  			fprintf(stderr, \"Can't set link policy on hci%d: %s (%d)\\n\",\n  535  						hdev, strerror(errno), errno);\n  ...\n  549  \n  550  	if (hci_strtolm(opt, &dr.dev_opt)) {\n  551: 		if (ioctl(ctl, HCISETLINKMODE, (unsigned long) &dr) < 0) {\n  552  			fprintf(stderr, \"Can't set default link mode on hci%d: %s (%d)\\n\",\n  553  						hdev, strerror(errno), errno);\n  ...\n  573  	dr.dev_opt = htobl(htobs(mpkt) | (htobs(mtu) << 16));\n  574  \n  575: 	if (ioctl(ctl, HCISETACLMTU, (unsigned long) &dr) < 0) {\n  576  		fprintf(stderr, \"Can't set ACL mtu on hci%d: %s(%d)\\n\",\n  577  						hdev, strerror(errno), errno);\n  ...\n  593  	dr.dev_opt = htobl(htobs(mpkt) | (htobs(mtu) << 16));\n  594  \n  595: 	if (ioctl(ctl, HCISETSCOMTU, (unsigned long) &dr) < 0) {\n  596  		fprintf(stderr, \"Can't set SCO mtu on hci%d: %s (%d)\\n\",\n  597  						hdev, strerror(errno), errno);\n  ...\n 1808  	str2ba(opt, &bdaddr);\n 1809  \n 1810: 	if (ioctl(dd, HCIBLOCKADDR, &bdaddr) < 0) {\n 1811: 		perror(\"ioctl(HCIBLOCKADDR)\");\n 1812  		exit(1);\n 1813  	}\n ....\n 1836  		str2ba(opt, &bdaddr);\n 1837  \n 1838: 	if (ioctl(dd, HCIUNBLOCKADDR, &bdaddr) < 0) {\n 1839: 		perror(\"ioctl(HCIUNBLOCKADDR)\");\n 1840  		exit(1);\n 1841  	}\n ....\n 2010  	argc--; argv++;\n 2011  \n 2012: 	if (ioctl(ctl, HCIGETDEVINFO, (void *) &di)) {\n 2013  		perror(\"Can't get device info\");\n 2014  		exit(1);\n\n~/projects/opensource/bluez/tools/hcidump:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/hcidump.c:\n   37  #include <sys/stat.h>\n   38  #include <sys/types.h>\n   39: #include <sys/ioctl.h>\n   40  #include <sys/socket.h>\n   41  \n\n~/projects/opensource/bluez/tools/hcitool:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/hcitool.c:\n   37  #include <getopt.h>\n   38  #include <sys/param.h>\n   39: #include <sys/ioctl.h>\n   40  #include <sys/socket.h>\n   41  #include <signal.h>\n   ..\n   98  	char addr[18];\n   99  \n  100: 	if (ioctl(s, HCIGETDEVINFO, (void *) &di))\n  101  		return 0;\n  102  \n  ...\n  165  	ci = cl->conn_info;\n  166  \n  167: 	if (ioctl(s, HCIGETCONNLIST, (void *) cl)) {\n  168  		perror(\"Can't get connection list\");\n  169  		exit(1);\n  ...\n  199  	ci = cl->conn_info;\n  200  \n  201: 	if (ioctl(s, HCIGETCONNLIST, (void *) cl)) {\n  202  		perror(\"Can't get connection list\");\n  203  		exit(1);\n  ...\n  717  				bacpy(&cr->bdaddr, &(info+i)->bdaddr);\n  718  				cr->type = ACL_LINK;\n  719: 				if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n  720  					handle = 0;\n  721  					cc = 1;\n  ...\n  919  	bacpy(&cr->bdaddr, &bdaddr);\n  920  	cr->type = ACL_LINK;\n  921: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n  922  		if (hci_create_connection(dd, &bdaddr,\n  923  					htobs(di.pkt_type & ACL_PTYPE_MASK),\n  ...\n 1331  	bacpy(&cr->bdaddr, &bdaddr);\n 1332  	cr->type = ACL_LINK;\n 1333: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1334  		perror(\"Get connection info failed\");\n 1335  		exit(1);\n ....\n 1457  	bacpy(&cr->bdaddr, &bdaddr);\n 1458  	cr->type = ACL_LINK;\n 1459: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1460  		perror(\"Get connection info failed\");\n 1461  		exit(1);\n ....\n 1525  	bacpy(&cr->bdaddr, &bdaddr);\n 1526  	cr->type = ACL_LINK;\n 1527: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1528  		perror(\"Get connection info failed\");\n 1529  		exit(1);\n ....\n 1595  	bacpy(&cr->bdaddr, &bdaddr);\n 1596  	cr->type = ACL_LINK;\n 1597: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1598  		perror(\"Get connection info failed\");\n 1599  		exit(1);\n ....\n 1665  	bacpy(&cr->bdaddr, &bdaddr);\n 1666  	cr->type = ACL_LINK;\n 1667: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1668  		perror(\"Get connection info failed\");\n 1669  		exit(1);\n ....\n 1746  	bacpy(&cr->bdaddr, &bdaddr);\n 1747  	cr->type = ACL_LINK;\n 1748: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1749  		perror(\"Get connection info failed\");\n 1750  		exit(1);\n ....\n 1824  	bacpy(&cr->bdaddr, &bdaddr);\n 1825  	cr->type = ACL_LINK;\n 1826: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1827  		perror(\"Get connection info failed\");\n 1828  		exit(1);\n ....\n 1917  	bacpy(&cr->bdaddr, &bdaddr);\n 1918  	cr->type = ACL_LINK;\n 1919: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 1920  		perror(\"Get connection info failed\");\n 1921  		exit(1);\n ....\n 2001  	bacpy(&cr->bdaddr, &bdaddr);\n 2002  	cr->type = ACL_LINK;\n 2003: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 2004  		perror(\"Get connection info failed\");\n 2005  		exit(1);\n ....\n 2067  	bacpy(&cr->bdaddr, &bdaddr);\n 2068  	cr->type = ACL_LINK;\n 2069: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 2070  		perror(\"Get connection info failed\");\n 2071  		exit(1);\n ....\n 2134  	bacpy(&cr->bdaddr, &bdaddr);\n 2135  	cr->type = ACL_LINK;\n 2136: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 2137  		perror(\"Get connection info failed\");\n 2138  		exit(1);\n ....\n 2200  	bacpy(&cr->bdaddr, &bdaddr);\n 2201  	cr->type = ACL_LINK;\n 2202: 	if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 2203  		perror(\"Get connection info failed\");\n 2204  		exit(1);\n ....\n 2277  		bacpy(&cr->bdaddr, &bdaddr);\n 2278  		cr->type = ACL_LINK;\n 2279: 		if (ioctl(dd, HCIGETCONNINFO, (unsigned long) cr) < 0) {\n 2280  			perror(\"Get connection info failed\");\n 2281  			free(cr);\n\n~/projects/opensource/bluez/tools/hid2hci:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/hid2hci.c:\n   37  #include <getopt.h>\n   38  #include <limits.h>\n   39: #include <sys/ioctl.h>\n   40  #include <linux/types.h>\n   41  #include <linux/hiddev.h>\n   ..\n   73  };\n   74  \n   75: #define USBFS_IOCTL_CONTROL	_IOWR('U', 0, struct usbfs_ctrltransfer)\n   76: #define USBFS_IOCTL_DISCONNECT	_IOR('U', 27, struct usbfs_disconnect)\n   77  \n   78  static int control_message(int fd, int requesttype, int request,\n   ..\n   90  	transfer.data = bytes;\n   91  \n   92: 	if (ioctl(fd, USBFS_IOCTL_CONTROL, &transfer) < 0) {\n   93  		fprintf(stderr, \"Control transfer failed: %s (%d)\\n\",\n   94  						strerror(errno), errno);\n   ..\n  135  		strcpy(disconnect.driver, \"usbfs\");\n  136  \n  137: 		if (ioctl(fd, USBFS_IOCTL_DISCONNECT, &disconnect) < 0) {\n  138  			fprintf(stderr, \"Can't claim interface: %s (%d)\\n\",\n  139  				strerror(errno), errno);\n  ...\n  181  		uref.usage_code  = 0xff000001;\n  182  		uref.value       = buf[i] & 0x000000ff;\n  183: 		err = ioctl(fd, HIDIOCSUSAGE, &uref);\n  184  		if (err < 0)\n  185  			return err;\n  ...\n  190  	rinfo.report_id   = 0x10;\n  191  	rinfo.num_fields  = 1;\n  192: 	err = ioctl(fd, HIDIOCSREPORT, &rinfo);\n  193  \n  194  	return err;\n  ...\n  207  		return err;\n  208  \n  209: 	err = ioctl(fd, HIDIOCINITREPORT, 0);\n  210  	if (err < 0)\n  211  		goto out;\n  ...\n  244  	strcpy(disconnect.driver, \"usbfs\");\n  245  \n  246: 	if (ioctl(fd, USBFS_IOCTL_DISCONNECT, &disconnect) < 0) {\n  247  		fprintf(stderr, \"Can't claim interface: %s (%d)\\n\",\n  248  						strerror(errno), errno);\n\n/home/jack/projects/opensource/bluez/tools/ibeacon.c:\n   34  #include <string.h>\n   35  #include <getopt.h>\n   36: #include <sys/ioctl.h>\n   37  #include <sys/socket.h>\n   38  \n\n~/projects/opensource/bluez/tools/l2ping:\n    <binary>\n\n~/projects/opensource/bluez/tools/l2test:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/l2test.c:\n   40  #include <sys/time.h>\n   41  #include <poll.h>\n   42: #include <sys/ioctl.h>\n   43  #include <sys/socket.h>\n   44  \n   ..\n  900  				struct timeval tv;\n  901  \n  902: 				if (ioctl(sk, SIOCGSTAMP, &tv) < 0) {\n  903  					timestamp = 0;\n  904  					memset(ts, 0, sizeof(ts));\n\n/home/jack/projects/opensource/bluez/tools/mgmt-tester.c:\n   28  #include <stdlib.h>\n   29  #include <stdbool.h>\n   30: #include <sys/ioctl.h>\n   31  \n   32  #include <glib.h>\n   ..\n 5399  		return false;\n 5400  \n 5401: 	err = ioctl(sk, HCIDEVDOWN, index);\n 5402  \n 5403  	hci_close_dev(sk);\n\n~/projects/opensource/bluez/tools/rctest:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/rctest.c:\n   37  #include <signal.h>\n   38  #include <sys/time.h>\n   39: #include <sys/ioctl.h>\n   40  #include <sys/socket.h>\n   41  #include <sys/stat.h>\n   ..\n  502  				struct timeval tv;\n  503  \n  504: 				if (ioctl(sk, SIOCGSTAMP, &tv) < 0) {\n  505  					timestamp = 0;\n  506  					memset(ts, 0, sizeof(ts));\n\n~/projects/opensource/bluez/tools/rfcomm:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/rfcomm.c:\n   37  #include <poll.h>\n   38  #include <sys/param.h>\n   39: #include <sys/ioctl.h>\n   40  #include <sys/socket.h>\n   41  #include <sys/wait.h>\n   ..\n  130  	di = dl->dev_info;\n  131  \n  132: 	if (ioctl(ctl, RFCOMMGETDEVLIST, (void *) dl) < 0) {\n  133  		perror(\"Can't get device list\");\n  134  		free(dl);\n  ...\n  163  		req.channel = 1;\n  164  \n  165: 	err = ioctl(ctl, RFCOMMCREATEDEV, &req);\n  166  	if (err == -1) {\n  167  		err = -errno;\n  ...\n  184  	req.dev_id = dev;\n  185  \n  186: 	err = ioctl(ctl, RFCOMMRELEASEDEV, &req);\n  187  	if (err < 0)\n  188  		perror(\"Can't release device\");\n  ...\n  206  	di = dl->dev_info;\n  207  \n  208: 	if (ioctl(ctl, RFCOMMGETDEVLIST, (void *) dl) < 0) {\n  209  		perror(\"Can't get device list\");\n  210  		free(dl);\n  ...\n  342  	req.channel = raddr.rc_channel;\n  343  \n  344: 	dev = ioctl(sk, RFCOMMCREATEDEV, &req);\n  345  	if (dev < 0) {\n  346  		perror(\"Can't create RFCOMM TTY\");\n  ...\n  419  	req.dev_id = dev;\n  420  	req.flags = (1 << RFCOMM_HANGUP_NOW);\n  421: 	ioctl(ctl, RFCOMMRELEASEDEV, &req);\n  422  \n  423  	close(sk);\n  ...\n  500  	req.channel = raddr.rc_channel;\n  501  \n  502: 	dev = ioctl(nsk, RFCOMMCREATEDEV, &req);\n  503  	if (dev < 0) {\n  504  		perror(\"Can't create RFCOMM TTY\");\n  ...\n  585  	req.dev_id = dev;\n  586  	req.flags = (1 << RFCOMM_HANGUP_NOW);\n  587: 	ioctl(ctl, RFCOMMRELEASEDEV, &req);\n  588  \n  589  	close(sk);\n  ...\n  617  	else {\n  618  		struct rfcomm_dev_info di = { .id = atoi(argv[0]) };\n  619: 		if (ioctl(ctl, RFCOMMGETDEVINFO, &di) < 0) {\n  620  			perror(\"Get info failed\");\n  621  			exit(1);\n\n~/projects/opensource/bluez/tools/sdptool:\n    <binary>\n\n/home/jack/projects/opensource/bluez/tools/.deps/ciptool.Po:\n   50   /usr/include/x86_64-linux-gnu/bits/poll.h \\\n   51   /usr/include/x86_64-linux-gnu/bits/poll2.h \\\n   52:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   53:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   54:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   55:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   56:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   57:  /usr/include/asm-generic/ioctl.h \\\n   58:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   59   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   60   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  211  /usr/include/x86_64-linux-gnu/bits/poll2.h:\n  212  \n  213: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  214  \n  215: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  216  \n  217: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  218  \n  219: /usr/include/asm-generic/ioctls.h:\n  220  \n  221: /usr/include/linux/ioctl.h:\n  222  \n  223: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  224  \n  225: /usr/include/asm-generic/ioctl.h:\n  226  \n  227: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  228  \n  229  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/csr_usb.Po:\n   54   /usr/include/limits.h /usr/include/x86_64-linux-gnu/bits/posix2_lim.h \\\n   55   /usr/include/x86_64-linux-gnu/bits/xopen_lim.h \\\n   56:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   57:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   58:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   59:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   60:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   61:  /usr/include/asm-generic/ioctl.h \\\n   62:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   63   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h tools/csr.h \\\n   64   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   ..\n  212  /usr/include/x86_64-linux-gnu/bits/xopen_lim.h:\n  213  \n  214: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  215  \n  216: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  217  \n  218: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  219  \n  220: /usr/include/asm-generic/ioctls.h:\n  221  \n  222: /usr/include/linux/ioctl.h:\n  223  \n  224: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  225  \n  226: /usr/include/asm-generic/ioctl.h:\n  227  \n  228: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  229  \n  230  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach.Po:\n   74   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   75   /usr/include/asm-generic/param.h \\\n   76:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   77:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   78:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   79:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   80:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   81:  /usr/include/asm-generic/ioctl.h \\\n   82:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h lib/bluetooth.h \\\n   83   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   84   /usr/include/x86_64-linux-gnu/bits/wchar.h /usr/include/byteswap.h \\\n   ..\n  288  /usr/include/asm-generic/param.h:\n  289  \n  290: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  291  \n  292: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  295  \n  296: /usr/include/asm-generic/ioctls.h:\n  297  \n  298: /usr/include/linux/ioctl.h:\n  299  \n  300: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  301  \n  302: /usr/include/asm-generic/ioctl.h:\n  303  \n  304: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  305  \n  306  lib/bluetooth.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach_ath3k.Po:\n   60   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   61   /usr/include/asm-generic/param.h \\\n   62:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   63:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   64:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   65:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   66:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   67:  /usr/include/asm-generic/ioctl.h \\\n   68:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   69   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h lib/bluetooth.h \\\n   70   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   ..\n  245  /usr/include/asm-generic/param.h:\n  246  \n  247: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  248  \n  249: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  250  \n  251: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  252  \n  253: /usr/include/asm-generic/ioctls.h:\n  254  \n  255: /usr/include/linux/ioctl.h:\n  256  \n  257: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  258  \n  259: /usr/include/asm-generic/ioctl.h:\n  260  \n  261: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  262  \n  263  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach_intel.Po:\n   63   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   64   /usr/include/asm-generic/param.h \\\n   65:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   66:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   67:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   68:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   69:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   70:  /usr/include/asm-generic/ioctl.h \\\n   71:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   72   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   73   /usr/include/x86_64-linux-gnu/bits/timex.h lib/bluetooth.h \\\n   ..\n  254  /usr/include/asm-generic/param.h:\n  255  \n  256: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  257  \n  258: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  259  \n  260: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  261  \n  262: /usr/include/asm-generic/ioctls.h:\n  263  \n  264: /usr/include/linux/ioctl.h:\n  265  \n  266: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  267  \n  268: /usr/include/asm-generic/ioctl.h:\n  269  \n  270: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  271  \n  272  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach_qualcomm.Po:\n   74   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   75   /usr/include/asm-generic/param.h \\\n   76:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   77:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   78:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   79:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   80:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   81:  /usr/include/asm-generic/ioctl.h \\\n   82:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   83   /usr/include/x86_64-linux-gnu/sys/uio.h lib/bluetooth.h \\\n   84   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   ..\n  288  /usr/include/asm-generic/param.h:\n  289  \n  290: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  291  \n  292: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  295  \n  296: /usr/include/asm-generic/ioctls.h:\n  297  \n  298: /usr/include/linux/ioctl.h:\n  299  \n  300: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  301  \n  302: /usr/include/asm-generic/ioctl.h:\n  303  \n  304: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  305  \n  306  /usr/include/x86_64-linux-gnu/sys/uio.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach_ti.Po:\n   59   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   60   /usr/include/asm-generic/param.h \\\n   61:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   62:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   63:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   64:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   65:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   66:  /usr/include/asm-generic/ioctl.h \\\n   67:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h lib/bluetooth.h \\\n   68   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   69   /usr/include/x86_64-linux-gnu/bits/wchar.h /usr/include/string.h \\\n   ..\n  241  /usr/include/asm-generic/param.h:\n  242  \n  243: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  244  \n  245: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  246  \n  247: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  248  \n  249: /usr/include/asm-generic/ioctls.h:\n  250  \n  251: /usr/include/linux/ioctl.h:\n  252  \n  253: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  254  \n  255: /usr/include/asm-generic/ioctl.h:\n  256  \n  257: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  258  \n  259  lib/bluetooth.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciattach_tialt.Po:\n   74   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   75   /usr/include/asm-generic/param.h \\\n   76:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   77:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   78:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   79:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   80:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   81:  /usr/include/asm-generic/ioctl.h \\\n   82:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   83   /usr/include/x86_64-linux-gnu/sys/uio.h lib/bluetooth.h \\\n   84   /usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdint.h /usr/include/stdint.h \\\n   ..\n  288  /usr/include/asm-generic/param.h:\n  289  \n  290: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  291  \n  292: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  293  \n  294: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  295  \n  296: /usr/include/asm-generic/ioctls.h:\n  297  \n  298: /usr/include/linux/ioctl.h:\n  299  \n  300: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  301  \n  302: /usr/include/asm-generic/ioctl.h:\n  303  \n  304: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  305  \n  306  /usr/include/x86_64-linux-gnu/sys/uio.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hciconfig.Po:\n   59   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   60   /usr/include/asm-generic/param.h \\\n   61:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   62:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   63:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   64:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   65:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   66:  /usr/include/asm-generic/ioctl.h \\\n   67:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   68   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   69   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  242  /usr/include/asm-generic/param.h:\n  243  \n  244: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  245  \n  246: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  247  \n  248: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  249  \n  250: /usr/include/asm-generic/ioctls.h:\n  251  \n  252: /usr/include/linux/ioctl.h:\n  253  \n  254: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  255  \n  256: /usr/include/asm-generic/ioctl.h:\n  257  \n  258: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  259  \n  260  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hcidump.Po:\n   50   /usr/include/x86_64-linux-gnu/bits/poll2.h \\\n   51   /usr/include/x86_64-linux-gnu/sys/stat.h \\\n   52:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   53:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   54:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   55:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   56:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   57:  /usr/include/asm-generic/ioctl.h \\\n   58:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   59   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   60   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  210  /usr/include/x86_64-linux-gnu/sys/stat.h:\n  211  \n  212: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  213  \n  214: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  215  \n  216: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  217  \n  218: /usr/include/asm-generic/ioctls.h:\n  219  \n  220: /usr/include/linux/ioctl.h:\n  221  \n  222: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  223  \n  224: /usr/include/asm-generic/ioctl.h:\n  225  \n  226: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  227  \n  228  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hcitool.Po:\n   64   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   65   /usr/include/asm-generic/param.h \\\n   66:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   67:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   68:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   69:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   70:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   71:  /usr/include/asm-generic/ioctl.h \\\n   72:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   73   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   74   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  255  /usr/include/asm-generic/param.h:\n  256  \n  257: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  258  \n  259: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  260  \n  261: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  262  \n  263: /usr/include/asm-generic/ioctls.h:\n  264  \n  265: /usr/include/linux/ioctl.h:\n  266  \n  267: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  268  \n  269: /usr/include/asm-generic/ioctl.h:\n  270  \n  271: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  272  \n  273  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/hid2hci.Po:\n   56   /usr/include/limits.h /usr/include/x86_64-linux-gnu/bits/posix2_lim.h \\\n   57   /usr/include/x86_64-linux-gnu/bits/xopen_lim.h \\\n   58:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   59:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   60:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   61:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   62:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   63:  /usr/include/asm-generic/ioctl.h \\\n   64:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   65   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   66   /usr/include/linux/types.h /usr/include/x86_64-linux-gnu/asm/types.h \\\n   ..\n  224  /usr/include/x86_64-linux-gnu/bits/xopen_lim.h:\n  225  \n  226: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  227  \n  228: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  229  \n  230: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  231  \n  232: /usr/include/asm-generic/ioctls.h:\n  233  \n  234: /usr/include/linux/ioctl.h:\n  235  \n  236: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  237  \n  238: /usr/include/asm-generic/ioctl.h:\n  239  \n  240: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  241  \n  242  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/l2test.Po:\n   58   /usr/include/x86_64-linux-gnu/bits/poll.h \\\n   59   /usr/include/x86_64-linux-gnu/bits/poll2.h \\\n   60:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   61:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   62:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   63:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   64:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   65:  /usr/include/asm-generic/ioctl.h \\\n   66:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   67   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   68   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  238  /usr/include/x86_64-linux-gnu/bits/poll2.h:\n  239  \n  240: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  241  \n  242: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  243  \n  244: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  245  \n  246: /usr/include/asm-generic/ioctls.h:\n  247  \n  248: /usr/include/linux/ioctl.h:\n  249  \n  250: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  251  \n  252: /usr/include/asm-generic/ioctl.h:\n  253  \n  254: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  255  \n  256  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/rctest.Po:\n   54   /usr/include/x86_64-linux-gnu/bits/sigthread.h \\\n   55   /usr/include/x86_64-linux-gnu/sys/time.h \\\n   56:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   57:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   58:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   59:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   60:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   61:  /usr/include/asm-generic/ioctl.h \\\n   62:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   63   /usr/include/x86_64-linux-gnu/sys/ttydefaults.h \\\n   64   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   ..\n  226  /usr/include/x86_64-linux-gnu/sys/time.h:\n  227  \n  228: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  229  \n  230: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  231  \n  232: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  233  \n  234: /usr/include/asm-generic/ioctls.h:\n  235  \n  236: /usr/include/linux/ioctl.h:\n  237  \n  238: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  239  \n  240: /usr/include/asm-generic/ioctl.h:\n  241  \n  242: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  243  \n  244  /usr/include/x86_64-linux-gnu/sys/ttydefaults.h:\n\n/home/jack/projects/opensource/bluez/tools/.deps/rfcomm.Po:\n   69   /usr/include/x86_64-linux-gnu/asm/param.h \\\n   70   /usr/include/asm-generic/param.h \\\n   71:  /usr/include/x86_64-linux-gnu/sys/ioctl.h \\\n   72:  /usr/include/x86_64-linux-gnu/bits/ioctls.h \\\n   73:  /usr/include/x86_64-linux-gnu/asm/ioctls.h \\\n   74:  /usr/include/asm-generic/ioctls.h /usr/include/linux/ioctl.h \\\n   75:  /usr/include/x86_64-linux-gnu/asm/ioctl.h \\\n   76:  /usr/include/asm-generic/ioctl.h \\\n   77:  /usr/include/x86_64-linux-gnu/bits/ioctl-types.h \\\n   78   /usr/include/x86_64-linux-gnu/sys/socket.h \\\n   79   /usr/include/x86_64-linux-gnu/sys/uio.h \\\n   ..\n  272  /usr/include/asm-generic/param.h:\n  273  \n  274: /usr/include/x86_64-linux-gnu/sys/ioctl.h:\n  275  \n  276: /usr/include/x86_64-linux-gnu/bits/ioctls.h:\n  277  \n  278: /usr/include/x86_64-linux-gnu/asm/ioctls.h:\n  279  \n  280: /usr/include/asm-generic/ioctls.h:\n  281  \n  282: /usr/include/linux/ioctl.h:\n  283  \n  284: /usr/include/x86_64-linux-gnu/asm/ioctl.h:\n  285  \n  286: /usr/include/asm-generic/ioctl.h:\n  287  \n  288: /usr/include/x86_64-linux-gnu/bits/ioctl-types.h:\n  289  \n  290  /usr/include/x86_64-linux-gnu/sys/socket.h:\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/af_bluetooth.c:\n   27  #include <linux/module.h>\n   28  #include <linux/debugfs.h>\n   29: #include <asm/ioctls.h>\n   30  \n   31  #include <net/bluetooth/bluetooth.h>\n   ..\n  446  EXPORT_SYMBOL(bt_sock_poll);\n  447  \n  448: int bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n  449  {\n  450  	struct sock *sk = sock->sk;\n  ...\n  486  \n  487  	default:\n  488: 		err = -ENOIOCTLCMD;\n  489  		break;\n  490  	}\n  ...\n  492  	return err;\n  493  }\n  494: EXPORT_SYMBOL(bt_sock_ioctl);\n  495  \n  496  /* This function expects the sk lock to be held when called */\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_core.c:\n 1900  }\n 1901  \n 1902: /* ---- HCI ioctl helpers ---- */\n 1903  \n 1904  int hci_dev_open(__u16 dev)\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_sock.c:\n  506  }\n  507  \n  508: /* Ioctls that require bound socket */\n  509: static int hci_sock_bound_ioctl(struct sock *sk, unsigned int cmd,\n  510  				unsigned long arg)\n  511  {\n  ...\n  553  	}\n  554  \n  555: 	return -ENOIOCTLCMD;\n  556  }\n  557  \n  558: static int hci_sock_ioctl(struct socket *sock, unsigned int cmd,\n  559  			  unsigned long arg)\n  560  {\n  ...\n  622  	lock_sock(sk);\n  623  \n  624: 	err = hci_sock_bound_ioctl(sk, cmd, arg);\n  625  \n  626  done:\n  ...\n 1159  	.sendmsg	= hci_sock_sendmsg,\n 1160  	.recvmsg	= hci_sock_recvmsg,\n 1161: 	.ioctl		= hci_sock_ioctl,\n 1162  	.poll		= datagram_poll,\n 1163  	.listen		= sock_no_listen,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/l2cap_sock.c:\n 1418  	.recvmsg	= l2cap_sock_recvmsg,\n 1419  	.poll		= bt_sock_poll,\n 1420: 	.ioctl		= bt_sock_ioctl,\n 1421  	.mmap		= sock_no_mmap,\n 1422  	.socketpair	= sock_no_socketpair,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/sco.c:\n 1144  	.recvmsg	= sco_sock_recvmsg,\n 1145  	.poll		= bt_sock_poll,\n 1146: 	.ioctl		= bt_sock_ioctl,\n 1147  	.mmap		= sock_no_mmap,\n 1148  	.socketpair	= sock_no_socketpair,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/bnep/bnep.h:\n  108  } __packed;\n  109  \n  110: /* BNEP ioctl defines */\n  111  #define BNEPCONNADD	_IOW('B', 200, int)\n  112  #define BNEPCONNDEL	_IOW('B', 201, int)\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/bnep/sock.c:\n   50  }\n   51  \n   52: static int bnep_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n   53  {\n   54  	struct bnep_connlist_req cl;\n   ..\n  129  \n  130  #ifdef CONFIG_COMPAT\n  131: static int bnep_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n  132  {\n  133  	if (cmd == BNEPGETCONNLIST) {\n  ...\n  153  	}\n  154  \n  155: 	return bnep_sock_ioctl(sock, cmd, arg);\n  156  }\n  157  #endif\n  ...\n  161  	.owner		= THIS_MODULE,\n  162  	.release	= bnep_sock_release,\n  163: 	.ioctl		= bnep_sock_ioctl,\n  164  #ifdef CONFIG_COMPAT\n  165: 	.compat_ioctl	= bnep_sock_compat_ioctl,\n  166  #endif\n  167  	.bind		= sock_no_bind,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/cmtp/capi.c:\n   33  #include <linux/skbuff.h>\n   34  #include <linux/socket.h>\n   35: #include <linux/ioctl.h>\n   36  #include <linux/file.h>\n   37  #include <linux/wait.h>\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/cmtp/cmtp.h:\n   29  #define BTNAMSIZ 18\n   30  \n   31: /* CMTP ioctl defines */\n   32  #define CMTPCONNADD	_IOW('C', 200, int)\n   33  #define CMTPCONNDEL	_IOW('C', 201, int)\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/cmtp/core.c:\n   33  #include <linux/skbuff.h>\n   34  #include <linux/socket.h>\n   35: #include <linux/ioctl.h>\n   36  #include <linux/file.h>\n   37  #include <linux/init.h>\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/cmtp/sock.c:\n   31  #include <linux/skbuff.h>\n   32  #include <linux/socket.h>\n   33: #include <linux/ioctl.h>\n   34  #include <linux/file.h>\n   35  #include <linux/compat.h>\n   ..\n   64  }\n   65  \n   66: static int cmtp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n   67  {\n   68  	struct cmtp_connadd_req ca;\n   ..\n  139  \n  140  #ifdef CONFIG_COMPAT\n  141: static int cmtp_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n  142  {\n  143  	if (cmd == CMTPGETCONNLIST) {\n  ...\n  163  	}\n  164  \n  165: 	return cmtp_sock_ioctl(sock, cmd, arg);\n  166  }\n  167  #endif\n  ...\n  171  	.owner		= THIS_MODULE,\n  172  	.release	= cmtp_sock_release,\n  173: 	.ioctl		= cmtp_sock_ioctl,\n  174  #ifdef CONFIG_COMPAT\n  175: 	.compat_ioctl	= cmtp_sock_compat_ioctl,\n  176  #endif\n  177  	.bind		= sock_no_bind,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hidp/hidp.h:\n   75  #define HIDP_PROTO_REPORT			0x01\n   76  \n   77: /* HIDP ioctl defines */\n   78  #define HIDPCONNADD	_IOW('H', 200, int)\n   79  #define HIDPCONNDEL	_IOW('H', 201, int)\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hidp/sock.c:\n   47  }\n   48  \n   49: static int hidp_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n   50  {\n   51  	void __user *argp = (void __user *) arg;\n   ..\n  140  };\n  141  \n  142: static int hidp_sock_compat_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n  143  {\n  144  	if (cmd == HIDPGETCONNLIST) {\n  ...\n  193  	}\n  194  \n  195: 	return hidp_sock_ioctl(sock, cmd, arg);\n  196  }\n  197  #endif\n  ...\n  201  	.owner		= THIS_MODULE,\n  202  	.release	= hidp_sock_release,\n  203: 	.ioctl		= hidp_sock_ioctl,\n  204  #ifdef CONFIG_COMPAT\n  205: 	.compat_ioctl	= hidp_sock_compat_ioctl,\n  206  #endif\n  207  	.bind		= sock_no_bind,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/rfcomm/sock.c:\n  862  }\n  863  \n  864: static int rfcomm_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n  865  {\n  866  	struct sock *sk __maybe_unused = sock->sk;\n  ...\n  869  	BT_DBG(\"sk %p cmd %x arg %lx\", sk, cmd, arg);\n  870  \n  871: 	err = bt_sock_ioctl(sock, cmd, arg);\n  872  \n  873: 	if (err == -ENOIOCTLCMD) {\n  874  #ifdef CONFIG_BT_RFCOMM_TTY\n  875  		lock_sock(sk);\n  876: 		err = rfcomm_dev_ioctl(sk, cmd, (void __user *) arg);\n  877  		release_sock(sk);\n  878  #else\n  ...\n 1023  	.setsockopt	= rfcomm_sock_setsockopt,\n 1024  	.getsockopt	= rfcomm_sock_getsockopt,\n 1025: 	.ioctl		= rfcomm_sock_ioctl,\n 1026  	.poll		= bt_sock_poll,\n 1027  	.socketpair	= sock_no_socketpair,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/rfcomm/tty.c:\n  362  }\n  363  \n  364: /* ---- Device IOCTLs ---- */\n  365  \n  366  #define NOCAP_FLAGS ((1 << RFCOMM_REUSE_DLC) | (1 << RFCOMM_RELEASE_ONHUP))\n  ...\n  523  }\n  524  \n  525: int rfcomm_dev_ioctl(struct sock *sk, unsigned int cmd, void __user *arg)\n  526  {\n  527  	BT_DBG(\"cmd %d arg %p\", cmd, arg);\n  ...\n  764  }\n  765  \n  766: static int rfcomm_tty_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n  767  {\n  768  	BT_DBG(\"tty %p cmd 0x%02x\", tty, cmd);\n  ...\n  771  	case TCGETS:\n  772  		BT_DBG(\"TCGETS is not supported\");\n  773: 		return -ENOIOCTLCMD;\n  774  \n  775  	case TCSETS:\n  776  		BT_DBG(\"TCSETS is not supported\");\n  777: 		return -ENOIOCTLCMD;\n  778  \n  779  	case TIOCMIWAIT:\n  ...\n  783  	case TIOCGSERIAL:\n  784  		BT_ERR(\"TIOCGSERIAL is not supported\");\n  785: 		return -ENOIOCTLCMD;\n  786  \n  787  	case TIOCSSERIAL:\n  788  		BT_ERR(\"TIOCSSERIAL is not supported\");\n  789: 		return -ENOIOCTLCMD;\n  790  \n  791  	case TIOCSERGSTRUCT:\n  792  		BT_ERR(\"TIOCSERGSTRUCT is not supported\");\n  793: 		return -ENOIOCTLCMD;\n  794  \n  795  	case TIOCSERGETLSR:\n  796  		BT_ERR(\"TIOCSERGETLSR is not supported\");\n  797: 		return -ENOIOCTLCMD;\n  798  \n  799  	case TIOCSERCONFIG:\n  800  		BT_ERR(\"TIOCSERCONFIG is not supported\");\n  801: 		return -ENOIOCTLCMD;\n  802  \n  803  	default:\n  804: 		return -ENOIOCTLCMD;	/* ioctls which we must ignore */\n  805  \n  806  	}\n  807  \n  808: 	return -ENOIOCTLCMD;\n  809  }\n  810  \n  ...\n 1068  	.chars_in_buffer	= rfcomm_tty_chars_in_buffer,\n 1069  	.flush_buffer		= rfcomm_tty_flush_buffer,\n 1070: 	.ioctl			= rfcomm_tty_ioctl,\n 1071  	.throttle		= rfcomm_tty_throttle,\n 1072  	.unthrottle		= rfcomm_tty_unthrottle,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/bluetooth.h:\n  247  			struct msghdr *msg, size_t len, int flags);\n  248  uint bt_sock_poll(struct file *file, struct socket *sock, poll_table *wait);\n  249: int  bt_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);\n  250  int  bt_sock_wait_state(struct sock *sk, int state, unsigned long timeo);\n  251  int  bt_sock_wait_ready(struct sock *sk, unsigned long flags);\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci.h:\n  140  			      BIT(HCI_FAST_CONNECTABLE))\n  141  \n  142: /* HCI ioctl defines */\n  143  #define HCIDEVUP	_IOW('H', 201, int)\n  144  #define HCIDEVDOWN	_IOW('H', 202, int)\n  ...\n 1711  #define HCI_FLT_OCF_BITS	127\n 1712  \n 1713: /* ---- HCI Ioctl requests structures ---- */\n 1714  struct hci_dev_stats {\n 1715  	__u32 err_rx;\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/rfcomm.h:\n  352  };\n  353  \n  354: int  rfcomm_dev_ioctl(struct sock *sk, unsigned int cmd, void __user *arg);\n  355  \n  356  #ifdef CONFIG_BT_RFCOMM_TTY\n\n3157 matches across 340 files\n\n\nSearching 4676 files for \"proto_ops\"\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_sock.c:\n 1151  }\n 1152  \n 1153: static const struct proto_ops hci_sock_ops = {\n 1154  	.family		= PF_BLUETOOTH,\n 1155  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/l2cap_sock.c:\n   40  };\n   41  \n   42: static const struct proto_ops l2cap_sock_ops;\n   43  static void l2cap_sock_init(struct sock *sk, struct sock *parent);\n   44  static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n   ..\n 1406  }\n 1407  \n 1408: static const struct proto_ops l2cap_sock_ops = {\n 1409  	.family		= PF_BLUETOOTH,\n 1410  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/sco.c:\n   35  static bool disable_esco;\n   36  \n   37: static const struct proto_ops sco_sock_ops;\n   38  \n   39  static struct bt_sock_list sco_sk_list = {\n   ..\n 1132  static struct dentry *sco_debugfs;\n 1133  \n 1134: static const struct proto_ops sco_sock_ops = {\n 1135  	.family		= PF_BLUETOOTH,\n 1136  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/bnep/sock.c:\n  157  #endif\n  158  \n  159: static const struct proto_ops bnep_sock_ops = {\n  160  	.family		= PF_BLUETOOTH,\n  161  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/cmtp/sock.c:\n  167  #endif\n  168  \n  169: static const struct proto_ops cmtp_sock_ops = {\n  170  	.family		= PF_BLUETOOTH,\n  171  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hidp/sock.c:\n  197  #endif\n  198  \n  199: static const struct proto_ops hidp_sock_ops = {\n  200  	.family		= PF_BLUETOOTH,\n  201  	.owner		= THIS_MODULE,\n\n/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/rfcomm/sock.c:\n   34  #include <net/bluetooth/rfcomm.h>\n   35  \n   36: static const struct proto_ops rfcomm_sock_ops;\n   37  \n   38  static struct bt_sock_list rfcomm_sk_list = {\n   ..\n 1009  static struct dentry *rfcomm_sock_debugfs;\n 1010  \n 1011: static const struct proto_ops rfcomm_sock_ops = {\n 1012  	.family		= PF_BLUETOOTH,\n 1013  	.owner		= THIS_MODULE,\n\n10 matches across 7 files\n",
			"settings":
			{
				"buffer_size": 374479,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_sock.c",
			"settings":
			{
				"buffer_size": 25504,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/lib/hci.c",
			"settings":
			{
				"buffer_size": 65299,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/lib/hci.h",
			"settings":
			{
				"buffer_size": 63685,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/lib/bluetooth/hci.h",
			"settings":
			{
				"buffer_size": 63685,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/monitor/hcidump.c",
			"settings":
			{
				"buffer_size": 8707,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/tools/amptest.c",
			"settings":
			{
				"buffer_size": 14797,
				"line_ending": "Unix"
			}
		},
		{
			"file": "hcilocal.c",
			"settings":
			{
				"buffer_size": 1940,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci.h",
			"settings":
			{
				"buffer_size": 40016,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci_core.h",
			"settings":
			{
				"buffer_size": 32490,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/tools/btinfo.c",
			"settings":
			{
				"buffer_size": 7980,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/tools/cltest.c",
			"settings":
			{
				"buffer_size": 6182,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/* Copyright (C) 1991-2014 Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, see\n   <http://www.gnu.org/licenses/>.  */\n\n/*\n *	POSIX Standard: 5.1.2 Directory Operations	<dirent.h>\n */\n\n#ifndef	_DIRENT_H\n#define	_DIRENT_H	1\n\n#include <features.h>\n\n__BEGIN_DECLS\n\n#include <bits/types.h>\n\n#ifdef __USE_XOPEN\n# ifndef __ino_t_defined\n#  ifndef __USE_FILE_OFFSET64\ntypedef __ino_t ino_t;\n#  else\ntypedef __ino64_t ino_t;\n#  endif\n#  define __ino_t_defined\n# endif\n# if defined __USE_LARGEFILE64 && !defined __ino64_t_defined\ntypedef __ino64_t ino64_t;\n#  define __ino64_t_defined\n# endif\n#endif\n\n/* This file defines `struct dirent'.\n\n   It defines the macro `_DIRENT_HAVE_D_NAMLEN' iff there is a `d_namlen'\n   member that gives the length of `d_name'.\n\n   It defines the macro `_DIRENT_HAVE_D_RECLEN' iff there is a `d_reclen'\n   member that gives the size of the entire directory entry.\n\n   It defines the macro `_DIRENT_HAVE_D_OFF' iff there is a `d_off'\n   member that gives the file offset of the next directory entry.\n\n   It defines the macro `_DIRENT_HAVE_D_TYPE' iff there is a `d_type'\n   member that gives the type of the file.\n */\n\n#include <bits/dirent.h>\n\n#if (defined __USE_BSD || defined __USE_MISC) && !defined d_fileno\n# define d_ino	d_fileno		 /* Backward compatibility.  */\n#endif\n\n/* These macros extract size information from a `struct dirent *'.\n   They may evaluate their argument multiple times, so it must not\n   have side effects.  Each of these may involve a relatively costly\n   call to `strlen' on some systems, so these values should be cached.\n\n   _D_EXACT_NAMLEN (DP)	returns the length of DP->d_name, not including\n   its terminating null character.\n\n   _D_ALLOC_NAMLEN (DP)	returns a size at least (_D_EXACT_NAMLEN (DP) + 1);\n   that is, the allocation size needed to hold the DP->d_name string.\n   Use this macro when you don't need the exact length, just an upper bound.\n   This macro is less likely to require calling `strlen' than _D_EXACT_NAMLEN.\n   */\n\n#ifdef _DIRENT_HAVE_D_NAMLEN\n# define _D_EXACT_NAMLEN(d) ((d)->d_namlen)\n# define _D_ALLOC_NAMLEN(d) (_D_EXACT_NAMLEN (d) + 1)\n#else\n# define _D_EXACT_NAMLEN(d) (strlen ((d)->d_name))\n# ifdef _DIRENT_HAVE_D_RECLEN\n#  define _D_ALLOC_NAMLEN(d) (((char *) (d) + (d)->d_reclen) - &(d)->d_name[0])\n# else\n#  define _D_ALLOC_NAMLEN(d) (sizeof (d)->d_name > 1 ? sizeof (d)->d_name : \\\n			      _D_EXACT_NAMLEN (d) + 1)\n# endif\n#endif\n\n\n#ifdef __USE_BSD\n/* File types for `d_type'.  */\nenum\n  {\n    DT_UNKNOWN = 0,\n# define DT_UNKNOWN	DT_UNKNOWN\n    DT_FIFO = 1,\n# define DT_FIFO	DT_FIFO\n    DT_CHR = 2,\n# define DT_CHR		DT_CHR \n    DT_DIR = 4,\n# define DT_DIR		DT_DIR\n    DT_BLK = 6,\n# define DT_BLK		DT_BLK\n    DT_REG = 8,\n# define DT_REG		DT_REG\n    DT_LNK = 10,\n# define DT_LNK		DT_LNK\n    DT_SOCK = 12,\n# define DT_SOCK	DT_SOCK\n    DT_WHT = 14\n# define DT_WHT		DT_WHT\n  };\n\n/* Convert between stat structure types and directory types.  */\n# define IFTODT(mode)	(((mode) & 0170000) >> 12)\n# define DTTOIF(dirtype)	((dirtype) << 12)\n#endif\n\n\n/* This is the data type of directory stream objects.\n   The actual structure is opaque to users.  */\ntypedef struct __dirstream DIR;\n\n/* Open a directory stream on NAME.\n   Return a DIR stream on the directory, or NULL if it could not be opened.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern DIR *opendir (const char *__name) __nonnull ((1));\n\n#ifdef __USE_XOPEN2K8\n/* Same as opendir, but open the stream on the file descriptor FD.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern DIR *fdopendir (int __fd);\n#endif\n\n/* Close the directory stream DIRP.\n   Return 0 if successful, -1 if not.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\nextern int closedir (DIR *__dirp) __nonnull ((1));\n\n/* Read a directory entry from DIRP.  Return a pointer to a `struct\n   dirent' describing the entry, or NULL for EOF or error.  The\n   storage returned may be overwritten by a later readdir call on the\n   same DIR stream.\n\n   If the Large File Support API is selected we have to use the\n   appropriate interface.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n#ifndef __USE_FILE_OFFSET64\nextern struct dirent *readdir (DIR *__dirp) __nonnull ((1));\n#else\n# ifdef __REDIRECT\nextern struct dirent *__REDIRECT (readdir, (DIR *__dirp), readdir64)\n     __nonnull ((1));\n# else\n#  define readdir readdir64\n# endif\n#endif\n\n#ifdef __USE_LARGEFILE64\nextern struct dirent64 *readdir64 (DIR *__dirp) __nonnull ((1));\n#endif\n\n#if defined __USE_POSIX || defined __USE_MISC\n/* Reentrant version of `readdir'.  Return in RESULT a pointer to the\n   next entry.\n\n   This function is a possible cancellation point and therefore not\n   marked with __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int readdir_r (DIR *__restrict __dirp,\n		      struct dirent *__restrict __entry,\n		      struct dirent **__restrict __result)\n     __nonnull ((1, 2, 3));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (readdir_r,\n		       (DIR *__restrict __dirp,\n			struct dirent *__restrict __entry,\n			struct dirent **__restrict __result),\n		       readdir64_r) __nonnull ((1, 2, 3));\n#  else\n#   define readdir_r readdir64_r\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\nextern int readdir64_r (DIR *__restrict __dirp,\n			struct dirent64 *__restrict __entry,\n			struct dirent64 **__restrict __result)\n     __nonnull ((1, 2, 3));\n# endif\n#endif	/* POSIX or misc */\n\n/* Rewind DIRP to the beginning of the directory.  */\nextern void rewinddir (DIR *__dirp) __THROW __nonnull ((1));\n\n#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN\n# include <bits/types.h>\n\n/* Seek to position POS on DIRP.  */\nextern void seekdir (DIR *__dirp, long int __pos) __THROW __nonnull ((1));\n\n/* Return the current position of DIRP.  */\nextern long int telldir (DIR *__dirp) __THROW __nonnull ((1));\n#endif\n\n#if defined __USE_BSD || defined __USE_MISC || defined __USE_XOPEN2K8\n\n/* Return the file descriptor used by DIRP.  */\nextern int dirfd (DIR *__dirp) __THROW __nonnull ((1));\n\n# if defined __OPTIMIZE__ && defined _DIR_dirfd\n#  define dirfd(dirp)	_DIR_dirfd (dirp)\n# endif\n\n# if defined __USE_BSD || defined __USE_MISC\n#  ifndef MAXNAMLEN\n/* Get the definitions of the POSIX.1 limits.  */\n#  include <bits/posix1_lim.h>\n\n/* `MAXNAMLEN' is the BSD name for what POSIX calls `NAME_MAX'.  */\n#   ifdef NAME_MAX\n#    define MAXNAMLEN	NAME_MAX\n#   else\n#    define MAXNAMLEN	255\n#   endif\n#  endif\n# endif\n\n# define __need_size_t\n# include <stddef.h>\n\n/* Scan the directory DIR, calling SELECTOR on each directory entry.\n   Entries for which SELECT returns nonzero are individually malloc'd,\n   sorted using qsort with CMP, and collected in a malloc'd array in\n   *NAMELIST.  Returns the number of entries selected, or -1 on error.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n# ifndef __USE_FILE_OFFSET64\nextern int scandir (const char *__restrict __dir,\n		    struct dirent ***__restrict __namelist,\n		    int (*__selector) (const struct dirent *),\n		    int (*__cmp) (const struct dirent **,\n				  const struct dirent **))\n     __nonnull ((1, 2));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT (scandir,\n		       (const char *__restrict __dir,\n			struct dirent ***__restrict __namelist,\n			int (*__selector) (const struct dirent *),\n			int (*__cmp) (const struct dirent **,\n				      const struct dirent **)),\n		       scandir64) __nonnull ((1, 2));\n#  else\n#   define scandir scandir64\n#  endif\n# endif\n\n# if defined __USE_GNU && defined __USE_LARGEFILE64\n/* This function is like `scandir' but it uses the 64bit dirent structure.\n   Please note that the CMP function must now work with struct dirent64 **.  */\nextern int scandir64 (const char *__restrict __dir,\n		      struct dirent64 ***__restrict __namelist,\n		      int (*__selector) (const struct dirent64 *),\n		      int (*__cmp) (const struct dirent64 **,\n				    const struct dirent64 **))\n     __nonnull ((1, 2));\n# endif\n\n# ifdef __USE_GNU\n/* Similar to `scandir' but a relative DIR name is interpreted relative\n   to the directory for which DFD is a descriptor.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\n#  ifndef __USE_FILE_OFFSET64\nextern int scandirat (int __dfd, const char *__restrict __dir,\n		      struct dirent ***__restrict __namelist,\n		      int (*__selector) (const struct dirent *),\n		      int (*__cmp) (const struct dirent **,\n				    const struct dirent **))\n     __nonnull ((2, 3));\n#  else\n#   ifdef __REDIRECT\nextern int __REDIRECT (scandirat,\n		       (int __dfd, const char *__restrict __dir,\n			struct dirent ***__restrict __namelist,\n			int (*__selector) (const struct dirent *),\n			int (*__cmp) (const struct dirent **,\n				      const struct dirent **)),\n		       scandirat64) __nonnull ((2, 3));\n#   else\n#    define scandirat scandirat64\n#   endif\n#  endif\n\n/* This function is like `scandir' but it uses the 64bit dirent structure.\n   Please note that the CMP function must now work with struct dirent64 **.  */\nextern int scandirat64 (int __dfd, const char *__restrict __dir,\n			struct dirent64 ***__restrict __namelist,\n			int (*__selector) (const struct dirent64 *),\n			int (*__cmp) (const struct dirent64 **,\n				      const struct dirent64 **))\n     __nonnull ((2, 3));\n# endif\n\n/* Function to compare two `struct dirent's alphabetically.  */\n# ifndef __USE_FILE_OFFSET64\nextern int alphasort (const struct dirent **__e1,\n		      const struct dirent **__e2)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT_NTH (alphasort,\n			   (const struct dirent **__e1,\n			    const struct dirent **__e2),\n			   alphasort64) __attribute_pure__ __nonnull ((1, 2));\n#  else\n#   define alphasort alphasort64\n#  endif\n# endif\n\n# if defined __USE_GNU && defined __USE_LARGEFILE64\nextern int alphasort64 (const struct dirent64 **__e1,\n			const struct dirent64 **__e2)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n# endif\n#endif /* Use BSD or misc or XPG7.  */\n\n\n#if defined __USE_BSD || defined __USE_MISC\n/* Read directory entries from FD into BUF, reading at most NBYTES.\n   Reading starts at offset *BASEP, and *BASEP is updated with the new\n   position after reading.  Returns the number of bytes read; zero when at\n   end of directory; or -1 for errors.  */\n# ifndef __USE_FILE_OFFSET64\nextern __ssize_t getdirentries (int __fd, char *__restrict __buf,\n				size_t __nbytes,\n				__off_t *__restrict __basep)\n     __THROW __nonnull ((2, 4));\n# else\n#  ifdef __REDIRECT\nextern __ssize_t __REDIRECT_NTH (getdirentries,\n				 (int __fd, char *__restrict __buf,\n				  size_t __nbytes,\n				  __off64_t *__restrict __basep),\n				 getdirentries64) __nonnull ((2, 4));\n#  else\n#   define getdirentries getdirentries64\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\nextern __ssize_t getdirentries64 (int __fd, char *__restrict __buf,\n				  size_t __nbytes,\n				  __off64_t *__restrict __basep)\n     __THROW __nonnull ((2, 4));\n# endif\n#endif /* Use BSD or misc.  */\n\n#ifdef __USE_GNU\n/* Function to compare two `struct dirent's by name & version.  */\n# ifndef __USE_FILE_OFFSET64\nextern int versionsort (const struct dirent **__e1,\n			const struct dirent **__e2)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n# else\n#  ifdef __REDIRECT\nextern int __REDIRECT_NTH (versionsort,\n			   (const struct dirent **__e1,\n			    const struct dirent **__e2),\n			   versionsort64)\n     __attribute_pure__ __nonnull ((1, 2));\n#  else\n#   define versionsort versionsort64\n#  endif\n# endif\n\n# ifdef __USE_LARGEFILE64\nextern int versionsort64 (const struct dirent64 **__e1,\n			  const struct dirent64 **__e2)\n     __THROW __attribute_pure__ __nonnull ((1, 2));\n# endif\n#endif /* Use GNU.  */\n\n__END_DECLS\n\n#endif /* dirent.h  */\n",
			"file": "/usr/include/dirent.h",
			"file_size": 12602,
			"file_write_time": 130693568210000000,
			"settings":
			{
				"buffer_size": 12603,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/usr/include/x86_64-linux-gnu/bits/dirent.h",
			"settings":
			{
				"buffer_size": 1728,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/tools/hciconfig.c",
			"settings":
			{
				"buffer_size": 47688,
				"line_ending": "Unix"
			}
		},
		{
			"file": "/home/jack/projects/opensource/bluez/tools/hcitool.c",
			"settings":
			{
				"buffer_size": 72309,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 75.0,
		"last_filter": "instal",
		"selected_items":
		[
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"package in",
				"Package Control: Install Package"
			],
			[
				"Package",
				"Package Control: Install Package"
			],
			[
				"Pack",
				"Package Control: Install Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 54.0,
		"history":
		[
			"view.run_command('run_lint')",
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jack/projects/jack-fancycode-samples/bluez/le/browser",
		"/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth"
	],
	"file_history":
	[
		"/home/jack/projects/opensource/bluez/acinclude.m4",
		"/home/jack/projects/opensource/bluez/Makefile.tools",
		"/home/jack/projects/opensource/bluez/tools/hciconfig.c",
		"/home/jack/projects/opensource/bluez/Makefile",
		"/home/jack/projects/jack-fancycode-samples/bluez/le/browser/Makefile",
		"/usr/include/x86_64-linux-gnu/bits/dirent.h",
		"/home/jack/.config/sublime-text-3/Packages/User/run_lint.py",
		"/home/jack/projects/jack-fancycode-samples/bluez/le/browser/browser.c",
		"/home/jack/Downloads/한글자막_채피_chappie_2015_1080p_web_rip_h264_aac_kingdom___액션1.smi",
		"/home/jack/Downloads/Chappie 2015 1080p BRRip x264 DTS-JYK.smi",
		"/home/jack/projects/jack-fancycode-samples/bluez/le/browser/test.cpp",
		"/home/jack/projects/AppConnector/appconnector-sdk/b2ap/hu/build/android/customer/obigo/app/src/main/java/com/obigo/b2ap/B2apMainActivity.java",
		"/home/jack/projects/AppConnector/appconnector-sdk/b2ap/hu/b2apd/acp/src/AcpPortMapTables.c",
		"/home/jack/projects/AppConnector/appconnector-sdk/b2ap/hu/b2apd/acp/include/AcpPortMapTables.h",
		"/home/jack/projects/AppConnector/appconnector-sdk/b2ap/hu/customer/obigo/android/iap/include/allgo/iAPAcc_common.h",
		"/home/jack/projects/AppConnector/appconnector-sdk/b2ap/hu/b2apd/acp/include/AcpInterfaces.h",
		"/home/jack/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/jack/.config/sublime-text-3/Packages/User/Distraction Free.sublime-settings",
		"/home/jack/.config/sublime-text-3/Packages/User/Plain text.sublime-settings",
		"/home/jack/projects/target/imx6/android/boundary-imx_jb4.3_1.0.0-ga/device/boundary/AndroidProducts.mk",
		"/home/jack/projects/target/imx6/android/boundary-imx_jb4.3_1.0.0-ga/device/boundary/cad/overlay/packages/apps/Launcher2/res/values/config.xml"
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
		"height": 93.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"proto_ops",
			"ioctl",
			"hci_sock_ioctl",
			"HCIDEVUP",
			"LE",
			"hci_read_local_name",
			"name",
			"cmd_lescan",
			"le",
			"HCIGETDEVINFO",
			"hci_dev_info",
			"hciconfig",
			"hci_dev_info",
			"HCISETSCAN",
			"command",
			"cmd_scan",
			"scan",
			"PF_BLUETOOTH",
			"AF_BLUETOOTH",
			"hci_dev_info",
			"hci_get_devs",
			"hci_get_route",
			"bdaddr_t",
			"hci_get_route",
			"bdaddr_t",
			"hci_get_route",
			"IREQ_CACHE_FLUSH",
			"d_type",
			"Customer_CallbackStopSession",
			"gAppConnectorCallbackHandle",
			"B2APTL_Init",
			"gCallbackHandle",
			"AcpSessionStopCallback",
			"B2AP_SESSION_DOWN",
			"B2APT_Notify_StopSession",
			"gnu",
			"fromelf",
			"CFLAGS",
			"SKIP_WPA_SUPPLICANT_RTL",
			"wpa_supplicant",
			"syntax",
			"make"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 7,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "/usr/include/bluetooth/hci_lib.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9916,
						"regions":
						{
						},
						"selection":
						[
							[
								1891,
								1891
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 602.0,
						"zoom_level": 1.0
					},
					"stack_index": 17,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "Makefile",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1525,
						"regions":
						{
						},
						"selection":
						[
							[
								10,
								10
							]
						],
						"settings":
						{
							"syntax": "Packages/Makefile/Makefile.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "hcilocal.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 525,
						"regions":
						{
						},
						"selection":
						[
							[
								475,
								475
							]
						],
						"settings":
						{
							"auto_name": "",
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "browser.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2967,
						"regions":
						{
						},
						"selection":
						[
							[
								1286,
								1286
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1360.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "/usr/include/x86_64-linux-gnu/bits/socket.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12741,
						"regions":
						{
						},
						"selection":
						[
							[
								2306,
								2306
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 918.0,
						"zoom_level": 1.0
					},
					"stack_index": 22,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "/usr/include/bluetooth/bluetooth.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7588,
						"regions":
						{
						},
						"selection":
						[
							[
								1244,
								1244
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 296.0,
						"zoom_level": 1.0
					},
					"stack_index": 21,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/usr/include/bluetooth/hci.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 61964,
						"regions":
						{
						},
						"selection":
						[
							[
								2113,
								2113
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4689.0,
						"zoom_level": 1.0
					},
					"stack_index": 18,
					"type": "text"
				},
				{
					"buffer": 7,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 374479,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										144,
										157
									],
									[
										470,
										483
									],
									[
										618,
										631
									],
									[
										742,
										755
									],
									[
										921,
										934
									],
									[
										1186,
										1199
									],
									[
										1434,
										1447
									],
									[
										1653,
										1666
									],
									[
										1835,
										1848
									],
									[
										2056,
										2069
									],
									[
										2199,
										2212
									],
									[
										2442,
										2455
									],
									[
										2665,
										2678
									],
									[
										2815,
										2828
									],
									[
										3014,
										3027
									],
									[
										3222,
										3230
									],
									[
										3564,
										3572
									],
									[
										3884,
										3892
									],
									[
										4119,
										4127
									],
									[
										4375,
										4383
									],
									[
										4644,
										4652
									],
									[
										4784,
										4792
									],
									[
										4990,
										4998
									],
									[
										5234,
										5242
									],
									[
										5453,
										5461
									],
									[
										5682,
										5690
									],
									[
										5956,
										5964
									],
									[
										6165,
										6173
									],
									[
										6369,
										6377
									],
									[
										6793,
										6798
									],
									[
										6946,
										6951
									],
									[
										7270,
										7275
									],
									[
										7445,
										7450
									],
									[
										7551,
										7556
									],
									[
										7628,
										7633
									],
									[
										7938,
										7943
									],
									[
										8124,
										8129
									],
									[
										8315,
										8320
									],
									[
										8414,
										8419
									],
									[
										8580,
										8585
									],
									[
										8766,
										8771
									],
									[
										8985,
										8990
									],
									[
										8991,
										8996
									],
									[
										9091,
										9096
									],
									[
										9292,
										9297
									],
									[
										9458,
										9463
									],
									[
										9582,
										9587
									],
									[
										9658,
										9663
									],
									[
										9855,
										9860
									],
									[
										9928,
										9933
									],
									[
										10092,
										10097
									],
									[
										10244,
										10249
									],
									[
										10423,
										10428
									],
									[
										10575,
										10580
									],
									[
										10647,
										10652
									],
									[
										10810,
										10815
									],
									[
										10950,
										10955
									],
									[
										11194,
										11199
									],
									[
										11268,
										11273
									],
									[
										11627,
										11632
									],
									[
										12028,
										12033
									],
									[
										12246,
										12251
									],
									[
										12307,
										12312
									],
									[
										12385,
										12390
									],
									[
										12441,
										12446
									],
									[
										12523,
										12528
									],
									[
										12606,
										12611
									],
									[
										12691,
										12696
									],
									[
										12781,
										12786
									],
									[
										12884,
										12889
									],
									[
										12959,
										12964
									],
									[
										13008,
										13013
									],
									[
										13061,
										13066
									],
									[
										13114,
										13119
									],
									[
										13167,
										13172
									],
									[
										13219,
										13224
									],
									[
										13361,
										13366
									],
									[
										13441,
										13446
									],
									[
										13526,
										13531
									],
									[
										13611,
										13616
									],
									[
										13679,
										13684
									],
									[
										13764,
										13769
									],
									[
										13849,
										13854
									],
									[
										13932,
										13937
									],
									[
										14015,
										14020
									],
									[
										14081,
										14086
									],
									[
										14138,
										14143
									],
									[
										14199,
										14204
									],
									[
										14268,
										14273
									],
									[
										14337,
										14342
									],
									[
										14497,
										14502
									],
									[
										14671,
										14676
									],
									[
										14845,
										14850
									],
									[
										15014,
										15019
									],
									[
										15174,
										15179
									],
									[
										15336,
										15341
									],
									[
										15514,
										15519
									],
									[
										15650,
										15655
									],
									[
										15762,
										15767
									],
									[
										15882,
										15887
									],
									[
										16114,
										16119
									],
									[
										16232,
										16237
									],
									[
										16281,
										16286
									],
									[
										16358,
										16363
									],
									[
										16481,
										16486
									],
									[
										16586,
										16591
									],
									[
										16743,
										16748
									],
									[
										16854,
										16859
									],
									[
										16899,
										16904
									],
									[
										16950,
										16955
									],
									[
										17145,
										17150
									],
									[
										17255,
										17260
									],
									[
										17378,
										17383
									],
									[
										17462,
										17467
									],
									[
										17560,
										17565
									],
									[
										17655,
										17660
									],
									[
										17752,
										17757
									],
									[
										17860,
										17865
									],
									[
										17890,
										17895
									],
									[
										17977,
										17982
									],
									[
										18013,
										18018
									],
									[
										18039,
										18044
									],
									[
										18261,
										18266
									],
									[
										18540,
										18545
									],
									[
										18869,
										18874
									],
									[
										19121,
										19126
									],
									[
										19205,
										19210
									],
									[
										19243,
										19248
									],
									[
										19283,
										19288
									],
									[
										19366,
										19371
									],
									[
										19650,
										19655
									],
									[
										19795,
										19800
									],
									[
										19920,
										19925
									],
									[
										20039,
										20044
									],
									[
										20138,
										20143
									],
									[
										20340,
										20345
									],
									[
										20371,
										20376
									],
									[
										20402,
										20407
									],
									[
										20413,
										20418
									],
									[
										20431,
										20436
									],
									[
										20560,
										20565
									],
									[
										20762,
										20767
									],
									[
										20936,
										20941
									],
									[
										21103,
										21108
									],
									[
										21277,
										21282
									],
									[
										21474,
										21479
									],
									[
										21572,
										21577
									],
									[
										21586,
										21591
									],
									[
										21687,
										21692
									],
									[
										21704,
										21709
									],
									[
										21821,
										21826
									],
									[
										21835,
										21840
									],
									[
										21966,
										21971
									],
									[
										21985,
										21990
									],
									[
										22007,
										22012
									],
									[
										22020,
										22025
									],
									[
										22101,
										22106
									],
									[
										22118,
										22123
									],
									[
										22302,
										22307
									],
									[
										22410,
										22415
									],
									[
										22509,
										22514
									],
									[
										22525,
										22530
									],
									[
										22622,
										22627
									],
									[
										22638,
										22643
									],
									[
										22659,
										22664
									],
									[
										22672,
										22677
									],
									[
										22786,
										22791
									],
									[
										22809,
										22814
									],
									[
										22825,
										22830
									],
									[
										22923,
										22928
									],
									[
										22939,
										22944
									],
									[
										23039,
										23044
									],
									[
										23055,
										23060
									],
									[
										23155,
										23160
									],
									[
										23170,
										23175
									],
									[
										23269,
										23274
									],
									[
										23279,
										23284
									],
									[
										23429,
										23434
									],
									[
										23443,
										23448
									],
									[
										23571,
										23576
									],
									[
										23585,
										23590
									],
									[
										23684,
										23689
									],
									[
										23707,
										23712
									],
									[
										23721,
										23726
									],
									[
										23817,
										23822
									],
									[
										23835,
										23840
									],
									[
										23928,
										23933
									],
									[
										23952,
										23957
									],
									[
										23969,
										23974
									],
									[
										24065,
										24070
									],
									[
										24081,
										24086
									],
									[
										24193,
										24198
									],
									[
										24211,
										24216
									],
									[
										24312,
										24317
									],
									[
										24330,
										24335
									],
									[
										24430,
										24435
									],
									[
										24447,
										24452
									],
									[
										24547,
										24552
									],
									[
										24571,
										24576
									],
									[
										24586,
										24591
									],
									[
										24703,
										24708
									],
									[
										24726,
										24731
									],
									[
										24743,
										24748
									],
									[
										24861,
										24866
									],
									[
										24876,
										24881
									],
									[
										25021,
										25026
									],
									[
										25036,
										25041
									],
									[
										25142,
										25147
									],
									[
										25160,
										25165
									],
									[
										25263,
										25268
									],
									[
										25279,
										25284
									],
									[
										25421,
										25426
									],
									[
										25437,
										25442
									],
									[
										25578,
										25583
									],
									[
										25593,
										25598
									],
									[
										25759,
										25764
									],
									[
										25773,
										25778
									],
									[
										25921,
										25926
									],
									[
										25942,
										25947
									],
									[
										26092,
										26097
									],
									[
										26145,
										26150
									],
									[
										26202,
										26207
									],
									[
										26264,
										26269
									],
									[
										26328,
										26333
									],
									[
										26375,
										26380
									],
									[
										26444,
										26449
									],
									[
										26515,
										26520
									],
									[
										26583,
										26588
									],
									[
										26656,
										26661
									],
									[
										26734,
										26739
									],
									[
										26815,
										26820
									],
									[
										26895,
										26900
									],
									[
										26972,
										26977
									],
									[
										27057,
										27062
									],
									[
										27130,
										27135
									],
									[
										27203,
										27208
									],
									[
										27274,
										27279
									],
									[
										27343,
										27348
									],
									[
										27433,
										27438
									],
									[
										27504,
										27509
									],
									[
										27573,
										27578
									],
									[
										27639,
										27644
									],
									[
										27706,
										27711
									],
									[
										27775,
										27780
									],
									[
										27840,
										27845
									],
									[
										27911,
										27916
									],
									[
										27983,
										27988
									],
									[
										28055,
										28060
									],
									[
										28125,
										28130
									],
									[
										28205,
										28210
									],
									[
										28277,
										28282
									],
									[
										28357,
										28362
									],
									[
										28445,
										28450
									],
									[
										28505,
										28510
									],
									[
										28573,
										28578
									],
									[
										28638,
										28643
									],
									[
										28702,
										28707
									],
									[
										28767,
										28772
									],
									[
										28832,
										28837
									],
									[
										28900,
										28905
									],
									[
										28965,
										28970
									],
									[
										29034,
										29039
									],
									[
										29101,
										29106
									],
									[
										29167,
										29172
									],
									[
										29229,
										29234
									],
									[
										29293,
										29298
									],
									[
										29358,
										29363
									],
									[
										29431,
										29436
									],
									[
										29518,
										29523
									],
									[
										29613,
										29618
									],
									[
										29666,
										29671
									],
									[
										29719,
										29724
									],
									[
										29792,
										29797
									],
									[
										29863,
										29868
									],
									[
										29937,
										29942
									],
									[
										30010,
										30015
									],
									[
										30084,
										30089
									],
									[
										30168,
										30173
									],
									[
										30245,
										30250
									],
									[
										30329,
										30334
									],
									[
										30413,
										30418
									],
									[
										30497,
										30502
									],
									[
										30581,
										30586
									],
									[
										30657,
										30662
									],
									[
										30733,
										30738
									],
									[
										30810,
										30815
									],
									[
										30891,
										30896
									],
									[
										30972,
										30977
									],
									[
										31057,
										31062
									],
									[
										31146,
										31151
									],
									[
										31260,
										31265
									],
									[
										31382,
										31387
									],
									[
										31469,
										31474
									],
									[
										31566,
										31571
									],
									[
										31649,
										31654
									],
									[
										31725,
										31730
									],
									[
										31801,
										31806
									],
									[
										31866,
										31871
									],
									[
										31953,
										31958
									],
									[
										32045,
										32050
									],
									[
										32131,
										32136
									],
									[
										32214,
										32219
									],
									[
										32305,
										32310
									],
									[
										32399,
										32404
									],
									[
										32480,
										32485
									],
									[
										32561,
										32566
									],
									[
										32639,
										32644
									],
									[
										32738,
										32743
									],
									[
										32833,
										32838
									],
									[
										32938,
										32943
									],
									[
										33018,
										33023
									],
									[
										33070,
										33075
									],
									[
										33378,
										33383
									],
									[
										33643,
										33648
									],
									[
										33941,
										33946
									],
									[
										34150,
										34155
									],
									[
										34299,
										34304
									],
									[
										34423,
										34428
									],
									[
										34542,
										34547
									],
									[
										34629,
										34634
									],
									[
										34900,
										34905
									],
									[
										35168,
										35173
									],
									[
										35341,
										35346
									],
									[
										35485,
										35490
									],
									[
										35637,
										35642
									],
									[
										35774,
										35779
									],
									[
										35909,
										35914
									],
									[
										36067,
										36072
									],
									[
										36206,
										36211
									],
									[
										36356,
										36361
									],
									[
										36494,
										36499
									],
									[
										36644,
										36649
									],
									[
										36793,
										36798
									],
									[
										36937,
										36942
									],
									[
										37169,
										37174
									],
									[
										37267,
										37272
									],
									[
										37304,
										37309
									],
									[
										37447,
										37452
									],
									[
										37543,
										37548
									],
									[
										37645,
										37650
									],
									[
										37744,
										37749
									],
									[
										37825,
										37830
									],
									[
										37908,
										37913
									],
									[
										38007,
										38012
									],
									[
										38086,
										38091
									],
									[
										38182,
										38187
									],
									[
										38265,
										38270
									],
									[
										38370,
										38375
									],
									[
										38455,
										38460
									],
									[
										38540,
										38545
									],
									[
										38630,
										38635
									],
									[
										38715,
										38720
									],
									[
										38939,
										38944
									],
									[
										38976,
										38981
									],
									[
										39129,
										39134
									],
									[
										39225,
										39230
									],
									[
										39306,
										39311
									],
									[
										39385,
										39390
									],
									[
										39501,
										39506
									],
									[
										39616,
										39621
									],
									[
										39731,
										39736
									],
									[
										39846,
										39851
									],
									[
										39961,
										39966
									],
									[
										40074,
										40079
									],
									[
										40185,
										40190
									],
									[
										40306,
										40311
									],
									[
										40416,
										40421
									],
									[
										40539,
										40544
									],
									[
										40663,
										40668
									],
									[
										40787,
										40792
									],
									[
										40903,
										40908
									],
									[
										41015,
										41020
									],
									[
										41127,
										41132
									],
									[
										41256,
										41261
									],
									[
										41388,
										41393
									],
									[
										41498,
										41503
									],
									[
										41612,
										41617
									],
									[
										41725,
										41730
									],
									[
										41854,
										41859
									],
									[
										41984,
										41989
									],
									[
										42078,
										42083
									],
									[
										42168,
										42173
									],
									[
										42258,
										42263
									],
									[
										42376,
										42381
									],
									[
										42491,
										42496
									],
									[
										42609,
										42614
									],
									[
										42722,
										42727
									],
									[
										42846,
										42851
									],
									[
										42976,
										42981
									],
									[
										43103,
										43108
									],
									[
										43234,
										43239
									],
									[
										43365,
										43370
									],
									[
										43502,
										43507
									],
									[
										43653,
										43658
									],
									[
										43774,
										43779
									],
									[
										43913,
										43918
									],
									[
										44041,
										44046
									],
									[
										44183,
										44188
									],
									[
										44325,
										44330
									],
									[
										44438,
										44443
									],
									[
										44581,
										44586
									],
									[
										44726,
										44731
									],
									[
										44841,
										44846
									],
									[
										45092,
										45097
									],
									[
										45237,
										45242
									],
									[
										45528,
										45533
									],
									[
										45695,
										45700
									],
									[
										45732,
										45737
									],
									[
										45848,
										45853
									],
									[
										46010,
										46015
									],
									[
										46106,
										46111
									],
									[
										46204,
										46209
									],
									[
										46285,
										46290
									],
									[
										46365,
										46370
									],
									[
										46463,
										46468
									],
									[
										46563,
										46568
									],
									[
										46665,
										46670
									],
									[
										46763,
										46768
									],
									[
										46859,
										46864
									],
									[
										46963,
										46968
									],
									[
										47060,
										47065
									],
									[
										47158,
										47163
									],
									[
										47415,
										47420
									],
									[
										47635,
										47640
									],
									[
										47869,
										47874
									],
									[
										48124,
										48129
									],
									[
										48342,
										48347
									],
									[
										48591,
										48596
									],
									[
										48659,
										48664
									],
									[
										48692,
										48697
									],
									[
										48762,
										48767
									],
									[
										49051,
										49056
									],
									[
										49350,
										49355
									],
									[
										49636,
										49641
									],
									[
										49721,
										49726
									],
									[
										49999,
										50004
									],
									[
										50050,
										50055
									],
									[
										50165,
										50170
									],
									[
										50280,
										50285
									],
									[
										50397,
										50402
									],
									[
										50522,
										50527
									],
									[
										50647,
										50652
									],
									[
										50768,
										50773
									],
									[
										51023,
										51028
									],
									[
										51152,
										51157
									],
									[
										51289,
										51294
									],
									[
										51428,
										51433
									],
									[
										51567,
										51572
									],
									[
										51791,
										51796
									],
									[
										51909,
										51914
									],
									[
										52021,
										52026
									],
									[
										52163,
										52168
									],
									[
										52308,
										52313
									],
									[
										52445,
										52450
									],
									[
										52584,
										52589
									],
									[
										52777,
										52782
									],
									[
										52814,
										52819
									],
									[
										52967,
										52972
									],
									[
										53068,
										53073
									],
									[
										53157,
										53162
									],
									[
										53266,
										53271
									],
									[
										53355,
										53360
									],
									[
										53470,
										53475
									],
									[
										53555,
										53560
									],
									[
										53639,
										53644
									],
									[
										53742,
										53747
									],
									[
										53847,
										53852
									],
									[
										53954,
										53959
									],
									[
										54055,
										54060
									],
									[
										54158,
										54163
									],
									[
										54292,
										54297
									],
									[
										54401,
										54406
									],
									[
										54514,
										54519
									],
									[
										54619,
										54624
									],
									[
										54729,
										54734
									],
									[
										54904,
										54909
									],
									[
										55156,
										55161
									],
									[
										55360,
										55365
									],
									[
										55611,
										55616
									],
									[
										55804,
										55809
									],
									[
										56130,
										56135
									],
									[
										56250,
										56255
									],
									[
										56287,
										56292
									],
									[
										56473,
										56478
									],
									[
										56638,
										56643
									],
									[
										56748,
										56753
									],
									[
										56840,
										56845
									],
									[
										56953,
										56958
									],
									[
										57045,
										57050
									],
									[
										57136,
										57141
									],
									[
										57225,
										57230
									],
									[
										57344,
										57349
									],
									[
										57432,
										57437
									],
									[
										57541,
										57546
									],
									[
										57652,
										57657
									],
									[
										57765,
										57770
									],
									[
										57878,
										57883
									],
									[
										57993,
										57998
									],
									[
										58106,
										58111
									],
									[
										58219,
										58224
									],
									[
										58334,
										58339
									],
									[
										58449,
										58454
									],
									[
										58537,
										58542
									],
									[
										58650,
										58655
									],
									[
										58761,
										58766
									],
									[
										58882,
										58887
									],
									[
										58997,
										59002
									],
									[
										59112,
										59117
									],
									[
										59205,
										59210
									],
									[
										59320,
										59325
									],
									[
										59442,
										59447
									],
									[
										59579,
										59584
									],
									[
										59697,
										59702
									],
									[
										59821,
										59826
									],
									[
										59939,
										59944
									],
									[
										60060,
										60065
									],
									[
										60184,
										60189
									],
									[
										60320,
										60325
									],
									[
										60452,
										60457
									],
									[
										60553,
										60558
									],
									[
										60660,
										60665
									],
									[
										60796,
										60801
									],
									[
										60932,
										60937
									],
									[
										61050,
										61055
									],
									[
										61348,
										61353
									],
									[
										61618,
										61623
									],
									[
										61807,
										61812
									],
									[
										62058,
										62063
									],
									[
										62245,
										62250
									],
									[
										62432,
										62437
									],
									[
										62570,
										62575
									],
									[
										62680,
										62685
									],
									[
										62796,
										62801
									],
									[
										62923,
										62928
									],
									[
										63178,
										63183
									],
									[
										63351,
										63356
									],
									[
										63503,
										63508
									],
									[
										63603,
										63608
									],
									[
										63701,
										63706
									],
									[
										63801,
										63806
									],
									[
										63903,
										63908
									],
									[
										64003,
										64008
									],
									[
										64110,
										64115
									],
									[
										64176,
										64181
									],
									[
										64231,
										64236
									],
									[
										64389,
										64394
									],
									[
										64510,
										64515
									],
									[
										64625,
										64630
									],
									[
										64749,
										64754
									],
									[
										64873,
										64878
									],
									[
										64997,
										65002
									],
									[
										65124,
										65129
									],
									[
										65253,
										65258
									],
									[
										65374,
										65379
									],
									[
										65483,
										65488
									],
									[
										65724,
										65729
									],
									[
										65892,
										65897
									],
									[
										65993,
										65998
									],
									[
										66092,
										66097
									],
									[
										66193,
										66198
									],
									[
										66291,
										66296
									],
									[
										66393,
										66398
									],
									[
										66498,
										66503
									],
									[
										66604,
										66609
									],
									[
										66713,
										66718
									],
									[
										66793,
										66798
									],
									[
										66896,
										66901
									],
									[
										67028,
										67033
									],
									[
										67135,
										67140
									],
									[
										67240,
										67245
									],
									[
										67490,
										67495
									],
									[
										67689,
										67694
									],
									[
										67742,
										67747
									],
									[
										67872,
										67877
									],
									[
										68012,
										68017
									],
									[
										68073,
										68078
									],
									[
										68185,
										68190
									],
									[
										68243,
										68248
									],
									[
										68421,
										68426
									],
									[
										68482,
										68487
									],
									[
										68541,
										68546
									],
									[
										68622,
										68627
									],
									[
										68779,
										68784
									],
									[
										68917,
										68922
									],
									[
										69084,
										69089
									],
									[
										69318,
										69323
									],
									[
										69402,
										69407
									],
									[
										69537,
										69542
									],
									[
										69720,
										69725
									],
									[
										69968,
										69973
									],
									[
										70099,
										70104
									],
									[
										70244,
										70249
									],
									[
										70376,
										70381
									],
									[
										70513,
										70518
									],
									[
										70662,
										70667
									],
									[
										70726,
										70731
									],
									[
										70849,
										70854
									],
									[
										71127,
										71132
									],
									[
										71373,
										71378
									],
									[
										71568,
										71573
									],
									[
										71686,
										71691
									],
									[
										71832,
										71837
									],
									[
										71893,
										71898
									],
									[
										72020,
										72025
									],
									[
										72036,
										72041
									],
									[
										72189,
										72194
									],
									[
										72466,
										72471
									],
									[
										72650,
										72655
									],
									[
										72873,
										72878
									],
									[
										73183,
										73188
									],
									[
										73251,
										73256
									],
									[
										73411,
										73416
									],
									[
										73487,
										73492
									],
									[
										73731,
										73736
									],
									[
										73883,
										73888
									],
									[
										73959,
										73964
									],
									[
										74091,
										74096
									],
									[
										74325,
										74330
									],
									[
										74518,
										74523
									],
									[
										74733,
										74738
									],
									[
										74923,
										74928
									],
									[
										75122,
										75127
									],
									[
										75194,
										75199
									],
									[
										75399,
										75404
									],
									[
										75466,
										75471
									],
									[
										75650,
										75655
									],
									[
										75861,
										75866
									],
									[
										76099,
										76104
									],
									[
										76204,
										76209
									],
									[
										76367,
										76372
									],
									[
										76579,
										76584
									],
									[
										76734,
										76739
									],
									[
										76832,
										76837
									],
									[
										76846,
										76851
									],
									[
										76947,
										76952
									],
									[
										76964,
										76969
									],
									[
										77081,
										77086
									],
									[
										77095,
										77100
									],
									[
										77226,
										77231
									],
									[
										77245,
										77250
									],
									[
										77267,
										77272
									],
									[
										77280,
										77285
									],
									[
										77361,
										77366
									],
									[
										77378,
										77383
									],
									[
										77562,
										77567
									],
									[
										77670,
										77675
									],
									[
										77769,
										77774
									],
									[
										77785,
										77790
									],
									[
										77882,
										77887
									],
									[
										77898,
										77903
									],
									[
										77919,
										77924
									],
									[
										77932,
										77937
									],
									[
										78046,
										78051
									],
									[
										78069,
										78074
									],
									[
										78085,
										78090
									],
									[
										78183,
										78188
									],
									[
										78199,
										78204
									],
									[
										78299,
										78304
									],
									[
										78315,
										78320
									],
									[
										78415,
										78420
									],
									[
										78430,
										78435
									],
									[
										78529,
										78534
									],
									[
										78539,
										78544
									],
									[
										78689,
										78694
									],
									[
										78703,
										78708
									],
									[
										78831,
										78836
									],
									[
										78845,
										78850
									],
									[
										78944,
										78949
									],
									[
										78967,
										78972
									],
									[
										78981,
										78986
									],
									[
										79077,
										79082
									],
									[
										79095,
										79100
									],
									[
										79188,
										79193
									],
									[
										79212,
										79217
									],
									[
										79229,
										79234
									],
									[
										79325,
										79330
									],
									[
										79341,
										79346
									],
									[
										79453,
										79458
									],
									[
										79471,
										79476
									],
									[
										79572,
										79577
									],
									[
										79590,
										79595
									],
									[
										79690,
										79695
									],
									[
										79707,
										79712
									],
									[
										79807,
										79812
									],
									[
										79831,
										79836
									],
									[
										79846,
										79851
									],
									[
										79963,
										79968
									],
									[
										79986,
										79991
									],
									[
										80003,
										80008
									],
									[
										80121,
										80126
									],
									[
										80136,
										80141
									],
									[
										80281,
										80286
									],
									[
										80296,
										80301
									],
									[
										80402,
										80407
									],
									[
										80420,
										80425
									],
									[
										80523,
										80528
									],
									[
										80539,
										80544
									],
									[
										80681,
										80686
									],
									[
										80697,
										80702
									],
									[
										80838,
										80843
									],
									[
										80853,
										80858
									],
									[
										80987,
										80992
									],
									[
										81001,
										81006
									],
									[
										81156,
										81161
									],
									[
										81177,
										81182
									],
									[
										81323,
										81328
									],
									[
										81376,
										81381
									],
									[
										81433,
										81438
									],
									[
										81495,
										81500
									],
									[
										81559,
										81564
									],
									[
										81606,
										81611
									],
									[
										81675,
										81680
									],
									[
										81746,
										81751
									],
									[
										81814,
										81819
									],
									[
										81887,
										81892
									],
									[
										81965,
										81970
									],
									[
										82046,
										82051
									],
									[
										82126,
										82131
									],
									[
										82203,
										82208
									],
									[
										82288,
										82293
									],
									[
										82361,
										82366
									],
									[
										82434,
										82439
									],
									[
										82505,
										82510
									],
									[
										82574,
										82579
									],
									[
										82664,
										82669
									],
									[
										82735,
										82740
									],
									[
										82804,
										82809
									],
									[
										82870,
										82875
									],
									[
										82937,
										82942
									],
									[
										83006,
										83011
									],
									[
										83071,
										83076
									],
									[
										83142,
										83147
									],
									[
										83214,
										83219
									],
									[
										83286,
										83291
									],
									[
										83356,
										83361
									],
									[
										83436,
										83441
									],
									[
										83508,
										83513
									],
									[
										83588,
										83593
									],
									[
										83676,
										83681
									],
									[
										83736,
										83741
									],
									[
										83804,
										83809
									],
									[
										83869,
										83874
									],
									[
										83933,
										83938
									],
									[
										83998,
										84003
									],
									[
										84063,
										84068
									],
									[
										84131,
										84136
									],
									[
										84196,
										84201
									],
									[
										84265,
										84270
									],
									[
										84332,
										84337
									],
									[
										84398,
										84403
									],
									[
										84460,
										84465
									],
									[
										84524,
										84529
									],
									[
										84589,
										84594
									],
									[
										84662,
										84667
									],
									[
										84749,
										84754
									],
									[
										84844,
										84849
									],
									[
										84897,
										84902
									],
									[
										84950,
										84955
									],
									[
										85023,
										85028
									],
									[
										85094,
										85099
									],
									[
										85168,
										85173
									],
									[
										85241,
										85246
									],
									[
										85315,
										85320
									],
									[
										85399,
										85404
									],
									[
										85476,
										85481
									],
									[
										85560,
										85565
									],
									[
										85644,
										85649
									],
									[
										85728,
										85733
									],
									[
										85812,
										85817
									],
									[
										85888,
										85893
									],
									[
										85964,
										85969
									],
									[
										86041,
										86046
									],
									[
										86122,
										86127
									],
									[
										86203,
										86208
									],
									[
										86288,
										86293
									],
									[
										86377,
										86382
									],
									[
										86459,
										86464
									],
									[
										86549,
										86554
									],
									[
										86636,
										86641
									],
									[
										86733,
										86738
									],
									[
										86816,
										86821
									],
									[
										86892,
										86897
									],
									[
										86968,
										86973
									],
									[
										87033,
										87038
									],
									[
										87120,
										87125
									],
									[
										87212,
										87217
									],
									[
										87298,
										87303
									],
									[
										87381,
										87386
									],
									[
										87472,
										87477
									],
									[
										87566,
										87571
									],
									[
										87647,
										87652
									],
									[
										87728,
										87733
									],
									[
										87806,
										87811
									],
									[
										87905,
										87910
									],
									[
										88000,
										88005
									],
									[
										88105,
										88110
									],
									[
										88185,
										88190
									],
									[
										88237,
										88242
									],
									[
										88545,
										88550
									],
									[
										88813,
										88818
									],
									[
										89112,
										89117
									],
									[
										89321,
										89326
									],
									[
										89470,
										89475
									],
									[
										89594,
										89599
									],
									[
										89713,
										89718
									],
									[
										89800,
										89805
									],
									[
										89875,
										89880
									],
									[
										90116,
										90121
									],
									[
										90318,
										90323
									],
									[
										90355,
										90360
									],
									[
										90505,
										90510
									],
									[
										90601,
										90606
									],
									[
										90682,
										90687
									],
									[
										90761,
										90766
									],
									[
										90877,
										90882
									],
									[
										90992,
										90997
									],
									[
										91107,
										91112
									],
									[
										91222,
										91227
									],
									[
										91337,
										91342
									],
									[
										91450,
										91455
									],
									[
										91561,
										91566
									],
									[
										91682,
										91687
									],
									[
										91792,
										91797
									],
									[
										91915,
										91920
									],
									[
										92039,
										92044
									],
									[
										92163,
										92168
									],
									[
										92279,
										92284
									],
									[
										92391,
										92396
									],
									[
										92503,
										92508
									],
									[
										92632,
										92637
									],
									[
										92764,
										92769
									],
									[
										92874,
										92879
									],
									[
										92988,
										92993
									],
									[
										93101,
										93106
									],
									[
										93230,
										93235
									],
									[
										93360,
										93365
									],
									[
										93454,
										93459
									],
									[
										93544,
										93549
									],
									[
										93634,
										93639
									],
									[
										93752,
										93757
									],
									[
										93867,
										93872
									],
									[
										93985,
										93990
									],
									[
										94098,
										94103
									],
									[
										94222,
										94227
									],
									[
										94352,
										94357
									],
									[
										94479,
										94484
									],
									[
										94610,
										94615
									],
									[
										94741,
										94746
									],
									[
										94878,
										94883
									],
									[
										95029,
										95034
									],
									[
										95150,
										95155
									],
									[
										95289,
										95294
									],
									[
										95417,
										95422
									],
									[
										95559,
										95564
									],
									[
										95701,
										95706
									],
									[
										95814,
										95819
									],
									[
										95957,
										95962
									],
									[
										96102,
										96107
									],
									[
										96217,
										96222
									],
									[
										96348,
										96353
									],
									[
										96591,
										96596
									],
									[
										96736,
										96741
									],
									[
										97027,
										97032
									],
									[
										97188,
										97193
									],
									[
										97225,
										97230
									],
									[
										97352,
										97357
									],
									[
										97463,
										97468
									],
									[
										97556,
										97561
									],
									[
										97650,
										97655
									],
									[
										97743,
										97748
									],
									[
										97856,
										97861
									],
									[
										97971,
										97976
									],
									[
										98082,
										98087
									],
									[
										98176,
										98181
									],
									[
										98408,
										98413
									],
									[
										98445,
										98450
									],
									[
										98561,
										98566
									],
									[
										98723,
										98728
									],
									[
										98819,
										98824
									],
									[
										98912,
										98917
									],
									[
										98993,
										98998
									],
									[
										99073,
										99078
									],
									[
										99171,
										99176
									],
									[
										99271,
										99276
									],
									[
										99373,
										99378
									],
									[
										99471,
										99476
									],
									[
										99567,
										99572
									],
									[
										99671,
										99676
									],
									[
										99768,
										99773
									],
									[
										99866,
										99871
									],
									[
										100123,
										100128
									],
									[
										100343,
										100348
									],
									[
										100577,
										100582
									],
									[
										100832,
										100837
									],
									[
										101050,
										101055
									],
									[
										101218,
										101223
									],
									[
										101336,
										101341
									],
									[
										101448,
										101453
									],
									[
										101590,
										101595
									],
									[
										101735,
										101740
									],
									[
										101872,
										101877
									],
									[
										102011,
										102016
									],
									[
										102207,
										102212
									],
									[
										102244,
										102249
									],
									[
										102397,
										102402
									],
									[
										102498,
										102503
									],
									[
										102587,
										102592
									],
									[
										102696,
										102701
									],
									[
										102785,
										102790
									],
									[
										102900,
										102905
									],
									[
										102985,
										102990
									],
									[
										103069,
										103074
									],
									[
										103172,
										103177
									],
									[
										103277,
										103282
									],
									[
										103384,
										103389
									],
									[
										103485,
										103490
									],
									[
										103588,
										103593
									],
									[
										103722,
										103727
									],
									[
										103831,
										103836
									],
									[
										103944,
										103949
									],
									[
										104049,
										104054
									],
									[
										104159,
										104164
									],
									[
										104334,
										104339
									],
									[
										104589,
										104594
									],
									[
										104793,
										104798
									],
									[
										105044,
										105049
									],
									[
										105237,
										105242
									],
									[
										105563,
										105568
									],
									[
										105683,
										105688
									],
									[
										105720,
										105725
									],
									[
										105906,
										105911
									],
									[
										106071,
										106076
									],
									[
										106181,
										106186
									],
									[
										106273,
										106278
									],
									[
										106386,
										106391
									],
									[
										106478,
										106483
									],
									[
										106569,
										106574
									],
									[
										106658,
										106663
									],
									[
										106777,
										106782
									],
									[
										106865,
										106870
									],
									[
										106974,
										106979
									],
									[
										107085,
										107090
									],
									[
										107198,
										107203
									],
									[
										107311,
										107316
									],
									[
										107426,
										107431
									],
									[
										107539,
										107544
									],
									[
										107652,
										107657
									],
									[
										107767,
										107772
									],
									[
										107882,
										107887
									],
									[
										107970,
										107975
									],
									[
										108083,
										108088
									],
									[
										108194,
										108199
									],
									[
										108315,
										108320
									],
									[
										108430,
										108435
									],
									[
										108545,
										108550
									],
									[
										108638,
										108643
									],
									[
										108753,
										108758
									],
									[
										108875,
										108880
									],
									[
										109012,
										109017
									],
									[
										109130,
										109135
									],
									[
										109254,
										109259
									],
									[
										109372,
										109377
									],
									[
										109493,
										109498
									],
									[
										109617,
										109622
									],
									[
										109753,
										109758
									],
									[
										109885,
										109890
									],
									[
										109986,
										109991
									],
									[
										110093,
										110098
									],
									[
										110229,
										110234
									],
									[
										110365,
										110370
									],
									[
										110483,
										110488
									],
									[
										110596,
										110601
									],
									[
										110894,
										110899
									],
									[
										111164,
										111169
									],
									[
										111353,
										111358
									],
									[
										111604,
										111609
									],
									[
										111791,
										111796
									],
									[
										111981,
										111986
									],
									[
										112119,
										112124
									],
									[
										112225,
										112230
									],
									[
										112337,
										112342
									],
									[
										112460,
										112465
									],
									[
										112711,
										112716
									],
									[
										112887,
										112892
									],
									[
										113039,
										113044
									],
									[
										113139,
										113144
									],
									[
										113237,
										113242
									],
									[
										113337,
										113342
									],
									[
										113439,
										113444
									],
									[
										113539,
										113544
									],
									[
										113646,
										113651
									],
									[
										113712,
										113717
									],
									[
										113767,
										113772
									],
									[
										113927,
										113932
									],
									[
										114048,
										114053
									],
									[
										114163,
										114168
									],
									[
										114287,
										114292
									],
									[
										114411,
										114416
									],
									[
										114535,
										114540
									],
									[
										114662,
										114667
									],
									[
										114791,
										114796
									],
									[
										114912,
										114917
									],
									[
										115021,
										115026
									],
									[
										115157,
										115162
									],
									[
										115290,
										115295
									],
									[
										115423,
										115428
									],
									[
										115553,
										115558
									],
									[
										115791,
										115796
									],
									[
										115959,
										115964
									],
									[
										116060,
										116065
									],
									[
										116159,
										116164
									],
									[
										116260,
										116265
									],
									[
										116358,
										116363
									],
									[
										116460,
										116465
									],
									[
										116565,
										116570
									],
									[
										116671,
										116676
									],
									[
										116780,
										116785
									],
									[
										116860,
										116865
									],
									[
										116963,
										116968
									],
									[
										117095,
										117100
									],
									[
										117202,
										117207
									],
									[
										117307,
										117312
									],
									[
										117557,
										117562
									],
									[
										117759,
										117764
									],
									[
										117812,
										117817
									],
									[
										117942,
										117947
									],
									[
										118051,
										118056
									],
									[
										118065,
										118070
									],
									[
										118091,
										118096
									],
									[
										118344,
										118349
									],
									[
										118456,
										118461
									],
									[
										118639,
										118644
									],
									[
										118779,
										118784
									],
									[
										118840,
										118845
									],
									[
										118952,
										118957
									],
									[
										119010,
										119015
									],
									[
										119188,
										119193
									],
									[
										119249,
										119254
									],
									[
										119308,
										119313
									],
									[
										119389,
										119394
									],
									[
										119546,
										119551
									],
									[
										119684,
										119689
									],
									[
										119851,
										119856
									],
									[
										120085,
										120090
									],
									[
										120169,
										120174
									],
									[
										120304,
										120309
									],
									[
										120487,
										120492
									],
									[
										120735,
										120740
									],
									[
										120866,
										120871
									],
									[
										121011,
										121016
									],
									[
										121143,
										121148
									],
									[
										121280,
										121285
									],
									[
										121429,
										121434
									],
									[
										121493,
										121498
									],
									[
										121607,
										121612
									],
									[
										121843,
										121848
									],
									[
										121966,
										121971
									],
									[
										122244,
										122249
									],
									[
										122490,
										122495
									],
									[
										122685,
										122690
									],
									[
										122803,
										122808
									],
									[
										122949,
										122954
									],
									[
										123010,
										123015
									],
									[
										123157,
										123162
									],
									[
										123243,
										123248
									],
									[
										123294,
										123299
									],
									[
										123443,
										123448
									],
									[
										123619,
										123624
									],
									[
										123763,
										123768
									],
									[
										124214,
										124219
									],
									[
										124341,
										124346
									],
									[
										124551,
										124556
									],
									[
										124651,
										124656
									],
									[
										124797,
										124802
									],
									[
										124914,
										124919
									],
									[
										125038,
										125043
									],
									[
										125162,
										125167
									],
									[
										125282,
										125287
									],
									[
										125395,
										125400
									],
									[
										125519,
										125524
									],
									[
										125767,
										125772
									],
									[
										125917,
										125922
									],
									[
										126076,
										126081
									],
									[
										126349,
										126354
									],
									[
										126619,
										126624
									],
									[
										126647,
										126652
									],
									[
										126892,
										126897
									],
									[
										126971,
										126976
									],
									[
										127046,
										127051
									],
									[
										127244,
										127249
									],
									[
										127366,
										127371
									],
									[
										127487,
										127492
									],
									[
										127662,
										127667
									],
									[
										127700,
										127705
									],
									[
										127854,
										127859
									],
									[
										127977,
										127982
									],
									[
										128142,
										128147
									],
									[
										128275,
										128280
									],
									[
										128405,
										128410
									],
									[
										128483,
										128488
									],
									[
										128559,
										128564
									],
									[
										128765,
										128770
									],
									[
										128826,
										128831
									],
									[
										128882,
										128887
									],
									[
										128939,
										128944
									],
									[
										128996,
										129001
									],
									[
										129053,
										129058
									],
									[
										129245,
										129250
									],
									[
										129298,
										129303
									],
									[
										129352,
										129357
									],
									[
										129406,
										129411
									],
									[
										129465,
										129470
									],
									[
										129526,
										129531
									],
									[
										129590,
										129595
									],
									[
										129721,
										129726
									],
									[
										129781,
										129786
									],
									[
										129897,
										129902
									],
									[
										130050,
										130055
									],
									[
										130195,
										130200
									],
									[
										130386,
										130391
									],
									[
										130558,
										130563
									],
									[
										130672,
										130677
									],
									[
										130830,
										130835
									],
									[
										130992,
										130997
									],
									[
										131174,
										131179
									],
									[
										131215,
										131220
									],
									[
										131320,
										131325
									],
									[
										131468,
										131473
									],
									[
										131642,
										131647
									],
									[
										131671,
										131676
									],
									[
										131859,
										131864
									],
									[
										132072,
										132077
									],
									[
										132142,
										132147
									],
									[
										132253,
										132258
									],
									[
										132348,
										132353
									],
									[
										132438,
										132443
									],
									[
										132570,
										132575
									],
									[
										132747,
										132752
									],
									[
										132958,
										132963
									],
									[
										133060,
										133065
									],
									[
										133177,
										133182
									],
									[
										133289,
										133294
									],
									[
										133392,
										133397
									],
									[
										133486,
										133491
									],
									[
										133650,
										133655
									],
									[
										133702,
										133707
									],
									[
										133877,
										133882
									],
									[
										134044,
										134049
									],
									[
										134089,
										134094
									],
									[
										134148,
										134153
									],
									[
										134193,
										134198
									],
									[
										134252,
										134257
									],
									[
										134297,
										134302
									],
									[
										134358,
										134363
									],
									[
										134403,
										134408
									],
									[
										134629,
										134634
									],
									[
										134693,
										134698
									],
									[
										134757,
										134762
									],
									[
										134830,
										134835
									],
									[
										134895,
										134900
									],
									[
										134941,
										134946
									],
									[
										135000,
										135005
									],
									[
										135046,
										135051
									],
									[
										135106,
										135111
									],
									[
										135152,
										135157
									],
									[
										135224,
										135229
									],
									[
										135269,
										135274
									],
									[
										135351,
										135356
									],
									[
										135397,
										135402
									],
									[
										135462,
										135467
									],
									[
										135505,
										135510
									],
									[
										135570,
										135575
									],
									[
										135613,
										135618
									],
									[
										135687,
										135692
									],
									[
										135733,
										135738
									],
									[
										135800,
										135805
									],
									[
										135846,
										135851
									],
									[
										135920,
										135925
									],
									[
										135992,
										135997
									],
									[
										136039,
										136044
									],
									[
										136104,
										136109
									],
									[
										136175,
										136180
									],
									[
										136250,
										136255
									],
									[
										136296,
										136301
									],
									[
										136368,
										136373
									],
									[
										136414,
										136419
									],
									[
										136485,
										136490
									],
									[
										136561,
										136566
									],
									[
										136628,
										136633
									],
									[
										136676,
										136681
									],
									[
										136742,
										136747
									],
									[
										136811,
										136816
									],
									[
										136861,
										136866
									],
									[
										136925,
										136930
									],
									[
										136969,
										136974
									],
									[
										137034,
										137039
									],
									[
										137083,
										137088
									],
									[
										137151,
										137156
									],
									[
										137197,
										137202
									],
									[
										137265,
										137270
									],
									[
										137340,
										137345
									],
									[
										137384,
										137389
									],
									[
										137451,
										137456
									],
									[
										137495,
										137500
									],
									[
										137565,
										137570
									],
									[
										137609,
										137614
									],
									[
										137687,
										137692
									],
									[
										137730,
										137735
									],
									[
										137799,
										137804
									],
									[
										137829,
										137834
									],
									[
										137896,
										137901
									],
									[
										137944,
										137949
									],
									[
										138007,
										138012
									],
									[
										138056,
										138061
									],
									[
										138128,
										138133
									],
									[
										138177,
										138182
									],
									[
										138253,
										138258
									],
									[
										138302,
										138307
									],
									[
										138377,
										138382
									],
									[
										138426,
										138431
									],
									[
										138500,
										138505
									],
									[
										138549,
										138554
									],
									[
										138630,
										138635
									],
									[
										138679,
										138684
									],
									[
										138757,
										138762
									],
									[
										138822,
										138827
									],
									[
										138927,
										138932
									],
									[
										139035,
										139040
									],
									[
										139084,
										139089
									],
									[
										139154,
										139159
									],
									[
										139201,
										139206
									],
									[
										139279,
										139284
									],
									[
										139324,
										139329
									],
									[
										139559,
										139564
									],
									[
										139781,
										139786
									],
									[
										140060,
										140065
									],
									[
										140267,
										140272
									],
									[
										140416,
										140421
									],
									[
										140445,
										140450
									],
									[
										140590,
										140595
									],
									[
										140742,
										140747
									],
									[
										140830,
										140835
									],
									[
										140858,
										140863
									],
									[
										140928,
										140933
									],
									[
										141058,
										141063
									],
									[
										141262,
										141267
									],
									[
										141319,
										141324
									],
									[
										141522,
										141527
									],
									[
										141794,
										141799
									],
									[
										142092,
										142097
									],
									[
										142145,
										142150
									],
									[
										142365,
										142370
									],
									[
										142674,
										142679
									],
									[
										142780,
										142785
									],
									[
										143008,
										143013
									],
									[
										143179,
										143184
									],
									[
										143343,
										143348
									],
									[
										143483,
										143488
									],
									[
										143718,
										143723
									],
									[
										144041,
										144046
									],
									[
										144099,
										144104
									],
									[
										144168,
										144173
									],
									[
										144325,
										144330
									],
									[
										144379,
										144384
									],
									[
										144606,
										144611
									],
									[
										144770,
										144775
									],
									[
										144891,
										144896
									],
									[
										145010,
										145015
									],
									[
										145148,
										145153
									],
									[
										145269,
										145274
									],
									[
										145393,
										145398
									],
									[
										145537,
										145542
									],
									[
										145663,
										145668
									],
									[
										145793,
										145798
									],
									[
										145921,
										145926
									],
									[
										146160,
										146165
									],
									[
										146284,
										146289
									],
									[
										146481,
										146486
									],
									[
										146669,
										146674
									],
									[
										146821,
										146826
									],
									[
										146894,
										146899
									],
									[
										147050,
										147055
									],
									[
										147286,
										147291
									],
									[
										147424,
										147429
									],
									[
										147710,
										147715
									],
									[
										147817,
										147822
									],
									[
										147846,
										147851
									],
									[
										147966,
										147971
									],
									[
										148154,
										148159
									],
									[
										148168,
										148173
									],
									[
										148386,
										148391
									],
									[
										148401,
										148406
									],
									[
										148583,
										148588
									],
									[
										148667,
										148672
									],
									[
										148843,
										148848
									],
									[
										148941,
										148946
									],
									[
										149148,
										149153
									],
									[
										149358,
										149363
									],
									[
										149579,
										149584
									],
									[
										149790,
										149795
									],
									[
										150038,
										150043
									],
									[
										150238,
										150243
									],
									[
										150292,
										150297
									],
									[
										150363,
										150368
									],
									[
										150580,
										150585
									],
									[
										150616,
										150621
									],
									[
										150715,
										150720
									],
									[
										150918,
										150923
									],
									[
										151008,
										151013
									],
									[
										151246,
										151251
									],
									[
										151428,
										151433
									],
									[
										151584,
										151589
									],
									[
										151860,
										151865
									],
									[
										151957,
										151962
									],
									[
										152104,
										152109
									],
									[
										152305,
										152310
									],
									[
										152551,
										152556
									],
									[
										152738,
										152743
									],
									[
										152753,
										152758
									],
									[
										152828,
										152833
									],
									[
										152888,
										152893
									],
									[
										152921,
										152926
									],
									[
										152969,
										152974
									],
									[
										153005,
										153010
									],
									[
										153053,
										153058
									],
									[
										153091,
										153096
									],
									[
										153147,
										153152
									],
									[
										153183,
										153188
									],
									[
										153231,
										153236
									],
									[
										153267,
										153272
									],
									[
										153315,
										153320
									],
									[
										153351,
										153356
									],
									[
										153399,
										153404
									],
									[
										153436,
										153441
									],
									[
										153484,
										153489
									],
									[
										153520,
										153525
									],
									[
										153568,
										153573
									],
									[
										153602,
										153607
									],
									[
										153658,
										153663
									],
									[
										153694,
										153699
									],
									[
										153742,
										153747
									],
									[
										153779,
										153784
									],
									[
										153827,
										153832
									],
									[
										153863,
										153868
									],
									[
										153911,
										153916
									],
									[
										153949,
										153954
									],
									[
										154005,
										154010
									],
									[
										154044,
										154049
									],
									[
										154098,
										154103
									],
									[
										154134,
										154139
									],
									[
										154185,
										154190
									],
									[
										154227,
										154232
									],
									[
										154384,
										154389
									],
									[
										154488,
										154493
									],
									[
										154736,
										154741
									],
									[
										154950,
										154955
									],
									[
										155081,
										155086
									],
									[
										155196,
										155201
									],
									[
										155286,
										155291
									],
									[
										155362,
										155367
									],
									[
										155438,
										155443
									],
									[
										155502,
										155507
									],
									[
										155661,
										155666
									],
									[
										155826,
										155831
									],
									[
										155886,
										155891
									],
									[
										156101,
										156106
									],
									[
										156330,
										156335
									],
									[
										156537,
										156542
									],
									[
										156810,
										156815
									],
									[
										157083,
										157088
									],
									[
										157344,
										157349
									],
									[
										157648,
										157653
									],
									[
										157936,
										157941
									],
									[
										158281,
										158286
									],
									[
										158584,
										158589
									],
									[
										158771,
										158776
									],
									[
										159052,
										159057
									],
									[
										159478,
										159483
									],
									[
										159771,
										159776
									],
									[
										160101,
										160106
									],
									[
										160454,
										160459
									],
									[
										160790,
										160795
									],
									[
										161025,
										161030
									],
									[
										161296,
										161301
									],
									[
										161531,
										161536
									],
									[
										161708,
										161713
									],
									[
										162058,
										162063
									],
									[
										162234,
										162239
									],
									[
										162346,
										162351
									],
									[
										162632,
										162637
									],
									[
										162756,
										162761
									],
									[
										162941,
										162946
									],
									[
										163176,
										163181
									],
									[
										163247,
										163252
									],
									[
										163477,
										163482
									],
									[
										163931,
										163936
									],
									[
										164081,
										164086
									],
									[
										164475,
										164480
									],
									[
										164667,
										164672
									],
									[
										164774,
										164779
									],
									[
										164945,
										164950
									],
									[
										165167,
										165172
									],
									[
										165548,
										165553
									],
									[
										165615,
										165620
									],
									[
										165928,
										165933
									],
									[
										166184,
										166189
									],
									[
										166468,
										166473
									],
									[
										166700,
										166705
									],
									[
										167036,
										167041
									],
									[
										167273,
										167278
									],
									[
										167491,
										167496
									],
									[
										167660,
										167665
									],
									[
										167875,
										167880
									],
									[
										168101,
										168106
									],
									[
										168306,
										168311
									],
									[
										168566,
										168571
									],
									[
										168858,
										168863
									],
									[
										168943,
										168948
									],
									[
										169180,
										169185
									],
									[
										169236,
										169241
									],
									[
										169345,
										169350
									],
									[
										169606,
										169611
									],
									[
										169737,
										169742
									],
									[
										169845,
										169850
									],
									[
										170105,
										170110
									],
									[
										170159,
										170164
									],
									[
										170266,
										170271
									],
									[
										170494,
										170499
									],
									[
										170547,
										170552
									],
									[
										170653,
										170658
									],
									[
										170932,
										170937
									],
									[
										171020,
										171025
									],
									[
										171227,
										171232
									],
									[
										171517,
										171522
									],
									[
										171622,
										171627
									],
									[
										171809,
										171814
									],
									[
										171856,
										171861
									],
									[
										171965,
										171970
									],
									[
										172212,
										172217
									],
									[
										172259,
										172264
									],
									[
										172351,
										172356
									],
									[
										172377,
										172382
									],
									[
										172419,
										172424
									],
									[
										172504,
										172509
									],
									[
										172551,
										172556
									],
									[
										172580,
										172585
									],
									[
										172663,
										172668
									],
									[
										172713,
										172718
									],
									[
										172742,
										172747
									],
									[
										172822,
										172827
									],
									[
										172867,
										172872
									],
									[
										172896,
										172901
									],
									[
										172983,
										172988
									],
									[
										173027,
										173032
									],
									[
										173056,
										173061
									],
									[
										173151,
										173156
									],
									[
										173187,
										173192
									],
									[
										173216,
										173221
									],
									[
										173289,
										173294
									],
									[
										173327,
										173332
									],
									[
										173356,
										173361
									],
									[
										173463,
										173468
									],
									[
										173500,
										173505
									],
									[
										173529,
										173534
									],
									[
										173630,
										173635
									],
									[
										173667,
										173672
									],
									[
										173696,
										173701
									],
									[
										173794,
										173799
									],
									[
										173994,
										173999
									],
									[
										174070,
										174075
									],
									[
										174141,
										174146
									],
									[
										174236,
										174241
									],
									[
										174460,
										174465
									],
									[
										174487,
										174492
									],
									[
										174761,
										174766
									],
									[
										174956,
										174961
									],
									[
										174981,
										174986
									],
									[
										175031,
										175036
									],
									[
										175100,
										175105
									],
									[
										175137,
										175142
									],
									[
										175164,
										175169
									],
									[
										175202,
										175207
									],
									[
										175252,
										175257
									],
									[
										175289,
										175294
									],
									[
										175339,
										175344
									],
									[
										175358,
										175363
									],
									[
										175379,
										175384
									],
									[
										175430,
										175435
									],
									[
										175510,
										175515
									],
									[
										175552,
										175557
									],
									[
										175600,
										175605
									],
									[
										175641,
										175646
									],
									[
										175682,
										175687
									],
									[
										175730,
										175735
									],
									[
										175852,
										175857
									],
									[
										175981,
										175986
									],
									[
										176080,
										176085
									],
									[
										176176,
										176181
									],
									[
										176338,
										176343
									],
									[
										176375,
										176380
									],
									[
										176433,
										176438
									],
									[
										176585,
										176590
									],
									[
										176713,
										176718
									],
									[
										176827,
										176832
									],
									[
										176965,
										176970
									],
									[
										177241,
										177246
									],
									[
										177321,
										177326
									],
									[
										177396,
										177401
									],
									[
										177548,
										177553
									],
									[
										177651,
										177656
									],
									[
										177795,
										177800
									],
									[
										178056,
										178061
									],
									[
										178283,
										178288
									],
									[
										178447,
										178452
									],
									[
										178624,
										178629
									],
									[
										178852,
										178857
									],
									[
										178897,
										178902
									],
									[
										179023,
										179028
									],
									[
										179142,
										179147
									],
									[
										179383,
										179388
									],
									[
										179584,
										179589
									],
									[
										179605,
										179610
									],
									[
										179785,
										179790
									],
									[
										179853,
										179858
									],
									[
										180031,
										180036
									],
									[
										180069,
										180074
									],
									[
										180209,
										180214
									],
									[
										180246,
										180251
									],
									[
										180407,
										180412
									],
									[
										180541,
										180546
									],
									[
										180622,
										180627
									],
									[
										180800,
										180805
									],
									[
										180955,
										180960
									],
									[
										180979,
										180984
									],
									[
										181168,
										181173
									],
									[
										181349,
										181354
									],
									[
										181574,
										181579
									],
									[
										181751,
										181756
									],
									[
										181846,
										181851
									],
									[
										181993,
										181998
									],
									[
										182201,
										182206
									],
									[
										182353,
										182358
									],
									[
										182538,
										182543
									],
									[
										182756,
										182761
									],
									[
										182822,
										182827
									],
									[
										182887,
										182892
									],
									[
										182987,
										182992
									],
									[
										183046,
										183051
									],
									[
										183193,
										183198
									],
									[
										183298,
										183303
									],
									[
										183424,
										183429
									],
									[
										183642,
										183647
									],
									[
										183867,
										183872
									],
									[
										184079,
										184084
									],
									[
										184338,
										184343
									],
									[
										184547,
										184552
									],
									[
										184801,
										184806
									],
									[
										184831,
										184836
									],
									[
										184868,
										184873
									],
									[
										184909,
										184914
									],
									[
										185125,
										185130
									],
									[
										185303,
										185308
									],
									[
										185571,
										185576
									],
									[
										185796,
										185801
									],
									[
										185942,
										185947
									],
									[
										186149,
										186154
									],
									[
										186262,
										186267
									],
									[
										186485,
										186490
									],
									[
										186566,
										186571
									],
									[
										186763,
										186768
									],
									[
										186987,
										186992
									],
									[
										187155,
										187160
									],
									[
										187283,
										187288
									],
									[
										187496,
										187501
									],
									[
										187735,
										187740
									],
									[
										187996,
										188001
									],
									[
										188250,
										188255
									],
									[
										188611,
										188616
									],
									[
										188945,
										188950
									],
									[
										189216,
										189221
									],
									[
										189459,
										189464
									],
									[
										189770,
										189775
									],
									[
										190025,
										190030
									],
									[
										190281,
										190286
									],
									[
										190365,
										190370
									],
									[
										190556,
										190561
									],
									[
										190764,
										190769
									],
									[
										190886,
										190891
									],
									[
										191094,
										191099
									],
									[
										191431,
										191436
									],
									[
										191610,
										191615
									],
									[
										191952,
										191957
									],
									[
										192306,
										192311
									],
									[
										192483,
										192488
									],
									[
										192750,
										192755
									],
									[
										192884,
										192889
									],
									[
										193076,
										193081
									],
									[
										193155,
										193160
									],
									[
										193285,
										193290
									],
									[
										193512,
										193517
									],
									[
										193630,
										193635
									],
									[
										193872,
										193877
									],
									[
										194093,
										194098
									],
									[
										194149,
										194154
									],
									[
										194202,
										194207
									],
									[
										194259,
										194264
									],
									[
										194373,
										194378
									],
									[
										194417,
										194422
									],
									[
										194527,
										194532
									],
									[
										194683,
										194688
									],
									[
										194729,
										194734
									],
									[
										194777,
										194782
									],
									[
										194916,
										194921
									],
									[
										195007,
										195012
									],
									[
										195053,
										195058
									],
									[
										195206,
										195211
									],
									[
										195293,
										195298
									],
									[
										195435,
										195440
									],
									[
										195681,
										195686
									],
									[
										195919,
										195924
									],
									[
										196080,
										196085
									],
									[
										196215,
										196220
									],
									[
										196503,
										196508
									],
									[
										196621,
										196626
									],
									[
										196736,
										196741
									],
									[
										196863,
										196868
									],
									[
										197024,
										197029
									],
									[
										197053,
										197058
									],
									[
										197271,
										197276
									],
									[
										197304,
										197309
									],
									[
										197569,
										197574
									],
									[
										197738,
										197743
									],
									[
										198027,
										198032
									],
									[
										198095,
										198100
									],
									[
										198153,
										198158
									],
									[
										198227,
										198232
									],
									[
										198300,
										198305
									],
									[
										198360,
										198365
									],
									[
										198422,
										198427
									],
									[
										198557,
										198562
									],
									[
										198603,
										198608
									],
									[
										198680,
										198685
									],
									[
										198837,
										198842
									],
									[
										198900,
										198905
									],
									[
										199019,
										199024
									],
									[
										199240,
										199245
									],
									[
										199390,
										199395
									],
									[
										199515,
										199520
									],
									[
										199708,
										199713
									],
									[
										199822,
										199827
									],
									[
										199914,
										199919
									],
									[
										199966,
										199971
									],
									[
										200087,
										200092
									],
									[
										200182,
										200187
									],
									[
										200274,
										200279
									],
									[
										200377,
										200382
									],
									[
										200463,
										200468
									],
									[
										200529,
										200534
									],
									[
										200679,
										200684
									],
									[
										200964,
										200969
									],
									[
										201044,
										201049
									],
									[
										201116,
										201121
									],
									[
										201205,
										201210
									],
									[
										201285,
										201290
									],
									[
										201369,
										201374
									],
									[
										201452,
										201457
									],
									[
										201533,
										201538
									],
									[
										201605,
										201610
									],
									[
										201744,
										201749
									],
									[
										201789,
										201794
									],
									[
										201865,
										201870
									],
									[
										202050,
										202055
									],
									[
										202088,
										202093
									],
									[
										202317,
										202322
									],
									[
										202483,
										202488
									],
									[
										202542,
										202547
									],
									[
										202721,
										202726
									],
									[
										203011,
										203016
									],
									[
										203096,
										203101
									],
									[
										203335,
										203340
									],
									[
										203717,
										203722
									],
									[
										203972,
										203977
									],
									[
										204140,
										204145
									],
									[
										204267,
										204272
									],
									[
										204307,
										204312
									],
									[
										204370,
										204375
									],
									[
										204483,
										204488
									],
									[
										204556,
										204561
									],
									[
										204661,
										204666
									],
									[
										204774,
										204779
									],
									[
										204858,
										204863
									],
									[
										204928,
										204933
									],
									[
										205030,
										205035
									],
									[
										205092,
										205097
									],
									[
										205244,
										205249
									],
									[
										205352,
										205357
									],
									[
										205412,
										205417
									],
									[
										205536,
										205541
									],
									[
										205608,
										205613
									],
									[
										205725,
										205730
									],
									[
										205794,
										205799
									],
									[
										205907,
										205912
									],
									[
										206015,
										206020
									],
									[
										206161,
										206166
									],
									[
										206279,
										206284
									],
									[
										206392,
										206397
									],
									[
										206502,
										206507
									],
									[
										206620,
										206625
									],
									[
										206737,
										206742
									],
									[
										206876,
										206881
									],
									[
										206992,
										206997
									],
									[
										207054,
										207059
									],
									[
										207185,
										207190
									],
									[
										207297,
										207302
									],
									[
										207349,
										207354
									],
									[
										207436,
										207441
									],
									[
										207488,
										207493
									],
									[
										207611,
										207616
									],
									[
										207625,
										207630
									],
									[
										207804,
										207809
									],
									[
										207832,
										207837
									],
									[
										207961,
										207966
									],
									[
										208084,
										208089
									],
									[
										208318,
										208323
									],
									[
										208395,
										208400
									],
									[
										208675,
										208680
									],
									[
										208762,
										208767
									],
									[
										208940,
										208945
									],
									[
										209086,
										209091
									],
									[
										209228,
										209233
									],
									[
										209287,
										209292
									],
									[
										209440,
										209445
									],
									[
										209678,
										209683
									],
									[
										209823,
										209828
									],
									[
										210156,
										210161
									],
									[
										210360,
										210365
									],
									[
										210563,
										210568
									],
									[
										210796,
										210801
									],
									[
										210840,
										210845
									],
									[
										211009,
										211014
									],
									[
										211061,
										211066
									],
									[
										211114,
										211119
									],
									[
										211167,
										211172
									],
									[
										211228,
										211233
									],
									[
										211281,
										211286
									],
									[
										211333,
										211338
									],
									[
										211440,
										211445
									],
									[
										211489,
										211494
									],
									[
										211628,
										211633
									],
									[
										211805,
										211810
									],
									[
										212030,
										212035
									],
									[
										212082,
										212087
									],
									[
										212125,
										212130
									],
									[
										212381,
										212386
									],
									[
										212503,
										212508
									],
									[
										212719,
										212724
									],
									[
										212932,
										212937
									],
									[
										213045,
										213050
									],
									[
										213241,
										213246
									],
									[
										213303,
										213308
									],
									[
										213474,
										213479
									],
									[
										213815,
										213820
									],
									[
										214052,
										214057
									],
									[
										214199,
										214204
									],
									[
										214295,
										214300
									],
									[
										214467,
										214472
									],
									[
										214555,
										214560
									],
									[
										214695,
										214700
									],
									[
										214970,
										214975
									],
									[
										215009,
										215014
									],
									[
										215253,
										215258
									],
									[
										215386,
										215391
									],
									[
										215509,
										215514
									],
									[
										215746,
										215751
									],
									[
										215871,
										215876
									],
									[
										216183,
										216188
									],
									[
										216267,
										216272
									],
									[
										216429,
										216434
									],
									[
										216628,
										216633
									],
									[
										216659,
										216664
									],
									[
										216715,
										216720
									],
									[
										216772,
										216777
									],
									[
										216836,
										216841
									],
									[
										216900,
										216905
									],
									[
										216964,
										216969
									],
									[
										217028,
										217033
									],
									[
										217092,
										217097
									],
									[
										217156,
										217161
									],
									[
										217220,
										217225
									],
									[
										217283,
										217288
									],
									[
										217345,
										217350
									],
									[
										217410,
										217415
									],
									[
										217475,
										217480
									],
									[
										217552,
										217557
									],
									[
										217638,
										217643
									],
									[
										217726,
										217731
									],
									[
										217811,
										217816
									],
									[
										218027,
										218032
									],
									[
										218342,
										218347
									],
									[
										218646,
										218651
									],
									[
										218969,
										218974
									],
									[
										219269,
										219274
									],
									[
										219562,
										219567
									],
									[
										219657,
										219662
									],
									[
										219722,
										219727
									],
									[
										219810,
										219815
									],
									[
										219898,
										219903
									],
									[
										220177,
										220182
									],
									[
										220226,
										220231
									],
									[
										220257,
										220262
									],
									[
										220306,
										220311
									],
									[
										220554,
										220559
									],
									[
										220706,
										220711
									],
									[
										220876,
										220881
									],
									[
										220990,
										220995
									],
									[
										221071,
										221076
									],
									[
										221350,
										221355
									],
									[
										221584,
										221589
									],
									[
										221830,
										221835
									],
									[
										222079,
										222084
									],
									[
										222273,
										222278
									],
									[
										222524,
										222529
									],
									[
										222656,
										222661
									],
									[
										222888,
										222893
									],
									[
										223116,
										223121
									],
									[
										223237,
										223242
									],
									[
										223414,
										223419
									],
									[
										223673,
										223678
									],
									[
										223951,
										223956
									],
									[
										224275,
										224280
									],
									[
										224453,
										224458
									],
									[
										224603,
										224608
									],
									[
										224868,
										224873
									],
									[
										225208,
										225213
									],
									[
										225476,
										225481
									],
									[
										225744,
										225749
									],
									[
										226025,
										226030
									],
									[
										226310,
										226315
									],
									[
										226390,
										226395
									],
									[
										226680,
										226685
									],
									[
										226885,
										226890
									],
									[
										226958,
										226963
									],
									[
										227081,
										227086
									],
									[
										227164,
										227169
									],
									[
										227233,
										227238
									],
									[
										227297,
										227302
									],
									[
										227363,
										227368
									],
									[
										227429,
										227434
									],
									[
										227503,
										227508
									],
									[
										227576,
										227581
									],
									[
										227646,
										227651
									],
									[
										227715,
										227720
									],
									[
										227782,
										227787
									],
									[
										228058,
										228063
									],
									[
										228206,
										228211
									],
									[
										228450,
										228455
									],
									[
										228500,
										228505
									],
									[
										228637,
										228642
									],
									[
										228858,
										228863
									],
									[
										229022,
										229027
									],
									[
										229196,
										229201
									],
									[
										229369,
										229374
									],
									[
										229694,
										229699
									],
									[
										229891,
										229896
									],
									[
										230147,
										230152
									],
									[
										230401,
										230406
									],
									[
										230765,
										230770
									],
									[
										230827,
										230832
									],
									[
										231022,
										231027
									],
									[
										231240,
										231245
									],
									[
										231440,
										231445
									],
									[
										231529,
										231534
									],
									[
										231740,
										231745
									],
									[
										231833,
										231838
									],
									[
										232088,
										232093
									],
									[
										232114,
										232119
									],
									[
										232236,
										232241
									],
									[
										232339,
										232344
									],
									[
										232455,
										232460
									],
									[
										232624,
										232629
									],
									[
										232695,
										232700
									],
									[
										232843,
										232848
									],
									[
										232965,
										232970
									],
									[
										233185,
										233190
									],
									[
										233325,
										233330
									],
									[
										233366,
										233371
									],
									[
										233601,
										233606
									],
									[
										233794,
										233799
									],
									[
										233813,
										233818
									],
									[
										233841,
										233846
									],
									[
										234050,
										234055
									],
									[
										234135,
										234140
									],
									[
										234254,
										234259
									],
									[
										234282,
										234287
									],
									[
										234322,
										234327
									],
									[
										234368,
										234373
									],
									[
										234508,
										234513
									],
									[
										234554,
										234559
									],
									[
										234739,
										234744
									],
									[
										234974,
										234979
									],
									[
										235196,
										235201
									],
									[
										235249,
										235254
									],
									[
										235431,
										235436
									],
									[
										235646,
										235651
									],
									[
										235676,
										235681
									],
									[
										235710,
										235715
									],
									[
										235781,
										235786
									],
									[
										235971,
										235976
									],
									[
										236026,
										236031
									],
									[
										236140,
										236145
									],
									[
										236169,
										236174
									],
									[
										236308,
										236313
									],
									[
										236341,
										236346
									],
									[
										236391,
										236396
									],
									[
										236566,
										236571
									],
									[
										236894,
										236899
									],
									[
										237121,
										237126
									],
									[
										237437,
										237442
									],
									[
										237506,
										237511
									],
									[
										237563,
										237568
									],
									[
										237617,
										237622
									],
									[
										237815,
										237820
									],
									[
										237977,
										237982
									],
									[
										238010,
										238015
									],
									[
										238048,
										238053
									],
									[
										238078,
										238083
									],
									[
										238218,
										238223
									],
									[
										238251,
										238256
									],
									[
										238301,
										238306
									],
									[
										238477,
										238482
									],
									[
										238704,
										238709
									],
									[
										238945,
										238950
									],
									[
										238988,
										238993
									],
									[
										239053,
										239058
									],
									[
										239110,
										239115
									],
									[
										239320,
										239325
									],
									[
										239489,
										239494
									],
									[
										239523,
										239528
									],
									[
										239561,
										239566
									],
									[
										239591,
										239596
									],
									[
										239625,
										239630
									],
									[
										239765,
										239770
									],
									[
										239798,
										239803
									],
									[
										239848,
										239853
									],
									[
										240024,
										240029
									],
									[
										240221,
										240226
									],
									[
										240510,
										240515
									],
									[
										240856,
										240861
									],
									[
										240934,
										240939
									],
									[
										241008,
										241013
									],
									[
										241066,
										241071
									],
									[
										241131,
										241136
									],
									[
										241331,
										241336
									],
									[
										241386,
										241391
									],
									[
										241505,
										241510
									],
									[
										241539,
										241544
									],
									[
										241573,
										241578
									],
									[
										241713,
										241718
									],
									[
										241752,
										241757
									],
									[
										241807,
										241812
									],
									[
										241983,
										241988
									],
									[
										242181,
										242186
									],
									[
										242408,
										242413
									],
									[
										242577,
										242582
									],
									[
										242797,
										242802
									],
									[
										242856,
										242861
									],
									[
										242914,
										242919
									],
									[
										242974,
										242979
									],
									[
										243183,
										243188
									],
									[
										243392,
										243397
									],
									[
										243423,
										243428
									],
									[
										243494,
										243499
									],
									[
										243570,
										243575
									],
									[
										243602,
										243607
									],
									[
										243727,
										243732
									],
									[
										243801,
										243806
									],
									[
										243880,
										243885
									],
									[
										243913,
										243918
									],
									[
										244006,
										244011
									],
									[
										244178,
										244183
									],
									[
										244353,
										244358
									],
									[
										244472,
										244477
									],
									[
										244649,
										244654
									],
									[
										244792,
										244797
									],
									[
										245038,
										245043
									],
									[
										245089,
										245094
									],
									[
										245304,
										245309
									],
									[
										245550,
										245555
									],
									[
										245642,
										245647
									],
									[
										245830,
										245835
									],
									[
										246175,
										246180
									],
									[
										246355,
										246360
									],
									[
										246482,
										246487
									],
									[
										246656,
										246661
									],
									[
										246892,
										246897
									],
									[
										247106,
										247111
									],
									[
										247183,
										247188
									],
									[
										247249,
										247254
									],
									[
										247306,
										247311
									],
									[
										247371,
										247376
									],
									[
										247435,
										247440
									],
									[
										247500,
										247505
									],
									[
										247691,
										247696
									],
									[
										247939,
										247944
									],
									[
										248218,
										248223
									],
									[
										248372,
										248377
									],
									[
										248392,
										248397
									],
									[
										248580,
										248585
									],
									[
										248800,
										248805
									],
									[
										248935,
										248940
									],
									[
										249067,
										249072
									],
									[
										249348,
										249353
									],
									[
										249668,
										249673
									],
									[
										249776,
										249781
									],
									[
										250002,
										250007
									],
									[
										250256,
										250261
									],
									[
										250434,
										250439
									],
									[
										250597,
										250602
									],
									[
										250757,
										250762
									],
									[
										250892,
										250897
									],
									[
										251029,
										251034
									],
									[
										251163,
										251168
									],
									[
										251342,
										251347
									],
									[
										251645,
										251650
									],
									[
										251789,
										251794
									],
									[
										251931,
										251936
									],
									[
										252212,
										252217
									],
									[
										252418,
										252423
									],
									[
										252712,
										252717
									],
									[
										252859,
										252864
									],
									[
										253016,
										253021
									],
									[
										253175,
										253180
									],
									[
										253287,
										253292
									],
									[
										253550,
										253555
									],
									[
										253738,
										253743
									],
									[
										253772,
										253777
									],
									[
										254094,
										254099
									],
									[
										254348,
										254353
									],
									[
										254574,
										254579
									],
									[
										254834,
										254839
									],
									[
										255015,
										255020
									],
									[
										255201,
										255206
									],
									[
										255354,
										255359
									],
									[
										255566,
										255571
									],
									[
										255600,
										255605
									],
									[
										255788,
										255793
									],
									[
										255923,
										255928
									],
									[
										256007,
										256012
									],
									[
										256061,
										256066
									],
									[
										256190,
										256195
									],
									[
										256424,
										256429
									],
									[
										256501,
										256506
									],
									[
										256775,
										256780
									],
									[
										256902,
										256907
									],
									[
										257061,
										257066
									],
									[
										257197,
										257202
									],
									[
										257409,
										257414
									],
									[
										257613,
										257618
									],
									[
										257941,
										257946
									],
									[
										258192,
										258197
									],
									[
										258269,
										258274
									],
									[
										258393,
										258398
									],
									[
										258471,
										258476
									],
									[
										258701,
										258706
									],
									[
										258860,
										258865
									],
									[
										258989,
										258994
									],
									[
										259144,
										259149
									],
									[
										259274,
										259279
									],
									[
										259321,
										259326
									],
									[
										259435,
										259440
									],
									[
										259542,
										259547
									],
									[
										259718,
										259723
									],
									[
										259747,
										259752
									],
									[
										259773,
										259778
									],
									[
										259814,
										259819
									],
									[
										259896,
										259901
									],
									[
										259970,
										259975
									],
									[
										260016,
										260021
									],
									[
										260090,
										260095
									],
									[
										260130,
										260135
									],
									[
										260169,
										260174
									],
									[
										260245,
										260250
									],
									[
										260445,
										260450
									],
									[
										260626,
										260631
									],
									[
										260792,
										260797
									],
									[
										260806,
										260811
									],
									[
										261147,
										261152
									],
									[
										261352,
										261357
									],
									[
										261548,
										261553
									],
									[
										261810,
										261815
									],
									[
										262002,
										262007
									],
									[
										262264,
										262269
									],
									[
										262323,
										262328
									],
									[
										262385,
										262390
									],
									[
										262448,
										262453
									],
									[
										262536,
										262541
									],
									[
										262634,
										262639
									],
									[
										262726,
										262731
									],
									[
										262826,
										262831
									],
									[
										262912,
										262917
									],
									[
										262998,
										263003
									],
									[
										263086,
										263091
									],
									[
										263182,
										263187
									],
									[
										263276,
										263281
									],
									[
										263380,
										263385
									],
									[
										263468,
										263473
									],
									[
										263556,
										263561
									],
									[
										263646,
										263651
									],
									[
										263736,
										263741
									],
									[
										263827,
										263832
									],
									[
										263921,
										263926
									],
									[
										264013,
										264018
									],
									[
										264105,
										264110
									],
									[
										264197,
										264202
									],
									[
										264289,
										264294
									],
									[
										264381,
										264386
									],
									[
										264487,
										264492
									],
									[
										264577,
										264582
									],
									[
										264677,
										264682
									],
									[
										264771,
										264776
									],
									[
										264865,
										264870
									],
									[
										264957,
										264962
									],
									[
										265049,
										265054
									],
									[
										265141,
										265146
									],
									[
										265227,
										265232
									],
									[
										265323,
										265328
									],
									[
										265417,
										265422
									],
									[
										265606,
										265611
									],
									[
										265670,
										265675
									],
									[
										265749,
										265754
									],
									[
										265838,
										265843
									],
									[
										266264,
										266269
									],
									[
										266566,
										266571
									],
									[
										266627,
										266632
									],
									[
										266701,
										266706
									],
									[
										266761,
										266766
									],
									[
										266822,
										266827
									],
									[
										266906,
										266911
									],
									[
										266990,
										266995
									],
									[
										267045,
										267050
									],
									[
										267129,
										267134
									],
									[
										267207,
										267212
									],
									[
										267280,
										267285
									],
									[
										267334,
										267339
									],
									[
										267416,
										267421
									],
									[
										267505,
										267510
									],
									[
										267560,
										267565
									],
									[
										267613,
										267618
									],
									[
										267666,
										267671
									],
									[
										267718,
										267723
									],
									[
										267771,
										267776
									],
									[
										267830,
										267835
									],
									[
										267904,
										267909
									],
									[
										267958,
										267963
									],
									[
										268010,
										268015
									],
									[
										268085,
										268090
									],
									[
										268164,
										268169
									],
									[
										268242,
										268247
									],
									[
										268321,
										268326
									],
									[
										268399,
										268404
									],
									[
										268457,
										268462
									],
									[
										268633,
										268638
									],
									[
										268698,
										268703
									],
									[
										268779,
										268784
									],
									[
										268865,
										268870
									],
									[
										268951,
										268956
									],
									[
										269012,
										269017
									],
									[
										269114,
										269119
									],
									[
										269177,
										269182
									],
									[
										269260,
										269265
									],
									[
										269321,
										269326
									],
									[
										269402,
										269407
									],
									[
										269485,
										269490
									],
									[
										269569,
										269574
									],
									[
										269650,
										269655
									],
									[
										269728,
										269733
									],
									[
										269809,
										269814
									],
									[
										269892,
										269897
									],
									[
										269972,
										269977
									],
									[
										270027,
										270032
									],
									[
										270081,
										270086
									],
									[
										270138,
										270143
									],
									[
										270254,
										270259
									],
									[
										270315,
										270320
									],
									[
										270398,
										270403
									],
									[
										270482,
										270487
									],
									[
										270566,
										270571
									],
									[
										270651,
										270656
									],
									[
										270737,
										270742
									],
									[
										270818,
										270823
									],
									[
										270901,
										270906
									],
									[
										270971,
										270976
									],
									[
										271054,
										271059
									],
									[
										271141,
										271146
									],
									[
										271225,
										271230
									],
									[
										271302,
										271307
									],
									[
										271380,
										271385
									],
									[
										271460,
										271465
									],
									[
										271531,
										271536
									],
									[
										271612,
										271617
									],
									[
										271680,
										271685
									],
									[
										271758,
										271763
									],
									[
										271831,
										271836
									],
									[
										271904,
										271909
									],
									[
										271990,
										271995
									],
									[
										272067,
										272072
									],
									[
										272127,
										272132
									],
									[
										272254,
										272259
									],
									[
										272315,
										272320
									],
									[
										272393,
										272398
									],
									[
										272449,
										272454
									],
									[
										272531,
										272536
									],
									[
										272614,
										272619
									],
									[
										272699,
										272704
									],
									[
										272789,
										272794
									],
									[
										272892,
										272897
									],
									[
										272967,
										272972
									],
									[
										273016,
										273021
									],
									[
										273069,
										273074
									],
									[
										273122,
										273127
									],
									[
										273175,
										273180
									],
									[
										273227,
										273232
									],
									[
										273348,
										273353
									],
									[
										273647,
										273652
									],
									[
										273725,
										273730
									],
									[
										274041,
										274046
									],
									[
										274130,
										274135
									],
									[
										274224,
										274229
									],
									[
										274318,
										274323
									],
									[
										274386,
										274391
									],
									[
										274480,
										274485
									],
									[
										274574,
										274579
									],
									[
										274670,
										274675
									],
									[
										274766,
										274771
									],
									[
										274832,
										274837
									],
									[
										274889,
										274894
									],
									[
										274950,
										274955
									],
									[
										275019,
										275024
									],
									[
										275088,
										275093
									],
									[
										275292,
										275297
									],
									[
										275417,
										275422
									],
									[
										275508,
										275513
									],
									[
										275569,
										275574
									],
									[
										275699,
										275704
									],
									[
										275890,
										275895
									],
									[
										276038,
										276043
									],
									[
										276189,
										276194
									],
									[
										276336,
										276341
									],
									[
										276476,
										276481
									],
									[
										276615,
										276620
									],
									[
										276812,
										276817
									],
									[
										276948,
										276953
									],
									[
										277060,
										277065
									],
									[
										277180,
										277185
									],
									[
										277412,
										277417
									],
									[
										277530,
										277535
									],
									[
										277648,
										277653
									],
									[
										277771,
										277776
									],
									[
										277876,
										277881
									],
									[
										278033,
										278038
									],
									[
										278144,
										278149
									],
									[
										278189,
										278194
									],
									[
										278240,
										278245
									],
									[
										278430,
										278435
									],
									[
										278706,
										278711
									],
									[
										278864,
										278869
									],
									[
										278948,
										278953
									],
									[
										279052,
										279057
									],
									[
										279147,
										279152
									],
									[
										279245,
										279250
									],
									[
										279351,
										279356
									],
									[
										279437,
										279442
									],
									[
										279507,
										279512
									],
									[
										279596,
										279601
									],
									[
										279657,
										279662
									],
									[
										279724,
										279729
									],
									[
										279787,
										279792
									],
									[
										279985,
										279990
									],
									[
										280196,
										280201
									],
									[
										280397,
										280402
									],
									[
										280503,
										280508
									],
									[
										280663,
										280668
									],
									[
										280937,
										280942
									],
									[
										281147,
										281152
									],
									[
										281344,
										281349
									],
									[
										281475,
										281480
									],
									[
										281612,
										281617
									],
									[
										281715,
										281720
									],
									[
										282000,
										282005
									],
									[
										282261,
										282266
									],
									[
										282575,
										282580
									],
									[
										282762,
										282767
									],
									[
										282853,
										282858
									],
									[
										282976,
										282981
									],
									[
										283123,
										283128
									],
									[
										283294,
										283299
									],
									[
										283468,
										283473
									],
									[
										283603,
										283608
									],
									[
										283672,
										283677
									],
									[
										283869,
										283874
									],
									[
										283930,
										283935
									],
									[
										284016,
										284021
									],
									[
										284102,
										284107
									],
									[
										284189,
										284194
									],
									[
										284274,
										284279
									],
									[
										284360,
										284365
									],
									[
										284446,
										284451
									],
									[
										284532,
										284537
									],
									[
										284619,
										284624
									],
									[
										284704,
										284709
									],
									[
										284917,
										284922
									],
									[
										285124,
										285129
									],
									[
										285383,
										285388
									],
									[
										285622,
										285627
									],
									[
										285841,
										285846
									],
									[
										285881,
										285886
									],
									[
										285919,
										285924
									],
									[
										286012,
										286017
									],
									[
										286045,
										286050
									],
									[
										286129,
										286134
									],
									[
										286354,
										286359
									],
									[
										286394,
										286399
									],
									[
										286427,
										286432
									],
									[
										286553,
										286558
									],
									[
										286706,
										286711
									],
									[
										286750,
										286755
									],
									[
										286793,
										286798
									],
									[
										287004,
										287009
									],
									[
										287190,
										287195
									],
									[
										287471,
										287476
									],
									[
										287686,
										287691
									],
									[
										287785,
										287790
									],
									[
										287977,
										287982
									],
									[
										287988,
										287993
									],
									[
										288177,
										288182
									],
									[
										288188,
										288193
									],
									[
										288377,
										288382
									],
									[
										288388,
										288393
									],
									[
										288565,
										288570
									],
									[
										288826,
										288831
									],
									[
										288884,
										288889
									],
									[
										289086,
										289091
									],
									[
										289114,
										289119
									],
									[
										289223,
										289228
									],
									[
										289288,
										289293
									],
									[
										289343,
										289348
									],
									[
										289386,
										289391
									],
									[
										289453,
										289458
									],
									[
										289612,
										289617
									],
									[
										289713,
										289718
									],
									[
										290009,
										290014
									],
									[
										290125,
										290130
									],
									[
										290246,
										290251
									],
									[
										290460,
										290465
									],
									[
										290587,
										290592
									],
									[
										290787,
										290792
									],
									[
										290974,
										290979
									],
									[
										291123,
										291128
									],
									[
										291336,
										291341
									],
									[
										291528,
										291533
									],
									[
										291648,
										291653
									],
									[
										291860,
										291865
									],
									[
										291934,
										291939
									],
									[
										291973,
										291978
									],
									[
										292100,
										292105
									],
									[
										292180,
										292185
									],
									[
										292226,
										292231
									],
									[
										292382,
										292387
									],
									[
										292463,
										292468
									],
									[
										292510,
										292515
									],
									[
										292666,
										292671
									],
									[
										292737,
										292742
									],
									[
										292773,
										292778
									],
									[
										292909,
										292914
									],
									[
										292980,
										292985
									],
									[
										293016,
										293021
									],
									[
										293175,
										293180
									],
									[
										293305,
										293310
									],
									[
										293468,
										293473
									],
									[
										293717,
										293722
									],
									[
										293828,
										293833
									],
									[
										293929,
										293934
									],
									[
										294040,
										294045
									],
									[
										294250,
										294255
									],
									[
										294449,
										294454
									],
									[
										294703,
										294708
									],
									[
										295040,
										295045
									],
									[
										295319,
										295324
									],
									[
										295455,
										295460
									],
									[
										295496,
										295501
									],
									[
										295537,
										295542
									],
									[
										295578,
										295583
									],
									[
										295678,
										295683
									],
									[
										295743,
										295748
									],
									[
										296119,
										296124
									],
									[
										296346,
										296351
									],
									[
										296574,
										296579
									],
									[
										296763,
										296768
									],
									[
										296896,
										296901
									],
									[
										297090,
										297095
									],
									[
										297260,
										297265
									],
									[
										297391,
										297396
									],
									[
										297516,
										297521
									],
									[
										297791,
										297796
									],
									[
										298023,
										298028
									],
									[
										298243,
										298248
									],
									[
										298482,
										298487
									],
									[
										298582,
										298587
									],
									[
										298750,
										298755
									],
									[
										298898,
										298903
									],
									[
										299022,
										299027
									],
									[
										299128,
										299133
									],
									[
										299294,
										299299
									],
									[
										299461,
										299466
									],
									[
										299653,
										299658
									],
									[
										299998,
										300003
									],
									[
										300051,
										300056
									],
									[
										300104,
										300109
									],
									[
										300148,
										300153
									],
									[
										300176,
										300181
									],
									[
										300228,
										300233
									],
									[
										300271,
										300276
									],
									[
										300324,
										300329
									],
									[
										300554,
										300559
									],
									[
										300613,
										300618
									],
									[
										300672,
										300677
									],
									[
										300722,
										300727
									],
									[
										300766,
										300771
									],
									[
										300824,
										300829
									],
									[
										300873,
										300878
									],
									[
										300932,
										300937
									],
									[
										301128,
										301133
									],
									[
										301358,
										301363
									],
									[
										301560,
										301565
									],
									[
										301727,
										301732
									],
									[
										301929,
										301934
									],
									[
										302234,
										302239
									],
									[
										302334,
										302339
									],
									[
										302598,
										302603
									],
									[
										302699,
										302704
									],
									[
										302867,
										302872
									],
									[
										303214,
										303219
									],
									[
										303267,
										303272
									],
									[
										303320,
										303325
									],
									[
										303364,
										303369
									],
									[
										303392,
										303397
									],
									[
										303444,
										303449
									],
									[
										303487,
										303492
									],
									[
										303540,
										303545
									],
									[
										303800,
										303805
									],
									[
										303859,
										303864
									],
									[
										303918,
										303923
									],
									[
										303968,
										303973
									],
									[
										304012,
										304017
									],
									[
										304070,
										304075
									],
									[
										304119,
										304124
									],
									[
										304178,
										304183
									],
									[
										304473,
										304478
									],
									[
										304526,
										304531
									],
									[
										304579,
										304584
									],
									[
										304623,
										304628
									],
									[
										304651,
										304656
									],
									[
										304703,
										304708
									],
									[
										304746,
										304751
									],
									[
										304799,
										304804
									],
									[
										305034,
										305039
									],
									[
										305093,
										305098
									],
									[
										305152,
										305157
									],
									[
										305202,
										305207
									],
									[
										305246,
										305251
									],
									[
										305304,
										305309
									],
									[
										305353,
										305358
									],
									[
										305412,
										305417
									],
									[
										305682,
										305687
									],
									[
										305807,
										305812
									],
									[
										305988,
										305993
									],
									[
										306194,
										306199
									],
									[
										306457,
										306462
									],
									[
										306593,
										306598
									],
									[
										306634,
										306639
									],
									[
										306675,
										306680
									],
									[
										306716,
										306721
									],
									[
										306816,
										306821
									],
									[
										306881,
										306886
									],
									[
										307269,
										307274
									],
									[
										307322,
										307327
									],
									[
										307375,
										307380
									],
									[
										307419,
										307424
									],
									[
										307447,
										307452
									],
									[
										307499,
										307504
									],
									[
										307542,
										307547
									],
									[
										307595,
										307600
									],
									[
										307827,
										307832
									],
									[
										307886,
										307891
									],
									[
										307945,
										307950
									],
									[
										307995,
										308000
									],
									[
										308039,
										308044
									],
									[
										308097,
										308102
									],
									[
										308146,
										308151
									],
									[
										308205,
										308210
									],
									[
										308488,
										308493
									],
									[
										308580,
										308585
									],
									[
										308709,
										308714
									],
									[
										308816,
										308821
									],
									[
										308997,
										309002
									],
									[
										309149,
										309154
									],
									[
										309349,
										309354
									],
									[
										309539,
										309544
									],
									[
										309734,
										309739
									],
									[
										309807,
										309812
									],
									[
										309969,
										309974
									],
									[
										310114,
										310119
									],
									[
										310211,
										310216
									],
									[
										310514,
										310519
									],
									[
										310567,
										310572
									],
									[
										310620,
										310625
									],
									[
										310664,
										310669
									],
									[
										310692,
										310697
									],
									[
										310744,
										310749
									],
									[
										310787,
										310792
									],
									[
										310840,
										310845
									],
									[
										311114,
										311119
									],
									[
										311173,
										311178
									],
									[
										311232,
										311237
									],
									[
										311282,
										311287
									],
									[
										311326,
										311331
									],
									[
										311384,
										311389
									],
									[
										311433,
										311438
									],
									[
										311492,
										311497
									],
									[
										311806,
										311811
									],
									[
										311859,
										311864
									],
									[
										311912,
										311917
									],
									[
										311956,
										311961
									],
									[
										311984,
										311989
									],
									[
										312036,
										312041
									],
									[
										312079,
										312084
									],
									[
										312132,
										312137
									],
									[
										312389,
										312394
									],
									[
										312448,
										312453
									],
									[
										312507,
										312512
									],
									[
										312557,
										312562
									],
									[
										312601,
										312606
									],
									[
										312659,
										312664
									],
									[
										312708,
										312713
									],
									[
										312767,
										312772
									],
									[
										312987,
										312992
									],
									[
										313140,
										313145
									],
									[
										313329,
										313334
									],
									[
										313515,
										313520
									],
									[
										313703,
										313708
									],
									[
										313889,
										313894
									],
									[
										314071,
										314076
									],
									[
										314415,
										314420
									],
									[
										314468,
										314473
									],
									[
										314521,
										314526
									],
									[
										314565,
										314570
									],
									[
										314593,
										314598
									],
									[
										314645,
										314650
									],
									[
										314688,
										314693
									],
									[
										314741,
										314746
									],
									[
										314964,
										314969
									],
									[
										315023,
										315028
									],
									[
										315082,
										315087
									],
									[
										315132,
										315137
									],
									[
										315176,
										315181
									],
									[
										315234,
										315239
									],
									[
										315283,
										315288
									],
									[
										315342,
										315347
									],
									[
										315550,
										315555
									],
									[
										315748,
										315753
									],
									[
										315979,
										315984
									],
									[
										316151,
										316156
									],
									[
										316258,
										316263
									],
									[
										316322,
										316327
									],
									[
										316379,
										316384
									],
									[
										316443,
										316448
									],
									[
										316507,
										316512
									],
									[
										316571,
										316576
									],
									[
										316635,
										316640
									],
									[
										316699,
										316704
									],
									[
										316763,
										316768
									],
									[
										316827,
										316832
									],
									[
										316890,
										316895
									],
									[
										316952,
										316957
									],
									[
										317017,
										317022
									],
									[
										317297,
										317302
									],
									[
										317350,
										317355
									],
									[
										317403,
										317408
									],
									[
										317447,
										317452
									],
									[
										317475,
										317480
									],
									[
										317527,
										317532
									],
									[
										317570,
										317575
									],
									[
										317623,
										317628
									],
									[
										317884,
										317889
									],
									[
										317943,
										317948
									],
									[
										318002,
										318007
									],
									[
										318052,
										318057
									],
									[
										318096,
										318101
									],
									[
										318154,
										318159
									],
									[
										318203,
										318208
									],
									[
										318262,
										318267
									],
									[
										318552,
										318557
									],
									[
										318605,
										318610
									],
									[
										318658,
										318663
									],
									[
										318702,
										318707
									],
									[
										318730,
										318735
									],
									[
										318782,
										318787
									],
									[
										318825,
										318830
									],
									[
										318878,
										318883
									],
									[
										319136,
										319141
									],
									[
										319195,
										319200
									],
									[
										319254,
										319259
									],
									[
										319304,
										319309
									],
									[
										319348,
										319353
									],
									[
										319406,
										319411
									],
									[
										319455,
										319460
									],
									[
										319514,
										319519
									],
									[
										319819,
										319824
									],
									[
										319872,
										319877
									],
									[
										319925,
										319930
									],
									[
										319969,
										319974
									],
									[
										319997,
										320002
									],
									[
										320049,
										320054
									],
									[
										320092,
										320097
									],
									[
										320145,
										320150
									],
									[
										320424,
										320429
									],
									[
										320483,
										320488
									],
									[
										320542,
										320547
									],
									[
										320592,
										320597
									],
									[
										320636,
										320641
									],
									[
										320694,
										320699
									],
									[
										320743,
										320748
									],
									[
										320802,
										320807
									],
									[
										321140,
										321145
									],
									[
										321193,
										321198
									],
									[
										321246,
										321251
									],
									[
										321290,
										321295
									],
									[
										321318,
										321323
									],
									[
										321370,
										321375
									],
									[
										321413,
										321418
									],
									[
										321466,
										321471
									],
									[
										321723,
										321728
									],
									[
										321782,
										321787
									],
									[
										321841,
										321846
									],
									[
										321891,
										321896
									],
									[
										321935,
										321940
									],
									[
										321993,
										321998
									],
									[
										322042,
										322047
									],
									[
										322101,
										322106
									],
									[
										322309,
										322314
									],
									[
										322411,
										322416
									],
									[
										322602,
										322607
									],
									[
										322776,
										322781
									],
									[
										322962,
										322967
									],
									[
										323166,
										323171
									],
									[
										323398,
										323403
									],
									[
										323531,
										323536
									],
									[
										323662,
										323667
									],
									[
										323703,
										323708
									],
									[
										323743,
										323748
									],
									[
										323936,
										323941
									],
									[
										324070,
										324075
									],
									[
										324259,
										324264
									],
									[
										324438,
										324443
									],
									[
										324620,
										324625
									],
									[
										324698,
										324703
									],
									[
										324849,
										324854
									],
									[
										325004,
										325009
									],
									[
										325141,
										325146
									],
									[
										325286,
										325291
									],
									[
										325514,
										325519
									],
									[
										325621,
										325626
									],
									[
										325822,
										325827
									],
									[
										326014,
										326019
									],
									[
										326305,
										326310
									],
									[
										326406,
										326411
									],
									[
										326554,
										326559
									],
									[
										326709,
										326714
									],
									[
										326880,
										326885
									],
									[
										327036,
										327041
									],
									[
										327212,
										327217
									],
									[
										327340,
										327345
									],
									[
										327526,
										327531
									],
									[
										327702,
										327707
									],
									[
										327888,
										327893
									],
									[
										328090,
										328095
									],
									[
										328176,
										328181
									],
									[
										328252,
										328257
									],
									[
										328325,
										328330
									],
									[
										328390,
										328395
									],
									[
										328565,
										328570
									],
									[
										328585,
										328590
									],
									[
										328776,
										328781
									],
									[
										328792,
										328797
									],
									[
										328985,
										328990
									],
									[
										329001,
										329006
									],
									[
										329091,
										329096
									],
									[
										329111,
										329116
									],
									[
										329370,
										329375
									],
									[
										329505,
										329510
									],
									[
										329641,
										329646
									],
									[
										329773,
										329778
									],
									[
										329954,
										329959
									],
									[
										330197,
										330202
									],
									[
										330297,
										330302
									],
									[
										330432,
										330437
									],
									[
										330711,
										330716
									],
									[
										330796,
										330801
									],
									[
										330948,
										330953
									],
									[
										331194,
										331199
									],
									[
										331380,
										331385
									],
									[
										331480,
										331485
									],
									[
										331615,
										331620
									],
									[
										331922,
										331927
									],
									[
										332161,
										332166
									],
									[
										332282,
										332287
									],
									[
										332487,
										332492
									],
									[
										332659,
										332664
									],
									[
										332887,
										332892
									],
									[
										333113,
										333118
									],
									[
										333337,
										333342
									],
									[
										333559,
										333564
									],
									[
										333700,
										333705
									],
									[
										333905,
										333910
									],
									[
										334130,
										334135
									],
									[
										334365,
										334370
									],
									[
										334606,
										334611
									],
									[
										334870,
										334875
									],
									[
										335120,
										335125
									],
									[
										335339,
										335344
									],
									[
										335396,
										335401
									],
									[
										335504,
										335509
									],
									[
										335563,
										335568
									],
									[
										335666,
										335671
									],
									[
										335961,
										335966
									],
									[
										336199,
										336204
									],
									[
										336315,
										336320
									],
									[
										336435,
										336440
									],
									[
										336594,
										336599
									],
									[
										336802,
										336807
									],
									[
										336983,
										336988
									],
									[
										337217,
										337222
									],
									[
										337419,
										337424
									],
									[
										337621,
										337626
									],
									[
										337823,
										337828
									],
									[
										338025,
										338030
									],
									[
										338227,
										338232
									],
									[
										338429,
										338434
									],
									[
										338631,
										338636
									],
									[
										338833,
										338838
									],
									[
										339035,
										339040
									],
									[
										339237,
										339242
									],
									[
										339439,
										339444
									],
									[
										339644,
										339649
									],
									[
										339952,
										339957
									],
									[
										340071,
										340076
									],
									[
										340147,
										340152
									],
									[
										340340,
										340345
									],
									[
										340356,
										340361
									],
									[
										340562,
										340567
									],
									[
										340578,
										340583
									],
									[
										340824,
										340829
									],
									[
										340985,
										340990
									],
									[
										341096,
										341101
									],
									[
										341238,
										341243
									],
									[
										341254,
										341259
									],
									[
										341521,
										341526
									],
									[
										341810,
										341815
									],
									[
										341917,
										341922
									],
									[
										342152,
										342157
									],
									[
										342245,
										342250
									],
									[
										342497,
										342502
									],
									[
										342625,
										342630
									],
									[
										342911,
										342916
									],
									[
										343033,
										343038
									],
									[
										343197,
										343202
									],
									[
										343334,
										343339
									],
									[
										343485,
										343490
									],
									[
										343663,
										343668
									],
									[
										343850,
										343855
									],
									[
										343981,
										343986
									],
									[
										344169,
										344174
									],
									[
										344328,
										344333
									],
									[
										344691,
										344696
									],
									[
										344744,
										344749
									],
									[
										344797,
										344802
									],
									[
										344841,
										344846
									],
									[
										344869,
										344874
									],
									[
										344921,
										344926
									],
									[
										344964,
										344969
									],
									[
										345017,
										345022
									],
									[
										345250,
										345255
									],
									[
										345309,
										345314
									],
									[
										345368,
										345373
									],
									[
										345418,
										345423
									],
									[
										345462,
										345467
									],
									[
										345520,
										345525
									],
									[
										345569,
										345574
									],
									[
										345628,
										345633
									],
									[
										345948,
										345953
									],
									[
										346001,
										346006
									],
									[
										346054,
										346059
									],
									[
										346098,
										346103
									],
									[
										346126,
										346131
									],
									[
										346178,
										346183
									],
									[
										346221,
										346226
									],
									[
										346274,
										346279
									],
									[
										346553,
										346558
									],
									[
										346612,
										346617
									],
									[
										346671,
										346676
									],
									[
										346721,
										346726
									],
									[
										346765,
										346770
									],
									[
										346823,
										346828
									],
									[
										346872,
										346877
									],
									[
										346931,
										346936
									],
									[
										347211,
										347216
									],
									[
										347264,
										347269
									],
									[
										347317,
										347322
									],
									[
										347361,
										347366
									],
									[
										347389,
										347394
									],
									[
										347441,
										347446
									],
									[
										347484,
										347489
									],
									[
										347537,
										347542
									],
									[
										347825,
										347830
									],
									[
										347884,
										347889
									],
									[
										347943,
										347948
									],
									[
										347993,
										347998
									],
									[
										348037,
										348042
									],
									[
										348095,
										348100
									],
									[
										348144,
										348149
									],
									[
										348203,
										348208
									],
									[
										348457,
										348462
									],
									[
										348510,
										348515
									],
									[
										348563,
										348568
									],
									[
										348607,
										348612
									],
									[
										348635,
										348640
									],
									[
										348687,
										348692
									],
									[
										348730,
										348735
									],
									[
										348783,
										348788
									],
									[
										349052,
										349057
									],
									[
										349111,
										349116
									],
									[
										349170,
										349175
									],
									[
										349220,
										349225
									],
									[
										349264,
										349269
									],
									[
										349322,
										349327
									],
									[
										349371,
										349376
									],
									[
										349430,
										349435
									],
									[
										349716,
										349721
									],
									[
										349769,
										349774
									],
									[
										349822,
										349827
									],
									[
										349866,
										349871
									],
									[
										349894,
										349899
									],
									[
										349946,
										349951
									],
									[
										349989,
										349994
									],
									[
										350042,
										350047
									],
									[
										350281,
										350286
									],
									[
										350340,
										350345
									],
									[
										350399,
										350404
									],
									[
										350449,
										350454
									],
									[
										350493,
										350498
									],
									[
										350551,
										350556
									],
									[
										350600,
										350605
									],
									[
										350659,
										350664
									],
									[
										350948,
										350953
									],
									[
										351001,
										351006
									],
									[
										351054,
										351059
									],
									[
										351098,
										351103
									],
									[
										351126,
										351131
									],
									[
										351178,
										351183
									],
									[
										351221,
										351226
									],
									[
										351274,
										351279
									],
									[
										351535,
										351540
									],
									[
										351594,
										351599
									],
									[
										351653,
										351658
									],
									[
										351703,
										351708
									],
									[
										351747,
										351752
									],
									[
										351805,
										351810
									],
									[
										351854,
										351859
									],
									[
										351913,
										351918
									],
									[
										352188,
										352193
									],
									[
										352241,
										352246
									],
									[
										352294,
										352299
									],
									[
										352338,
										352343
									],
									[
										352366,
										352371
									],
									[
										352418,
										352423
									],
									[
										352461,
										352466
									],
									[
										352514,
										352519
									],
									[
										352800,
										352805
									],
									[
										352859,
										352864
									],
									[
										352918,
										352923
									],
									[
										352968,
										352973
									],
									[
										353012,
										353017
									],
									[
										353070,
										353075
									],
									[
										353119,
										353124
									],
									[
										353178,
										353183
									],
									[
										353432,
										353437
									],
									[
										353485,
										353490
									],
									[
										353538,
										353543
									],
									[
										353582,
										353587
									],
									[
										353610,
										353615
									],
									[
										353662,
										353667
									],
									[
										353705,
										353710
									],
									[
										353758,
										353763
									],
									[
										354019,
										354024
									],
									[
										354078,
										354083
									],
									[
										354137,
										354142
									],
									[
										354187,
										354192
									],
									[
										354231,
										354236
									],
									[
										354289,
										354294
									],
									[
										354338,
										354343
									],
									[
										354397,
										354402
									],
									[
										354669,
										354674
									],
									[
										354722,
										354727
									],
									[
										354775,
										354780
									],
									[
										354819,
										354824
									],
									[
										354847,
										354852
									],
									[
										354899,
										354904
									],
									[
										354942,
										354947
									],
									[
										354995,
										355000
									],
									[
										355218,
										355223
									],
									[
										355277,
										355282
									],
									[
										355336,
										355341
									],
									[
										355386,
										355391
									],
									[
										355430,
										355435
									],
									[
										355488,
										355493
									],
									[
										355537,
										355542
									],
									[
										355596,
										355601
									],
									[
										355883,
										355888
									],
									[
										355936,
										355941
									],
									[
										355989,
										355994
									],
									[
										356033,
										356038
									],
									[
										356061,
										356066
									],
									[
										356113,
										356118
									],
									[
										356156,
										356161
									],
									[
										356209,
										356214
									],
									[
										356440,
										356445
									],
									[
										356499,
										356504
									],
									[
										356558,
										356563
									],
									[
										356608,
										356613
									],
									[
										356652,
										356657
									],
									[
										356710,
										356715
									],
									[
										356759,
										356764
									],
									[
										356818,
										356823
									],
									[
										357096,
										357101
									],
									[
										357149,
										357154
									],
									[
										357202,
										357207
									],
									[
										357246,
										357251
									],
									[
										357274,
										357279
									],
									[
										357326,
										357331
									],
									[
										357369,
										357374
									],
									[
										357422,
										357427
									],
									[
										357645,
										357650
									],
									[
										357704,
										357709
									],
									[
										357763,
										357768
									],
									[
										357813,
										357818
									],
									[
										357857,
										357862
									],
									[
										357915,
										357920
									],
									[
										357964,
										357969
									],
									[
										358023,
										358028
									],
									[
										358343,
										358348
									],
									[
										358396,
										358401
									],
									[
										358449,
										358454
									],
									[
										358493,
										358498
									],
									[
										358521,
										358526
									],
									[
										358573,
										358578
									],
									[
										358616,
										358621
									],
									[
										358669,
										358674
									],
									[
										358932,
										358937
									],
									[
										358991,
										358996
									],
									[
										359050,
										359055
									],
									[
										359100,
										359105
									],
									[
										359144,
										359149
									],
									[
										359202,
										359207
									],
									[
										359251,
										359256
									],
									[
										359310,
										359315
									],
									[
										359597,
										359602
									],
									[
										359650,
										359655
									],
									[
										359703,
										359708
									],
									[
										359747,
										359752
									],
									[
										359775,
										359780
									],
									[
										359827,
										359832
									],
									[
										359870,
										359875
									],
									[
										359923,
										359928
									],
									[
										360156,
										360161
									],
									[
										360215,
										360220
									],
									[
										360274,
										360279
									],
									[
										360324,
										360329
									],
									[
										360368,
										360373
									],
									[
										360426,
										360431
									],
									[
										360475,
										360480
									],
									[
										360534,
										360539
									],
									[
										360824,
										360829
									],
									[
										360877,
										360882
									],
									[
										360930,
										360935
									],
									[
										360974,
										360979
									],
									[
										361002,
										361007
									],
									[
										361054,
										361059
									],
									[
										361097,
										361102
									],
									[
										361150,
										361155
									],
									[
										361381,
										361386
									],
									[
										361440,
										361445
									],
									[
										361499,
										361504
									],
									[
										361549,
										361554
									],
									[
										361593,
										361598
									],
									[
										361651,
										361656
									],
									[
										361700,
										361705
									],
									[
										361759,
										361764
									],
									[
										362036,
										362041
									],
									[
										362089,
										362094
									],
									[
										362142,
										362147
									],
									[
										362186,
										362191
									],
									[
										362214,
										362219
									],
									[
										362266,
										362271
									],
									[
										362309,
										362314
									],
									[
										362362,
										362367
									],
									[
										362577,
										362582
									],
									[
										362636,
										362641
									],
									[
										362695,
										362700
									],
									[
										362745,
										362750
									],
									[
										362789,
										362794
									],
									[
										362847,
										362852
									],
									[
										362896,
										362901
									],
									[
										362955,
										362960
									],
									[
										363195,
										363200
									],
									[
										363326,
										363331
									],
									[
										363485,
										363490
									],
									[
										363585,
										363590
									],
									[
										363781,
										363786
									],
									[
										363947,
										363952
									],
									[
										364016,
										364021
									],
									[
										364139,
										364144
									],
									[
										364193,
										364198
									],
									[
										364344,
										364349
									],
									[
										364475,
										364480
									],
									[
										364493,
										364498
									],
									[
										364722,
										364727
									],
									[
										364739,
										364744
									],
									[
										364965,
										364970
									],
									[
										364982,
										364987
									],
									[
										365179,
										365184
									],
									[
										365410,
										365415
									],
									[
										365597,
										365602
									],
									[
										365757,
										365762
									],
									[
										365887,
										365892
									],
									[
										365906,
										365911
									],
									[
										365957,
										365962
									],
									[
										365982,
										365987
									],
									[
										366198,
										366203
									],
									[
										366394,
										366399
									],
									[
										366669,
										366674
									],
									[
										366904,
										366909
									],
									[
										367028,
										367033
									],
									[
										367214,
										367219
									],
									[
										367374,
										367379
									],
									[
										367504,
										367509
									],
									[
										367523,
										367528
									],
									[
										367574,
										367579
									],
									[
										367599,
										367604
									],
									[
										367789,
										367794
									],
									[
										368020,
										368025
									],
									[
										368201,
										368206
									],
									[
										368361,
										368366
									],
									[
										368491,
										368496
									],
									[
										368510,
										368515
									],
									[
										368561,
										368566
									],
									[
										368586,
										368591
									],
									[
										368762,
										368767
									],
									[
										368976,
										368981
									],
									[
										369030,
										369035
									],
									[
										369127,
										369132
									],
									[
										369311,
										369316
									],
									[
										369332,
										369337
									],
									[
										369527,
										369532
									],
									[
										369678,
										369683
									],
									[
										369841,
										369846
									],
									[
										370055,
										370060
									],
									[
										370158,
										370163
									],
									[
										370302,
										370307
									],
									[
										370415,
										370420
									],
									[
										370534,
										370539
									],
									[
										370651,
										370656
									],
									[
										370768,
										370773
									],
									[
										370823,
										370828
									],
									[
										370836,
										370841
									],
									[
										370912,
										370917
									],
									[
										371059,
										371064
									],
									[
										371080,
										371085
									],
									[
										371416,
										371421
									],
									[
										371774,
										371779
									],
									[
										371950,
										371955
									],
									[
										372157,
										372162
									],
									[
										372448,
										372457
									],
									[
										372660,
										372669
									],
									[
										372892,
										372901
									],
									[
										373122,
										373131
									],
									[
										373287,
										373296
									],
									[
										373502,
										373511
									],
									[
										373718,
										373727
									],
									[
										373934,
										373943
									],
									[
										374179,
										374188
									],
									[
										374358,
										374367
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								373745,
								373745
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 4,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 170663.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/net/bluetooth/hci_sock.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 25504,
						"regions":
						{
						},
						"selection":
						[
							[
								23534,
								23534
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 19336.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "/home/jack/projects/opensource/bluez/lib/hci.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 65299,
						"regions":
						{
						},
						"selection":
						[
							[
								22767,
								22767
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 15630.0,
						"zoom_level": 1.0
					},
					"stack_index": 16,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "/home/jack/projects/opensource/bluez/lib/hci.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 63685,
						"regions":
						{
						},
						"selection":
						[
							[
								2098,
								2098
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1146.0,
						"zoom_level": 1.0
					},
					"stack_index": 15,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "/home/jack/projects/opensource/bluez/lib/bluetooth/hci.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 63685,
						"regions":
						{
						},
						"selection":
						[
							[
								2098,
								2098
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1146.0,
						"zoom_level": 1.0
					},
					"stack_index": 14,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "/home/jack/projects/opensource/bluez/monitor/hcidump.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8707,
						"regions":
						{
						},
						"selection":
						[
							[
								4533,
								4533
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3135.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "/home/jack/projects/opensource/bluez/tools/amptest.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 14797,
						"regions":
						{
						},
						"selection":
						[
							[
								11253,
								11253
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 8575.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 14,
					"file": "hcilocal.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1940,
						"regions":
						{
						},
						"selection":
						[
							[
								1940,
								1940
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 814.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 15,
					"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 40016,
						"regions":
						{
						},
						"selection":
						[
							[
								3485,
								3485
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2142.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 16,
					"file": "/home/jack/projects/kernel/ubuntu/linux-3.13.0/include/net/bluetooth/hci_core.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 32490,
						"regions":
						{
						},
						"selection":
						[
							[
								2333,
								2333
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1445.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 17,
					"file": "/home/jack/projects/opensource/bluez/tools/btinfo.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7980,
						"regions":
						{
						},
						"selection":
						[
							[
								6697,
								6697
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 4767.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 18,
					"file": "/home/jack/projects/opensource/bluez/tools/cltest.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6182,
						"regions":
						{
						},
						"selection":
						[
							[
								5115,
								5115
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3475.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 19,
					"file": "/usr/include/dirent.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 12603,
						"regions":
						{
						},
						"selection":
						[
							[
								3435,
								3441
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1547.0,
						"zoom_level": 1.0
					},
					"stack_index": 20,
					"type": "text"
				},
				{
					"buffer": 20,
					"file": "/usr/include/x86_64-linux-gnu/bits/dirent.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1728,
						"regions":
						{
						},
						"selection":
						[
							[
								908,
								908
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 150.0,
						"zoom_level": 1.0
					},
					"stack_index": 19,
					"type": "text"
				},
				{
					"buffer": 21,
					"file": "/home/jack/projects/opensource/bluez/tools/hciconfig.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 47688,
						"regions":
						{
						},
						"selection":
						[
							[
								16575,
								16575
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 11524.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 22,
					"file": "/home/jack/projects/opensource/bluez/tools/hcitool.c",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 72309,
						"regions":
						{
						},
						"selection":
						[
							[
								2931,
								2931
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1146.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 25.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "bluetooth.sublime-project",
	"replace":
	{
		"height": 46.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"hcitool.c",
				"bluez/tools/hcitool.c"
			],
			[
				"hciconf",
				"bluez/tools/hciconfig.c"
			],
			[
				"make",
				"browser/Makefile"
			],
			[
				"hciconfig.c",
				"bluez/tools/hciconfig.c"
			],
			[
				"dirent",
				"include/dirent.h"
			],
			[
				"diren",
				"include/x86_64-linux-gnu/bits/dirent.h"
			],
			[
				"acpma",
				"b2apd/acp/src/AcpPortMapTables.c"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": false,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 282.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
